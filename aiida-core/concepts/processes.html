

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Concept &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/togglebutton.js"></script>
        <script src="../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Concept</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/concepts/processes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="concept">
<span id="concepts-processes"></span><h1>Concept<a class="headerlink" href="#concept" title="Permalink to this headline">¶</a></h1>
<p>Anything that runs in AiiDA is an instance of the <a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.process.Process" title="aiida.engine.processes.process.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> class.
The <code class="docutils literal notranslate"><span class="pre">Process</span></code> class contains all the information and logic to tell, whoever is handling it, how to run it to completion.
Typically the one responsible for running the processes is an instance of a <a class="reference internal" href="../apidoc/aiida.engine.html#aiida.engine.runners.Runner" title="aiida.engine.runners.Runner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Runner</span></code></a>.
This can be a local runner or one of the daemon runners in case of the daemon running the process.</p>
<p>In addition to those run instructions, any <code class="docutils literal notranslate"><span class="pre">Process</span></code> that has been executed needs some sort of record in the database to store what happened during its execution.
For example it needs to record what its exact inputs were, the log messages that were reported and what the final outputs were.
For this purpose, every process will utilize an instance of a sub class of the <a class="reference internal" href="../apidoc/aiida.orm.nodes.process.html#aiida.orm.nodes.process.ProcessNode" title="aiida.orm.nodes.process.ProcessNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessNode</span></code></a> class.
This <code class="docutils literal notranslate"><span class="pre">ProcessNode</span></code> class is a sub class of <a class="reference internal" href="../apidoc/aiida.orm.nodes.html#aiida.orm.nodes.Node" title="aiida.orm.nodes.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a> and serves as the record of the process’ execution in the database and by extension the provenance graph.</p>
<p>It is very important to understand this division of labor.
A <code class="docutils literal notranslate"><span class="pre">Process</span></code> describes how something should be run, and the <code class="docutils literal notranslate"><span class="pre">ProcessNode</span></code> serves as a mere record in the database of what actually happened during execution.
A good thing to remember is that while it is running, we are dealing with the <code class="docutils literal notranslate"><span class="pre">Process</span></code> and when it is finished we interact with the <code class="docutils literal notranslate"><span class="pre">ProcessNode</span></code>.</p>
<div class="section" id="process-types">
<span id="concepts-process-types"></span><h2>Process types<a class="headerlink" href="#process-types" title="Permalink to this headline">¶</a></h2>
<p>Processes in AiiDA come in two flavors:</p>
<blockquote>
<div><ul class="simple">
<li><p>Calculation-like</p></li>
<li><p>Workflow-like</p></li>
</ul>
</div></blockquote>
<p>The calculation-like processes have the capability to <em>create</em> data, whereas the workflow-like processes orchestrate other processes and have the ability to <em>return</em> data produced by calculations.
Again, this is a distinction that plays a big role in AiiDA and is crucial to understand.
For this reason, these different types of processes also get a different sub class of the <code class="docutils literal notranslate"><span class="pre">ProcessNode</span></code> class.
The hierarchy of these node classes and the link types that are allowed between them and <code class="docutils literal notranslate"><span class="pre">Data</span></code> nodes, is explained in detail in the <a class="reference internal" href="provenance.html#concepts-provenance-implementation"><span class="std std-ref">provenance implementation</span></a> documentation.</p>
<p>Currently, there are four types of processes in <code class="docutils literal notranslate"><span class="pre">aiida-core</span></code> and the following table shows with which node class it is represented in the provenance graph and what the process is used for.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 38%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Process class</p></th>
<th class="head"><p>Node class</p></th>
<th class="head"><p>Used for</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.calcjob.CalcJob" title="aiida.engine.processes.calcjobs.calcjob.CalcJob"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcJob</span></code></a></p></td>
<td><p><a class="reference internal" href="../apidoc/aiida.orm.nodes.process.calculation.html#aiida.orm.nodes.process.calculation.calcjob.CalcJobNode" title="aiida.orm.nodes.process.calculation.calcjob.CalcJobNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcJobNode</span></code></a></p></td>
<td><p>Calculations performed by external codes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../apidoc/aiida.engine.processes.workchains.html#aiida.engine.processes.workchains.workchain.WorkChain" title="aiida.engine.processes.workchains.workchain.WorkChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">WorkChain</span></code></a></p></td>
<td><p><a class="reference internal" href="../apidoc/aiida.orm.nodes.process.workflow.html#aiida.orm.nodes.process.workflow.workchain.WorkChainNode" title="aiida.orm.nodes.process.workflow.workchain.WorkChainNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">WorkChainNode</span></code></a></p></td>
<td><p>Workflows that run multiple calculations</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.functions.FunctionProcess" title="aiida.engine.processes.functions.FunctionProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionProcess</span></code></a></p></td>
<td><p><a class="reference internal" href="../apidoc/aiida.orm.nodes.process.calculation.html#aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode" title="aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcFunctionNode</span></code></a></p></td>
<td><p>Python functions decorated with the <code class="docutils literal notranslate"><span class="pre">&#64;calcfunction</span></code> decorator</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.functions.FunctionProcess" title="aiida.engine.processes.functions.FunctionProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionProcess</span></code></a></p></td>
<td><p><a class="reference internal" href="../apidoc/aiida.orm.nodes.process.workflow.html#aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode" title="aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">WorkFunctionNode</span></code></a></p></td>
<td><p>Python functions decorated with the <code class="docutils literal notranslate"><span class="pre">&#64;workfunction</span></code> decorator</p></td>
</tr>
</tbody>
</table>
<p>For basic information on the concept of a <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> or <code class="docutils literal notranslate"><span class="pre">calcfunction</span></code>, refer to the <a class="reference internal" href="calculations.html#concepts-calculations"><span class="std std-ref">calculations concept</span></a> and the same for the <code class="docutils literal notranslate"><span class="pre">WorkChain</span></code> and <code class="docutils literal notranslate"><span class="pre">workfunction</span></code> is described in the <a class="reference internal" href="workflows.html#concepts-workflows"><span class="std std-ref">workflows concept</span></a>.
After having read and understood the basic concept of calculation and workflow processes, detailed information on how to implement and use them can be found in the dedicated developing sections for <a class="reference internal" href="../working/calculations.html#working-calculations"><span class="std std-ref">calculations</span></a> and <a class="reference internal" href="../working/workflows.html#working-workflows"><span class="std std-ref">workflows</span></a>, respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A <code class="docutils literal notranslate"><span class="pre">FunctionProcess</span></code> is never explicitly implemented but will be generated dynamically by the engine when a python function decorated with a <a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.functions.calcfunction" title="aiida.engine.processes.functions.calcfunction"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcfunction()</span></code></a> or <a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.functions.workfunction" title="aiida.engine.processes.functions.workfunction"><code class="xref py py-func docutils literal notranslate"><span class="pre">workfunction()</span></code></a> is run.</p>
</div>
</div>
<div class="section" id="process-state">
<span id="concepts-process-state"></span><h2>Process state<a class="headerlink" href="#process-state" title="Permalink to this headline">¶</a></h2>
<p>Each instance of a <code class="docutils literal notranslate"><span class="pre">Process</span></code> class that is being executed has a process state.
This property tells you about the current status of the process.
It is stored in the instance of the <code class="docutils literal notranslate"><span class="pre">Process</span></code> itself and the workflow engine, the <code class="docutils literal notranslate"><span class="pre">plumpy</span></code> library, operates only on that value.
However, the <code class="docutils literal notranslate"><span class="pre">Process</span></code> instance ‘dies’ as soon as it is terminated, therefore the process state is also written to the calculation node that the process uses as its database record, under the <code class="docutils literal notranslate"><span class="pre">process_state</span></code> attribute.
The process can be in one of six states:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><em>Active</em></p></th>
<th class="head"><p><em>Terminated</em></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Created</p></td>
<td><p>Killed</p></td>
</tr>
<tr class="row-odd"><td><p>Running</p></td>
<td><p>Excepted</p></td>
</tr>
<tr class="row-even"><td><p>Waiting</p></td>
<td><p>Finished</p></td>
</tr>
</tbody>
</table>
<p>The three states in the left column are ‘active’ states, whereas the right column displays the three ‘terminal’ states.
Once a process reaches a terminal state, it will never leave it; its execution is permanently terminated.
When a process is first created, it is put in the <code class="docutils literal notranslate"><span class="pre">Created</span></code> state.
As soon as it is picked up by a runner and it is active, it will be in the <code class="docutils literal notranslate"><span class="pre">Running</span></code> state.
If the process is waiting for another process, that it called, to be finished, it will be in the <code class="docutils literal notranslate"><span class="pre">Waiting</span></code> state.
If a process is in the <code class="docutils literal notranslate"><span class="pre">Killed</span></code> state, it means the user issued a command to kill it, or its parent process was killed.
The <code class="docutils literal notranslate"><span class="pre">Excepted</span></code> state indicates that during execution an exception occurred that was not caught and the process was unexpectedly terminated.
The final option is the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> state, which means that the process was successfully executed, and the execution was nominal.
Note that this does not automatically mean that the result of the process can also be considered to be successful, it was just executed without any problems.</p>
<p>To distinguish between a successful and a failed execution, there is the <a class="reference internal" href="#concepts-process-exit-codes"><span class="std std-ref">exit status</span></a>.
This is another attribute that is stored in the node of the process and is an integer that can be set by the process.
A <code class="docutils literal notranslate"><span class="pre">0</span></code> (zero) means that the result of the process was successful, and a non-zero value indicates a failure.
All the process nodes used by the various processes are sub-classes of <a class="reference internal" href="../apidoc/aiida.orm.nodes.process.html#aiida.orm.nodes.process.ProcessNode" title="aiida.orm.nodes.process.ProcessNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessNode</span></code></a>, which defines handy properties to query the process state and exit status.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">process_state</span></code></p></td>
<td><p>Returns the current process state</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">exit_status</span></code></p></td>
<td><p>Returns the exit status, or None if not set</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">exit_message</span></code></p></td>
<td><p>Returns the exit message, or None if not set</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">is_terminated</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the process was either <code class="docutils literal notranslate"><span class="pre">Killed</span></code>, <code class="docutils literal notranslate"><span class="pre">Excepted</span></code>, or <code class="docutils literal notranslate"><span class="pre">Finished</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">is_killed</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the process is <code class="docutils literal notranslate"><span class="pre">Killed</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">is_excepted</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the process is <code class="docutils literal notranslate"><span class="pre">Excepted</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">is_finished</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the process is <code class="docutils literal notranslate"><span class="pre">Finished</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">is_finished_ok</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the process is <code class="docutils literal notranslate"><span class="pre">Finished</span></code> and the <code class="docutils literal notranslate"><span class="pre">exit_status</span></code> is equal to zero</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">is_failed</span></code></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the process is <code class="docutils literal notranslate"><span class="pre">Finished</span></code> and the <code class="docutils literal notranslate"><span class="pre">exit_status</span></code> is non-zero</p></td>
</tr>
</tbody>
</table>
<p>When you load a calculation node from the database, you can use these property methods to inquire about its state and exit status.</p>
</div>
<div class="section" id="process-exit-codes">
<span id="concepts-process-exit-codes"></span><h2>Process exit codes<a class="headerlink" href="#process-exit-codes" title="Permalink to this headline">¶</a></h2>
<p>The previous section about the process state showed that a process that is <code class="docutils literal notranslate"><span class="pre">Finished</span></code> does not say anything about whether the result is ‘successful’ or ‘failed’.
The <code class="docutils literal notranslate"><span class="pre">Finished</span></code> state means nothing more than that the engine succeeded in running the process to the end of execution, without it encountering exceptions or being killed.
To distinguish between a ‘successful’ and ‘failed’ process, an ‘exit status’ can be defined.
The <a class="reference external" href="https://en.wikipedia.org/wiki/Exit_status">exit status is a common concept in programming</a> and is a small integer, where zero means that the result of the process was successful, and a non-zero value indicates a failure.
By default a process that terminates nominally will get a <code class="docutils literal notranslate"><span class="pre">0</span></code> (zero) exit status.
To mark a process as failed, one can return an instance of the <a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.exit_code.ExitCode" title="aiida.engine.processes.exit_code.ExitCode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExitCode</span></code></a> named tuple, which allows to set an integer <code class="docutils literal notranslate"><span class="pre">exit_status</span></code> and a string message as <code class="docutils literal notranslate"><span class="pre">exit_message</span></code>.
When the engine receives such an <code class="docutils literal notranslate"><span class="pre">ExitCode</span></code> as the return value from a process, it will set the exit status and message on the corresponding attributes of the process node representing the process in the provenance graph.
How exit codes can be defined and returned depends on the process type and will be documented in detail in the respective <a class="reference internal" href="../working/calculations.html#working-calculations"><span class="std std-ref">calculation</span></a> and <a class="reference internal" href="../working/workflows.html#working-workflows"><span class="std std-ref">workflow</span></a> development sections.</p>
</div>
<div class="section" id="process-lifetime">
<span id="concepts-process-lifetime"></span><h2>Process lifetime<a class="headerlink" href="#process-lifetime" title="Permalink to this headline">¶</a></h2>
<p>The lifetime of a process is defined as the time from the moment it is launched until it reaches a <a class="reference internal" href="#concepts-process-state"><span class="std std-ref">terminal state</span></a>.</p>
<div class="section" id="process-and-node-distinction">
<span id="concepts-process-node-distinction"></span><h3>Process and node distinction<a class="headerlink" href="#process-and-node-distinction" title="Permalink to this headline">¶</a></h3>
<p>As explained in the <a class="reference internal" href="#concepts-processes"><span class="std std-ref">introduction of this section</span></a>, there is a clear and important distinction between the ‘process’ and the ‘node’ that represents its execution in the provenance graph.
When a process is launched, an instance of the <code class="docutils literal notranslate"><span class="pre">Process</span></code> class is created in memory which will be propagated to completion by the responsible runner.
This ‘process’ instance only exists in the memory of the python interpreter that it is running in, for example that of a daemon runner, and so we cannot directly inspect its state.
That is why the process will write any of its state changes to the corresponding node representing it in the provenance graph.
In this way, the node acts as a ‘proxy’ or a mirror image that reflects the state of the process in memory.
This means that the output of many of the <code class="docutils literal notranslate"><span class="pre">verdi</span></code> commands, such as <code class="docutils literal notranslate"><span class="pre">verdi</span> <span class="pre">process</span> <span class="pre">list</span></code>, do not actually show the state of the process instances, but rather the state of the node to which they have last written their state.</p>
</div>
<div class="section" id="process-tasks">
<h3>Process tasks<a class="headerlink" href="#process-tasks" title="Permalink to this headline">¶</a></h3>
<p>The previous section explained how launching a process means creating an instance of the <code class="docutils literal notranslate"><span class="pre">Process</span></code> class in memory.
When the process is being ‘ran’ (see the section on <a class="reference internal" href="../working/processes.html#working-processes-launch"><span class="std std-ref">launching processes</span></a> for more details) that is to say in a local interpreter, the particular process instance will die as soon as the interpreter dies.
This is what often makes ‘submitting’ the preferred method of launching a process.
When a process is ‘submitted’, an instance of the <code class="docutils literal notranslate"><span class="pre">Process</span></code> is created, along with the node that represents it in the database, and its state is then persisted to the database.
This is called a ‘process checkpoint’, more information on which <a class="reference internal" href="#concepts-process-checkpoints"><span class="std std-ref">will follow later</span></a>.
Subsequently, the process instance is shutdown and a ‘continuation task’ is sent to the process queue of RabbitMQ.
This task is simply a small message that just contains an identifier for the process.</p>
<p>All the daemon runners, when they are launched, subscribe to the process queue and RabbitMQ will distribute the continuation tasks to them as they come in, making sure that each task is only sent to one runner at a time.
The receiving daemon runner can restore the process instance in memory from the checkpoint that was stored in the database and continue the execution.
As soon as the process reaches a terminal state, the daemon runner will acknowledge to RabbitMQ that the task has been completed.
Until the runner has confirmed that a task is completed, RabbitMQ will consider the task as incomplete.
If a daemon runner is shutdown or dies before it got the chance to finish running a process, the task will automatically be requeued by RabbitMQ and sent to another daemon runner.
Together with the fact that all the tasks in the process queue are persisted to disk by RabbitMQ, guarantees that once a continuation task has been sent to RabbitMQ, it will at some point be finished, while allowing the machine to be shutdown.</p>
<p>Each daemon runner has a maximum number of tasks that it can run concurrently, which means that if there are more active tasks than available slots, some of the tasks will remain queued.
Processes, whose task is in the queue and not with any runner, though technically ‘active’ as they are not terminated, are not actually being run at the moment.
While a process is not actually being run, i.e. it is not in memory with a runner, one cannot interact with it.
Similarly, as soon as the task disappears, either because the process was intentionally terminated (or unintentionally), the process will never continue running again.</p>
</div>
<div class="section" id="process-checkpoints">
<span id="concepts-process-checkpoints"></span><h3>Process checkpoints<a class="headerlink" href="#process-checkpoints" title="Permalink to this headline">¶</a></h3>
<p>A process checkpoint is a complete representation of a <code class="docutils literal notranslate"><span class="pre">Process</span></code> instance in memory that can be stored in the database.
Since it is a complete representation, the <code class="docutils literal notranslate"><span class="pre">Process</span></code> instance can also be fully reconstructed from such a checkpoint.
At any state transition of a process, a checkpoint will be created, by serializing the process instance and storing it as an attribute on the corresponding process node.
This mechanism is the final cog in the machine, together with the persisted process queue of RabbitMQ as explained in the previous section, that allows processes to continue after the machine they were running on, has been shutdown and restarted.</p>
</div>
</div>
<div class="section" id="process-sealing">
<span id="concepts-process-sealing"></span><h2>Process sealing<a class="headerlink" href="#process-sealing" title="Permalink to this headline">¶</a></h2>
<p>One of the cardinal rules of AiiDA is that once a node is <em>stored</em>, it is immutable, which means that its attributes can no longer be changed.
This rule is a problem for processes, however, since in order to be able to start running it, its corresponding process node first has to be stored.
However, at that point its attributes, such as the process state or other mutable attributes, can no longer be changed by the engine throughout the lifetime of the corresponding process.
To overcome this limitation, the concept of <em>updatable</em> attributes is introduced.
These are special attributes that are allowed to be changed <em>even</em> when the process node is already stored <em>and</em> the corresponding process is still active.
To mark the point where a process is terminated and even the updatable attributes on the process node are to be considered immutable, the node is <em>sealed</em>.
A sealed process node behaves exactly like a normal stored node, as in <em>all</em> of its attributes are immutable.
In addition, once a process node is sealed, no more incoming or outgoing links can be attached to it.
Unsealed process nodes can also not be exported, because they belong to processes that are still active.
Note that the sealing concept does not apply to data nodes and they are exportable as soon as they are stored.
To determine whether a process node is sealed, one can use the property <a class="reference internal" href="../apidoc/aiida.orm.utils.html#aiida.orm.utils.mixins.Sealable.is_sealed" title="aiida.orm.utils.mixins.Sealable.is_sealed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_sealed()</span></code></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>