

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.common package &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/togglebutton.js"></script>
        <script src="../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>aiida.common package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/apidoc/aiida.common.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-aiida.common">
<span id="aiida-common-package"></span><h1>aiida.common package<a class="headerlink" href="#module-aiida.common" title="Permalink to this headline">¶</a></h1>
<p>Common data structures, utility classes and functions</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Modules in this sub package have to run without a loaded database environment</p>
</div>
<dl class="class">
<dt id="aiida.common.CalcJobState">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">CalcJobState</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcJobState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CalcJobState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>The sub state of a CalcJobNode while its Process is in an active state (i.e. Running or Waiting).</p>
<dl class="attribute">
<dt id="aiida.common.CalcJobState.PARSING">
<code class="sig-name descname">PARSING</code><em class="property"> = 'parsing'</em><a class="headerlink" href="#aiida.common.CalcJobState.PARSING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.RETRIEVING">
<code class="sig-name descname">RETRIEVING</code><em class="property"> = 'retrieving'</em><a class="headerlink" href="#aiida.common.CalcJobState.RETRIEVING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.SUBMITTING">
<code class="sig-name descname">SUBMITTING</code><em class="property"> = 'submitting'</em><a class="headerlink" href="#aiida.common.CalcJobState.SUBMITTING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.UPLOADING">
<code class="sig-name descname">UPLOADING</code><em class="property"> = 'uploading'</em><a class="headerlink" href="#aiida.common.CalcJobState.UPLOADING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.WITHSCHEDULER">
<code class="sig-name descname">WITHSCHEDULER</code><em class="property"> = 'withscheduler'</em><a class="headerlink" href="#aiida.common.CalcJobState.WITHSCHEDULER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CalcJobState.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.CalcInfo">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">CalcInfo</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CalcInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This object will store the data returned by the calculation plugin and to be
passed to the ExecManager.</p>
<p>In the following descriptions all paths have to be considered relative</p>
<ul>
<li><dl>
<dt>retrieve_list: a list of strings or tuples that indicate files that are to be retrieved from the remote</dt><dd><p>after the calculation has finished and stored in the repository in a FolderData.
If the entry in the list is just a string, it is assumed to be the filepath on the remote and it will
be copied to ‘.’ of the repository with name os.path.split(item)[1]
If the entry is a tuple it is expected to have the following format</p>
<blockquote>
<div><p>(‘remotepath’, ‘localpath’, depth)</p>
</div></blockquote>
<p>If the ‘remotepath’ is a file or folder, it will be copied in the repository to ‘localpath’.
However, if the ‘remotepath’ contains file patterns with wildcards, the ‘localpath’ should be set to ‘.’
and the depth parameter should be an integer that decides the localname. The ‘remotepath’ will be split on
file separators and the local filename will be determined by joining the N last elements, where N is
given by the depth variable.</p>
<p>Example: (‘some/remote/path/files/pattern*[0-9].xml’, ‘.’, 2)</p>
<p>Will result in all files that match the pattern to be copied to the local repository with path</p>
<blockquote>
<div><p>‘files/pattern*[0-9].xml’</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>retrieve_temporary_list: a list of strings or tuples that indicate files that will be retrieved</dt><dd><p>and stored temporarily in a FolderData, that will be available only during the parsing call.
The format of the list is the same as that of ‘retrieve_list’</p>
</dd>
</dl>
</li>
<li><dl>
<dt>retrieve_singlefile_list: a list of tuples with format</dt><dd><p>(‘linkname_from calc to singlefile’, ‘subclass of singlefile’, ‘filename’)
Each tuple represents a file that will be retrieved from cluster and saved in SinglefileData nodes</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.0.0: </span>Will be removed in <cite>v2.0.0</cite>, use <cite>retrieve_temporary_list</cite> instead.</p>
</div>
</dd>
</dl>
</li>
<li><p>local_copy_list: a list of tuples with format (‘node_uuid’, ‘filename’, relativedestpath’)</p></li>
<li><p>remote_copy_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p></li>
<li><p>remote_symlink_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p></li>
<li><dl class="simple">
<dt>provenance_exclude_list: a sequence of relative paths of files in the sandbox folder of a <cite>CalcJob</cite> instance that</dt><dd><p>should not be stored permanantly in the repository folder of the corresponding <cite>CalcJobNode</cite> that will be
created, but should only be copied to the remote working directory on the target computer. This is useful for
input files that should be copied to the working directory but should not be copied as well to the repository
either, for example, because they contain proprietary information or because they are big and their content is
already indirectly present in the repository through one of the data nodes passed as input to the calculation.</p>
</dd>
</dl>
</li>
<li><p>codes_info: a list of dictionaries used to pass the info of the execution of a code</p></li>
<li><p>codes_run_mode: a string used to specify the order in which multi codes can be executed</p></li>
</ul>
<dl class="attribute">
<dt id="aiida.common.CalcInfo.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CalcInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcInfo._default_fields">
<code class="sig-name descname">_default_fields</code><em class="property"> = ('job_environment', 'email', 'email_on_started', 'email_on_terminated', 'uuid', 'prepend_text', 'append_text', 'num_machines', 'num_mpiprocs_per_machine', 'priority', 'max_wallclock_seconds', 'max_memory_kb', 'rerunnable', 'retrieve_list', 'retrieve_temporary_list', 'retrieve_singlefile_list', 'local_copy_list', 'remote_copy_list', 'remote_symlink_list', 'provenance_exclude_list', 'codes_info', 'codes_run_mode')</em><a class="headerlink" href="#aiida.common.CalcInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.CodeInfo">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">CodeInfo</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CodeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This attribute-dictionary contains the information needed to execute a code.
Possible attributes are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">cmdline_params</span></code>: a list of strings, containing parameters to be written on
the command line right after the call to the code, as for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">...</span> <span class="o">&lt;</span> <span class="n">stdin</span> <span class="o">&gt;</span> <span class="n">stdout</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stdin_name</span></code>: (optional) the name of the standard input file. Note, it is
only possible to use the stdin with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">stdin_name</span>
</pre></div>
</div>
<p>If no stdin_name is specified, the string “&lt; stdin_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&lt;’ if stdin_name is specified;
if that is needed, avoid stdin_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stdout_name</span></code>: (optional) the name of the standard output file. Note, it is
only possible to pass output to stdout_name with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span>
</pre></div>
</div>
<p>If no stdout_name is specified, the string “&gt; stdout_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&gt;’ if stdout_name is specified;
if that is needed, avoid stdout_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stderr_name</span></code>: (optional) a string, the name of the error file of the code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">join_files</span></code>: (optional) if True, redirects the error to the output file.
If join_files=True, the code will be called as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;&amp;</span><span class="mi">1</span>
</pre></div>
</div>
<p>otherwise, if join_files=False and stderr is passed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">stderr_name</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">withmpi</span></code>: if True, executes the code with mpirun (or another MPI installed
on the remote computer)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">code_uuid</span></code>: the uuid of the code associated to the CodeInfo</p></li>
</ul>
<dl class="attribute">
<dt id="aiida.common.CodeInfo.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CodeInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CodeInfo._default_fields">
<code class="sig-name descname">_default_fields</code><em class="property"> = ('cmdline_params', 'stdin_name', 'stdout_name', 'stderr_name', 'join_files', 'withmpi', 'code_uuid')</em><a class="headerlink" href="#aiida.common.CodeInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.CodeRunMode">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">CodeRunMode</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeRunMode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CodeRunMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.IntEnum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a></p>
<p>Enum to indicate the way the codes of a calculation should be run.</p>
<p>For PARALLEL, the codes for a given calculation will be run in parallel by running them in the background:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>For the SERIAL option, codes will be executed sequentially by running for example the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.CodeRunMode.PARALLEL">
<code class="sig-name descname">PARALLEL</code><em class="property"> = 1</em><a class="headerlink" href="#aiida.common.CodeRunMode.PARALLEL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CodeRunMode.SERIAL">
<code class="sig-name descname">SERIAL</code><em class="property"> = 0</em><a class="headerlink" href="#aiida.common.CodeRunMode.SERIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CodeRunMode.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CodeRunMode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.AiidaException">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">AiidaException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#AiidaException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AiidaException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<p>Base class for all AiiDA exceptions.</p>
<p>Each module will have its own subclass, inherited from this
(e.g. ExecManagerException, TransportException, …)</p>
<dl class="attribute">
<dt id="aiida.common.AiidaException.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.AiidaException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.AiidaException.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.AiidaException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.NotExistent">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">NotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#NotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.NotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the required entity does not exist.</p>
<dl class="attribute">
<dt id="aiida.common.NotExistent.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.NotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MultipleObjectsError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">MultipleObjectsError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleObjectsError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MultipleObjectsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when more than one entity is found in the DB, but only one was
expected.</p>
<dl class="attribute">
<dt id="aiida.common.MultipleObjectsError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MultipleObjectsError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.RemoteOperationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">RemoteOperationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#RemoteOperationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.RemoteOperationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an error in a remote operation occurs, as in a failed kill()
of a scheduler job.</p>
<dl class="attribute">
<dt id="aiida.common.RemoteOperationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.RemoteOperationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ContentNotExistent">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ContentNotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ContentNotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ContentNotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.NotExistent" title="aiida.common.exceptions.NotExistent"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.NotExistent</span></code></a></p>
<p>Raised when trying to access an attribute, a key or a file in the result
nodes that is not present</p>
<dl class="attribute">
<dt id="aiida.common.ContentNotExistent.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ContentNotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.FailedError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">FailedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FailedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FailedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when accessing a calculation that is in the FAILED status</p>
<dl class="attribute">
<dt id="aiida.common.FailedError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.FailedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.StoringNotAllowed">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">StoringNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#StoringNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.StoringNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to store an unstorable node (e.g. a base Node class)</p>
<dl class="attribute">
<dt id="aiida.common.StoringNotAllowed.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.StoringNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ModificationNotAllowed">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ModificationNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ModificationNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ModificationNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to modify a field, object, property, … that should not
be modified.</p>
<dl class="attribute">
<dt id="aiida.common.ModificationNotAllowed.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ModificationNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.IntegrityError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">IntegrityError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IntegrityError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.IntegrityError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when there is an underlying data integrity error.  This can be database related
or a general data integrity error.  This can happen if, e.g., a foreign key check fails.
See PEP 249 for details.</p>
<dl class="attribute">
<dt id="aiida.common.IntegrityError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.IntegrityError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.UniquenessError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">UniquenessError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UniquenessError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.UniquenessError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to violate a uniqueness constraint (on the
DB, for instance).</p>
<dl class="attribute">
<dt id="aiida.common.UniquenessError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.UniquenessError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.EntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">EntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#EntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.EntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an entry point cannot be uniquely resolved and imported.</p>
<dl class="attribute">
<dt id="aiida.common.EntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.EntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MissingEntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">MissingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MissingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point is not registered with the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.MissingEntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MissingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MultipleEntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">MultipleEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MultipleEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point cannot uniquely be resolved by the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.MultipleEntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MultipleEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.LoadingEntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">LoadingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LoadingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.LoadingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the resource corresponding to requested entry point cannot be imported.</p>
<dl class="attribute">
<dt id="aiida.common.LoadingEntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.LoadingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InvalidEntryPointTypeError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">InvalidEntryPointTypeError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InvalidEntryPointTypeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InvalidEntryPointTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when a loaded entry point has a type that is not supported by the corresponding entry point group.</p>
<dl class="attribute">
<dt id="aiida.common.InvalidEntryPointTypeError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InvalidEntryPointTypeError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InvalidOperation">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">InvalidOperation</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InvalidOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InvalidOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>The allowed operation is not valid (e.g., when trying to add a non-internal attribute
before saving the entry), or deleting an entry that is protected (e.g.,
because it is referenced by foreign keys)</p>
<dl class="attribute">
<dt id="aiida.common.InvalidOperation.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InvalidOperation.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ParsingError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Generic error raised when there is a parsing error</p>
<dl class="attribute">
<dt id="aiida.common.ParsingError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InternalError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">InternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an internal error of AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.InternalError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.PluginInternalError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">PluginInternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#PluginInternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.PluginInternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.InternalError" title="aiida.common.exceptions.InternalError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.InternalError</span></code></a></p>
<p>Error raised when there is an internal error which is due to a plugin
and not to the AiiDA infrastructure.</p>
<dl class="attribute">
<dt id="aiida.common.PluginInternalError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.PluginInternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ValidationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an error during the validation phase
of a property.</p>
<dl class="attribute">
<dt id="aiida.common.ValidationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ConfigurationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is a configuration error in AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.ConfigurationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ProfileConfigurationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ProfileConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ProfileConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ProfileConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when a wrong/inexistent profile is requested.</p>
<dl class="attribute">
<dt id="aiida.common.ProfileConfigurationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ProfileConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MissingConfigurationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">MissingConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MissingConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file is missing.</p>
<dl class="attribute">
<dt id="aiida.common.MissingConfigurationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MissingConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ConfigurationVersionError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">ConfigurationVersionError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationVersionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ConfigurationVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file version is not
compatible with the current version.</p>
<dl class="attribute">
<dt id="aiida.common.ConfigurationVersionError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ConfigurationVersionError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.IncompatibleDatabaseSchema">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">IncompatibleDatabaseSchema</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IncompatibleDatabaseSchema"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.IncompatibleDatabaseSchema" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Raised when the database schema is incompatible with that of the code.</p>
<dl class="attribute">
<dt id="aiida.common.IncompatibleDatabaseSchema.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.IncompatibleDatabaseSchema.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.DbContentError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">DbContentError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#DbContentError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DbContentError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the content of the DB is not valid.
This should never happen if the user does not play directly
with the DB.</p>
<dl class="attribute">
<dt id="aiida.common.DbContentError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.DbContentError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InputValidationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">InputValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InputValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InputValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ValidationError" title="aiida.common.exceptions.ValidationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ValidationError</span></code></a></p>
<p>The input data for a calculation did not validate (e.g., missing
required input data, wrong data, …)</p>
<dl class="attribute">
<dt id="aiida.common.InputValidationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InputValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.FeatureNotAvailable">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">FeatureNotAvailable</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureNotAvailable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FeatureNotAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested from a plugin, that is not available.</p>
<dl class="attribute">
<dt id="aiida.common.FeatureNotAvailable.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.FeatureNotAvailable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.FeatureDisabled">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">FeatureDisabled</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureDisabled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FeatureDisabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested, but the user has chosen to disable
it (e.g., for submissions on disabled computers).</p>
<dl class="attribute">
<dt id="aiida.common.FeatureDisabled.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.FeatureDisabled.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.LicensingException">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">LicensingException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LicensingException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.LicensingException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when requirements for data licensing are not met.</p>
<dl class="attribute">
<dt id="aiida.common.LicensingException.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.LicensingException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.TestsNotAllowedError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">TestsNotAllowedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TestsNotAllowedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.TestsNotAllowedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when tests are required to be run/loaded, but we are not in a testing environment.</p>
<p>This is to prevent data loss.</p>
<dl class="attribute">
<dt id="aiida.common.TestsNotAllowedError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.TestsNotAllowedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.UnsupportedSpeciesError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">UnsupportedSpeciesError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UnsupportedSpeciesError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.UnsupportedSpeciesError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
<p>Raised when StructureData operations are fed species that are not supported by AiiDA such as Deuterium</p>
<dl class="attribute">
<dt id="aiida.common.UnsupportedSpeciesError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.UnsupportedSpeciesError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.UnsupportedSpeciesError.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.UnsupportedSpeciesError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.TransportTaskException">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">TransportTaskException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TransportTaskException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.TransportTaskException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a TransportTask, an task to be completed by the engine that requires transport, fails</p>
<dl class="attribute">
<dt id="aiida.common.TransportTaskException.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.TransportTaskException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.OutputParsingError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">OutputParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#OutputParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.OutputParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ParsingError" title="aiida.common.exceptions.ParsingError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ParsingError</span></code></a></p>
<p>Can be raised by a Parser when it fails to parse the output generated by a <cite>CalcJob</cite> process.</p>
<dl class="attribute">
<dt id="aiida.common.OutputParsingError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.OutputParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.AttributeDict">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">AttributeDict</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
<p>This class internally stores values in a dictionary, but exposes
the keys also as attributes, i.e. asking for attrdict.key
will return the value of attrdict[‘key’] and so on.</p>
<p>Raises an AttributeError if the key does not exist, when called as an attribute,
while the usual KeyError if the key does not exist and the dictionary syntax is
used.</p>
<dl class="method">
<dt id="aiida.common.AttributeDict.__deepcopy__">
<code class="sig-name descname">__deepcopy__</code><span class="sig-paren">(</span><em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__deepcopy__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__deepcopy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Deep copy.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__delattr__">
<code class="sig-name descname">__delattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__delattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a key as an attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.8)"><strong>AttributeError</strong></a> – if the attribute does not correspond to an existing key.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.AttributeDict.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.extendeddicts', '__doc__': &quot;\n    This class internally stores values in a dictionary, but exposes\n    the keys also as attributes, i.e. asking for attrdict.key\n    will return the value of attrdict['key'] and so on.\n\n    Raises an AttributeError if the key does not exist, when called as an attribute,\n    while the usual KeyError if the key does not exist and the dictionary syntax is\n    used.\n    &quot;, '__init__': &lt;function AttributeDict.__init__&gt;, '__repr__': &lt;function AttributeDict.__repr__&gt;, '__getattr__': &lt;function AttributeDict.__getattr__&gt;, '__setattr__': &lt;function AttributeDict.__setattr__&gt;, '__delattr__': &lt;function AttributeDict.__delattr__&gt;, '__deepcopy__': &lt;function AttributeDict.__deepcopy__&gt;, '__getstate__': &lt;function AttributeDict.__getstate__&gt;, '__setstate__': &lt;function AttributeDict.__setstate__&gt;, '__dir__': &lt;function AttributeDict.__dir__&gt;, '__dict__': &lt;attribute '__dict__' of 'AttributeDict' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'AttributeDict' objects&gt;})</em><a class="headerlink" href="#aiida.common.AttributeDict.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__dir__">
<code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__getattr__">
<code class="sig-name descname">__getattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a key as an attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.8)"><strong>AttributeError</strong></a> – if the attribute does not correspond to an existing key.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__getstate__">
<code class="sig-name descname">__getstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__getstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively turn the <cite>dict</cite> and all its nested dictionaries into <cite>AttributeDict</cite> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.AttributeDict.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.AttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the object.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__setattr__">
<code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__setstate__">
<code class="sig-name descname">__setstate__</code><span class="sig-paren">(</span><em class="sig-param">dictionary</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.AttributeDict.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.AttributeDict.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.FixedFieldsAttributeDict">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">FixedFieldsAttributeDict</code><span class="sig-paren">(</span><em class="sig-param">init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with filtering
of valid attributes.
This is only the base class, without valid attributes;
use a derived class to do the actual work.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">FixedFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_valid_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__dir__">
<code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively turn the <cite>dict</cite> and all its nested dictionaries into <cite>AttributeDict</cite> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.FixedFieldsAttributeDict.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__setattr__">
<code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.FixedFieldsAttributeDict._valid_fields">
<code class="sig-name descname">_valid_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict._valid_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.get_valid_fields">
<em class="property">classmethod </em><code class="sig-name descname">get_valid_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.get_valid_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.get_valid_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of valid fields.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.DefaultFieldsAttributeDict">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">DefaultFieldsAttributeDict</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with an
internal value storing the ‘default’ keys to be distinguished
from extra fields.</p>
<p>Extra methods defaultkeys() and extrakeys() divide the set returned by
keys() in default keys (i.e. those defined at definition time)
and other keys.
There is also a method get_default_fields() to return the internal list.</p>
<p>Moreover, for undefined default keys, it returns None instead of raising a
KeyError/AttributeError exception.</p>
<p>Remember to define the _default_fields in a subclass!
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">DefaultFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_default_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the validate() method is called, it calls in turn all validate_KEY
methods, where KEY is one of the default keys.
If the method is not present, the field is considered to be always valid.
Each validate_KEY method should accept a single argument ‘value’ that will
contain the value to be checked.</p>
<p>It raises a ValidationError if any of the validate_KEY
function raises an exception, otherwise it simply returns.
NOTE: the <cite>validate_*</cite> functions are called also for unset fields, so if the
field can be empty on validation, you have to start your validation
function with something similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Decide behavior if I set to None a field.
Current behavior, if
<code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance and ‘def_field’ one of the default fields, that is
undefined, we get:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: ‘whatever’</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> does NOT contain ‘def_field’</p></li>
</ul>
<p>if we do <code class="docutils literal notranslate"><span class="pre">a.def_field</span> <span class="pre">=</span> <span class="pre">None</span></code>, then the behavior becomes</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: None</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> DOES contain ‘def_field’</p></li>
</ul>
<p>See if we want that setting a default field to None means deleting it.</p>
</div>
<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None instead of raising an exception if the key does not exist
but is in the list of default fields.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.DefaultFieldsAttributeDict.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.__setattr__">
<code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.DefaultFieldsAttributeDict._default_fields">
<code class="sig-name descname">_default_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.defaultkeys">
<code class="sig-name descname">defaultkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.defaultkeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.defaultkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default keys defined in the instance.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.extrakeys">
<code class="sig-name descname">extrakeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.extrakeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.extrakeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extra keys defined in the instance.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.get_default_fields">
<em class="property">classmethod </em><code class="sig-name descname">get_default_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.get_default_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.get_default_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of default fields, either defined in the instance or not.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.validate">
<code class="sig-name descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the keys, if any <code class="docutils literal notranslate"><span class="pre">validate_*</span></code> method is available.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.GraphTraversalRule">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">GraphTraversalRule</code><span class="sig-paren">(</span><em class="sig-param">link_type</em>, <em class="sig-param">direction</em>, <em class="sig-param">toggleable</em>, <em class="sig-param">default</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a></p>
<p>A namedtuple that defines a graph traversal rule.</p>
<p>When starting from a certain sub set of nodes, the graph traversal rules specify which links should be followed to
add adjacent nodes to finally arrive at a set of nodes that represent a valid and consistent sub graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>link_type</strong> – the <cite>LinkType</cite> that the rule applies to</p></li>
<li><p><strong>direction</strong> – whether the link type should be followed backwards or forwards</p></li>
<li><p><strong>toggleable</strong> – boolean to indicate whether the rule can be changed from the default value. If this is <cite>False</cite> it
means the default value can never be changed as it will result in an inconsistent graph.</p></li>
<li><p><strong>default</strong> – boolean, the default value of the rule, if <cite>True</cite> means that the link type for the given direction
should be followed.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="aiida.common.GraphTraversalRule.__getnewargs__">
<code class="sig-name descname">__getnewargs__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule.__getnewargs__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self as a plain tuple.  Used by copy and pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRule.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.GraphTraversalRule.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule.__new__">
<em class="property">static </em><code class="sig-name descname">__new__</code><span class="sig-paren">(</span><em class="sig-param">_cls</em>, <em class="sig-param">link_type</em>, <em class="sig-param">direction</em>, <em class="sig-param">toggleable</em>, <em class="sig-param">default</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new instance of GraphTraversalRule(link_type, direction, toggleable, default)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a nicely formatted representation string</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRule.__slots__">
<code class="sig-name descname">__slots__</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.GraphTraversalRule.__slots__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule._asdict">
<code class="sig-name descname">_asdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule._asdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new OrderedDict which maps field names to their values.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRule._fields">
<code class="sig-name descname">_fields</code><em class="property"> = ('link_type', 'direction', 'toggleable', 'default')</em><a class="headerlink" href="#aiida.common.GraphTraversalRule._fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRule._fields_defaults">
<code class="sig-name descname">_fields_defaults</code><em class="property"> = {}</em><a class="headerlink" href="#aiida.common.GraphTraversalRule._fields_defaults" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule._make">
<em class="property">classmethod </em><code class="sig-name descname">_make</code><span class="sig-paren">(</span><em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule._make" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a new GraphTraversalRule object from a sequence or iterable</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule._replace">
<code class="sig-name descname">_replace</code><span class="sig-paren">(</span><em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.GraphTraversalRule._replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new GraphTraversalRule object replacing specified fields with new values</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule.default">
<em class="property">property </em><code class="sig-name descname">default</code><a class="headerlink" href="#aiida.common.GraphTraversalRule.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#aiida.common.GraphTraversalRule.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule.link_type">
<em class="property">property </em><code class="sig-name descname">link_type</code><a class="headerlink" href="#aiida.common.GraphTraversalRule.link_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.GraphTraversalRule.toggleable">
<em class="property">property </em><code class="sig-name descname">toggleable</code><a class="headerlink" href="#aiida.common.GraphTraversalRule.toggleable" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.GraphTraversalRules">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">GraphTraversalRules</code><a class="reference internal" href="../_modules/aiida/common/links.html#GraphTraversalRules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.GraphTraversalRules" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>Graph traversal rules when deleting or exporting nodes.</p>
<dl class="attribute">
<dt id="aiida.common.GraphTraversalRules.DEFAULT">
<code class="sig-name descname">DEFAULT</code><em class="property"> = {'call_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='backward', toggleable=True, default=False), 'call_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='forward', toggleable=True, default=False), 'call_work_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='backward', toggleable=True, default=False), 'call_work_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='forward', toggleable=True, default=False), 'create_backward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='backward', toggleable=True, default=False), 'create_forward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='forward', toggleable=True, default=False), 'input_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='backward', toggleable=True, default=False), 'input_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='forward', toggleable=True, default=False), 'input_work_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='backward', toggleable=True, default=False), 'input_work_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='forward', toggleable=True, default=False), 'return_backward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='backward', toggleable=True, default=False), 'return_forward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='forward', toggleable=True, default=False)}</em><a class="headerlink" href="#aiida.common.GraphTraversalRules.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRules.DELETE">
<code class="sig-name descname">DELETE</code><em class="property"> = {'call_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='backward', toggleable=False, default=True), 'call_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='forward', toggleable=True, default=True), 'call_work_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='backward', toggleable=False, default=True), 'call_work_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='forward', toggleable=True, default=True), 'create_backward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='backward', toggleable=False, default=True), 'create_forward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='forward', toggleable=True, default=True), 'input_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='backward', toggleable=False, default=False), 'input_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='forward', toggleable=False, default=True), 'input_work_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='backward', toggleable=False, default=False), 'input_work_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='forward', toggleable=False, default=True), 'return_backward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='backward', toggleable=False, default=True), 'return_forward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='forward', toggleable=False, default=False)}</em><a class="headerlink" href="#aiida.common.GraphTraversalRules.DELETE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRules.EXPORT">
<code class="sig-name descname">EXPORT</code><em class="property"> = {'call_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='backward', toggleable=True, default=True), 'call_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='forward', toggleable=False, default=True), 'call_work_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='backward', toggleable=True, default=True), 'call_work_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='forward', toggleable=False, default=True), 'create_backward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='backward', toggleable=True, default=True), 'create_forward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='forward', toggleable=False, default=True), 'input_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='backward', toggleable=False, default=True), 'input_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='forward', toggleable=True, default=False), 'input_work_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='backward', toggleable=False, default=True), 'input_work_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='forward', toggleable=True, default=False), 'return_backward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='backward', toggleable=True, default=False), 'return_forward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='forward', toggleable=False, default=True)}</em><a class="headerlink" href="#aiida.common.GraphTraversalRules.EXPORT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.GraphTraversalRules.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.GraphTraversalRules.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.LinkType">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">LinkType</code><a class="reference internal" href="../_modules/aiida/common/links.html#LinkType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.LinkType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>A simple enum of allowed link types.</p>
<dl class="attribute">
<dt id="aiida.common.LinkType.CALL_CALC">
<code class="sig-name descname">CALL_CALC</code><em class="property"> = 'call_calc'</em><a class="headerlink" href="#aiida.common.LinkType.CALL_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.CALL_WORK">
<code class="sig-name descname">CALL_WORK</code><em class="property"> = 'call_work'</em><a class="headerlink" href="#aiida.common.LinkType.CALL_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.CREATE">
<code class="sig-name descname">CREATE</code><em class="property"> = 'create'</em><a class="headerlink" href="#aiida.common.LinkType.CREATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.INPUT_CALC">
<code class="sig-name descname">INPUT_CALC</code><em class="property"> = 'input_calc'</em><a class="headerlink" href="#aiida.common.LinkType.INPUT_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.INPUT_WORK">
<code class="sig-name descname">INPUT_WORK</code><em class="property"> = 'input_work'</em><a class="headerlink" href="#aiida.common.LinkType.INPUT_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.RETURN">
<code class="sig-name descname">RETURN</code><em class="property"> = 'return'</em><a class="headerlink" href="#aiida.common.LinkType.RETURN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.LinkType.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.validate_link_label">
<code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">validate_link_label</code><span class="sig-paren">(</span><em class="sig-param">link_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/links.html#validate_link_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.validate_link_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the given link label.</p>
<p>Valid link labels adhere to the following restrictions:</p>
<blockquote>
<div><ul class="simple">
<li><p>Has to be a valid python identifier</p></li>
<li><p>Can only contain alphanumeric characters and underscores</p></li>
<li><p>Can not start or end with an underscore</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.8)"><strong>TypeError</strong></a> – if the link label is not a string type</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the link label is invalid</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.override_log_level">
<code class="sig-prename descclassname">aiida.common.</code><code class="sig-name descname">override_log_level</code><span class="sig-paren">(</span><em class="sig-param">level=50</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/log.html#override_log_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.override_log_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Temporarily adjust the log-level of logger.</p>
</dd></dl>

<div class="section" id="module-aiida.common.constants">
<span id="submodules"></span><h2>Submodules<a class="headerlink" href="#module-aiida.common.constants" title="Permalink to this headline">¶</a></h2>
<p>Module to define the (physical) constants used throughout the code.</p>
<span class="target" id="module-aiida.common.datastructures"></span><p>Module to define commonly used data structures.</p>
<dl class="class">
<dt id="aiida.common.datastructures.CalcJobState">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.datastructures.</code><code class="sig-name descname">CalcJobState</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcJobState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CalcJobState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>The sub state of a CalcJobNode while its Process is in an active state (i.e. Running or Waiting).</p>
<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.PARSING">
<code class="sig-name descname">PARSING</code><em class="property"> = 'parsing'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.PARSING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.RETRIEVING">
<code class="sig-name descname">RETRIEVING</code><em class="property"> = 'retrieving'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.RETRIEVING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.SUBMITTING">
<code class="sig-name descname">SUBMITTING</code><em class="property"> = 'submitting'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.SUBMITTING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.UPLOADING">
<code class="sig-name descname">UPLOADING</code><em class="property"> = 'uploading'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.UPLOADING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.WITHSCHEDULER">
<code class="sig-name descname">WITHSCHEDULER</code><em class="property"> = 'withscheduler'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.WITHSCHEDULER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.datastructures.CalcInfo">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.datastructures.</code><code class="sig-name descname">CalcInfo</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CalcInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This object will store the data returned by the calculation plugin and to be
passed to the ExecManager.</p>
<p>In the following descriptions all paths have to be considered relative</p>
<ul>
<li><dl>
<dt>retrieve_list: a list of strings or tuples that indicate files that are to be retrieved from the remote</dt><dd><p>after the calculation has finished and stored in the repository in a FolderData.
If the entry in the list is just a string, it is assumed to be the filepath on the remote and it will
be copied to ‘.’ of the repository with name os.path.split(item)[1]
If the entry is a tuple it is expected to have the following format</p>
<blockquote>
<div><p>(‘remotepath’, ‘localpath’, depth)</p>
</div></blockquote>
<p>If the ‘remotepath’ is a file or folder, it will be copied in the repository to ‘localpath’.
However, if the ‘remotepath’ contains file patterns with wildcards, the ‘localpath’ should be set to ‘.’
and the depth parameter should be an integer that decides the localname. The ‘remotepath’ will be split on
file separators and the local filename will be determined by joining the N last elements, where N is
given by the depth variable.</p>
<p>Example: (‘some/remote/path/files/pattern*[0-9].xml’, ‘.’, 2)</p>
<p>Will result in all files that match the pattern to be copied to the local repository with path</p>
<blockquote>
<div><p>‘files/pattern*[0-9].xml’</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>retrieve_temporary_list: a list of strings or tuples that indicate files that will be retrieved</dt><dd><p>and stored temporarily in a FolderData, that will be available only during the parsing call.
The format of the list is the same as that of ‘retrieve_list’</p>
</dd>
</dl>
</li>
<li><dl>
<dt>retrieve_singlefile_list: a list of tuples with format</dt><dd><p>(‘linkname_from calc to singlefile’, ‘subclass of singlefile’, ‘filename’)
Each tuple represents a file that will be retrieved from cluster and saved in SinglefileData nodes</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.0.0: </span>Will be removed in <cite>v2.0.0</cite>, use <cite>retrieve_temporary_list</cite> instead.</p>
</div>
</dd>
</dl>
</li>
<li><p>local_copy_list: a list of tuples with format (‘node_uuid’, ‘filename’, relativedestpath’)</p></li>
<li><p>remote_copy_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p></li>
<li><p>remote_symlink_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p></li>
<li><dl class="simple">
<dt>provenance_exclude_list: a sequence of relative paths of files in the sandbox folder of a <cite>CalcJob</cite> instance that</dt><dd><p>should not be stored permanantly in the repository folder of the corresponding <cite>CalcJobNode</cite> that will be
created, but should only be copied to the remote working directory on the target computer. This is useful for
input files that should be copied to the working directory but should not be copied as well to the repository
either, for example, because they contain proprietary information or because they are big and their content is
already indirectly present in the repository through one of the data nodes passed as input to the calculation.</p>
</dd>
</dl>
</li>
<li><p>codes_info: a list of dictionaries used to pass the info of the execution of a code</p></li>
<li><p>codes_run_mode: a string used to specify the order in which multi codes can be executed</p></li>
</ul>
<dl class="attribute">
<dt id="aiida.common.datastructures.CalcInfo.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CalcInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcInfo._default_fields">
<code class="sig-name descname">_default_fields</code><em class="property"> = ('job_environment', 'email', 'email_on_started', 'email_on_terminated', 'uuid', 'prepend_text', 'append_text', 'num_machines', 'num_mpiprocs_per_machine', 'priority', 'max_wallclock_seconds', 'max_memory_kb', 'rerunnable', 'retrieve_list', 'retrieve_temporary_list', 'retrieve_singlefile_list', 'local_copy_list', 'remote_copy_list', 'remote_symlink_list', 'provenance_exclude_list', 'codes_info', 'codes_run_mode')</em><a class="headerlink" href="#aiida.common.datastructures.CalcInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.datastructures.CodeInfo">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.datastructures.</code><code class="sig-name descname">CodeInfo</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CodeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This attribute-dictionary contains the information needed to execute a code.
Possible attributes are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">cmdline_params</span></code>: a list of strings, containing parameters to be written on
the command line right after the call to the code, as for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">...</span> <span class="o">&lt;</span> <span class="n">stdin</span> <span class="o">&gt;</span> <span class="n">stdout</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stdin_name</span></code>: (optional) the name of the standard input file. Note, it is
only possible to use the stdin with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">stdin_name</span>
</pre></div>
</div>
<p>If no stdin_name is specified, the string “&lt; stdin_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&lt;’ if stdin_name is specified;
if that is needed, avoid stdin_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stdout_name</span></code>: (optional) the name of the standard output file. Note, it is
only possible to pass output to stdout_name with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span>
</pre></div>
</div>
<p>If no stdout_name is specified, the string “&gt; stdout_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&gt;’ if stdout_name is specified;
if that is needed, avoid stdout_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stderr_name</span></code>: (optional) a string, the name of the error file of the code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">join_files</span></code>: (optional) if True, redirects the error to the output file.
If join_files=True, the code will be called as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;&amp;</span><span class="mi">1</span>
</pre></div>
</div>
<p>otherwise, if join_files=False and stderr is passed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">stderr_name</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">withmpi</span></code>: if True, executes the code with mpirun (or another MPI installed
on the remote computer)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">code_uuid</span></code>: the uuid of the code associated to the CodeInfo</p></li>
</ul>
<dl class="attribute">
<dt id="aiida.common.datastructures.CodeInfo.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CodeInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CodeInfo._default_fields">
<code class="sig-name descname">_default_fields</code><em class="property"> = ('cmdline_params', 'stdin_name', 'stdout_name', 'stderr_name', 'join_files', 'withmpi', 'code_uuid')</em><a class="headerlink" href="#aiida.common.datastructures.CodeInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.datastructures.CodeRunMode">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.datastructures.</code><code class="sig-name descname">CodeRunMode</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeRunMode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.IntEnum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a></p>
<p>Enum to indicate the way the codes of a calculation should be run.</p>
<p>For PARALLEL, the codes for a given calculation will be run in parallel by running them in the background:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>For the SERIAL option, codes will be executed sequentially by running for example the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.datastructures.CodeRunMode.PARALLEL">
<code class="sig-name descname">PARALLEL</code><em class="property"> = 1</em><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode.PARALLEL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CodeRunMode.SERIAL">
<code class="sig-name descname">SERIAL</code><em class="property"> = 0</em><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode.SERIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CodeRunMode.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.escaping"></span><p>Miscellaneous functions for escaping strings.</p>
<dl class="function">
<dt id="aiida.common.escaping.escape_for_bash">
<code class="sig-prename descclassname">aiida.common.escaping.</code><code class="sig-name descname">escape_for_bash</code><span class="sig-paren">(</span><em class="sig-param">str_to_escape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#escape_for_bash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.escape_for_bash" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes any string and escapes it in a way that
bash will interpret it as a single string.</p>
<p>Explanation:</p>
<p>At the end, in the return statement, the string is put within single
quotes. Therefore, the only thing that I have to escape in bash is the
single quote character. To do this, I substitute every single
quote ‘ with ‘”’”’ which means:</p>
<p>First single quote: exit from the enclosing single quotes</p>
<p>Second, third and fourth character: “’” is a single quote character,
escaped by double quotes</p>
<p>Last single quote: reopen the single quote to continue the string</p>
<p>Finally, note that for python I have to enclose the string ‘”’”’
within triple quotes to make it work, getting finally: the complicated
string found below.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.escaping.escape_for_sql_like">
<code class="sig-prename descclassname">aiida.common.escaping.</code><code class="sig-name descname">escape_for_sql_like</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#escape_for_sql_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.escape_for_sql_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that escapes % or _ symbols provided by user</p>
<p>SQL LIKE syntax summary:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%</span></code> -&gt; match any number of characters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span></code> -&gt; match exactly one character</p></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="aiida.common.escaping.get_regex_pattern_from_sql">
<code class="sig-prename descclassname">aiida.common.escaping.</code><code class="sig-name descname">get_regex_pattern_from_sql</code><span class="sig-paren">(</span><em class="sig-param">sql_pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#get_regex_pattern_from_sql"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.get_regex_pattern_from_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string providing a pattern to match in SQL
syntax into a string performing the same match as a regex.</p>
<p>SQL LIKE syntax summary:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%</span></code> -&gt; match any number of characters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span></code> -&gt; match exactly one character</p></li>
</ul>
<p>Moreover, <code class="docutils literal notranslate"><span class="pre">\</span></code> is the escape character (by default), so:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\\</span></code> -&gt; single backslash</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\%</span></code> -&gt; literal % symbol</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\_</span></code> -&gt; literal _ symbol</p></li>
</ul>
<p>and moreover the string should begin at the beginning of the line
and end at the end of the line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sql_pattern</strong> – the string with the pattern in SQL syntax</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a string with the pattern in regex syntax</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.escaping.sql_string_match">
<code class="sig-prename descclassname">aiida.common.escaping.</code><code class="sig-name descname">sql_string_match</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#sql_string_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.sql_string_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the string matches the provided pattern,
specified using SQL syntax.</p>
<p>See documentation of <a class="reference internal" href="#aiida.common.escaping.get_regex_pattern_from_sql" title="aiida.common.escaping.get_regex_pattern_from_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_regex_pattern_from_sql()</span></code></a>
for an explanation of the syntax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>string</strong> – the string to check</p></li>
<li><p><strong>pattern</strong> – the SQL pattern</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the string matches, False otherwise</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-aiida.common.exceptions"></span><p>Module that define the exceptions that are thrown by AiiDA’s internal code.</p>
<dl class="exception">
<dt id="aiida.common.exceptions.AiidaException">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">AiidaException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#AiidaException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.AiidaException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<p>Base class for all AiiDA exceptions.</p>
<p>Each module will have its own subclass, inherited from this
(e.g. ExecManagerException, TransportException, …)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.AiidaException.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.AiidaException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.AiidaException.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.AiidaException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.NotExistent">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">NotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#NotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.NotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the required entity does not exist.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.NotExistent.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.NotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MultipleObjectsError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">MultipleObjectsError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleObjectsError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MultipleObjectsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when more than one entity is found in the DB, but only one was
expected.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MultipleObjectsError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MultipleObjectsError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.RemoteOperationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">RemoteOperationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#RemoteOperationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.RemoteOperationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an error in a remote operation occurs, as in a failed kill()
of a scheduler job.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.RemoteOperationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.RemoteOperationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ContentNotExistent">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ContentNotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ContentNotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ContentNotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.NotExistent" title="aiida.common.exceptions.NotExistent"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.NotExistent</span></code></a></p>
<p>Raised when trying to access an attribute, a key or a file in the result
nodes that is not present</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ContentNotExistent.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ContentNotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.FailedError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">FailedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FailedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.FailedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when accessing a calculation that is in the FAILED status</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.FailedError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.FailedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.StoringNotAllowed">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">StoringNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#StoringNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.StoringNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to store an unstorable node (e.g. a base Node class)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.StoringNotAllowed.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.StoringNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ModificationNotAllowed">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ModificationNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ModificationNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ModificationNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to modify a field, object, property, … that should not
be modified.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ModificationNotAllowed.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ModificationNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.IntegrityError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">IntegrityError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IntegrityError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.IntegrityError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when there is an underlying data integrity error.  This can be database related
or a general data integrity error.  This can happen if, e.g., a foreign key check fails.
See PEP 249 for details.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.IntegrityError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.IntegrityError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.UniquenessError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">UniquenessError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UniquenessError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.UniquenessError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to violate a uniqueness constraint (on the
DB, for instance).</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.UniquenessError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.UniquenessError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.EntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">EntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#EntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.EntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an entry point cannot be uniquely resolved and imported.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.EntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.EntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MissingEntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">MissingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MissingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point is not registered with the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MissingEntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MissingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MultipleEntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">MultipleEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MultipleEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point cannot uniquely be resolved by the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MultipleEntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MultipleEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.LoadingEntryPointError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">LoadingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LoadingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.LoadingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the resource corresponding to requested entry point cannot be imported.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.LoadingEntryPointError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.LoadingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InvalidEntryPointTypeError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">InvalidEntryPointTypeError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InvalidEntryPointTypeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InvalidEntryPointTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when a loaded entry point has a type that is not supported by the corresponding entry point group.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InvalidEntryPointTypeError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InvalidEntryPointTypeError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InvalidOperation">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">InvalidOperation</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InvalidOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InvalidOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>The allowed operation is not valid (e.g., when trying to add a non-internal attribute
before saving the entry), or deleting an entry that is protected (e.g.,
because it is referenced by foreign keys)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InvalidOperation.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InvalidOperation.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ParsingError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Generic error raised when there is a parsing error</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ParsingError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InternalError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">InternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an internal error of AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InternalError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.PluginInternalError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">PluginInternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#PluginInternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.PluginInternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.InternalError" title="aiida.common.exceptions.InternalError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.InternalError</span></code></a></p>
<p>Error raised when there is an internal error which is due to a plugin
and not to the AiiDA infrastructure.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.PluginInternalError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.PluginInternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ValidationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an error during the validation phase
of a property.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ValidationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ConfigurationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is a configuration error in AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ConfigurationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ProfileConfigurationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ProfileConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ProfileConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ProfileConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when a wrong/inexistent profile is requested.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ProfileConfigurationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ProfileConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MissingConfigurationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">MissingConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MissingConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file is missing.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MissingConfigurationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MissingConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ConfigurationVersionError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">ConfigurationVersionError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationVersionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ConfigurationVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file version is not
compatible with the current version.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ConfigurationVersionError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ConfigurationVersionError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.IncompatibleDatabaseSchema">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">IncompatibleDatabaseSchema</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IncompatibleDatabaseSchema"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.IncompatibleDatabaseSchema" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Raised when the database schema is incompatible with that of the code.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.IncompatibleDatabaseSchema.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.IncompatibleDatabaseSchema.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.DbContentError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">DbContentError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#DbContentError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.DbContentError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the content of the DB is not valid.
This should never happen if the user does not play directly
with the DB.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.DbContentError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.DbContentError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InputValidationError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">InputValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InputValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InputValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ValidationError" title="aiida.common.exceptions.ValidationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ValidationError</span></code></a></p>
<p>The input data for a calculation did not validate (e.g., missing
required input data, wrong data, …)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InputValidationError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InputValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.FeatureNotAvailable">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">FeatureNotAvailable</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureNotAvailable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.FeatureNotAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested from a plugin, that is not available.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.FeatureNotAvailable.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.FeatureNotAvailable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.FeatureDisabled">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">FeatureDisabled</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureDisabled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.FeatureDisabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested, but the user has chosen to disable
it (e.g., for submissions on disabled computers).</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.FeatureDisabled.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.FeatureDisabled.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.LicensingException">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">LicensingException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LicensingException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.LicensingException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when requirements for data licensing are not met.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.LicensingException.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.LicensingException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.TestsNotAllowedError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">TestsNotAllowedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TestsNotAllowedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.TestsNotAllowedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when tests are required to be run/loaded, but we are not in a testing environment.</p>
<p>This is to prevent data loss.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.TestsNotAllowedError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.TestsNotAllowedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.UnsupportedSpeciesError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">UnsupportedSpeciesError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UnsupportedSpeciesError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.UnsupportedSpeciesError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
<p>Raised when StructureData operations are fed species that are not supported by AiiDA such as Deuterium</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.UnsupportedSpeciesError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.UnsupportedSpeciesError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.UnsupportedSpeciesError.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.UnsupportedSpeciesError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.TransportTaskException">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">TransportTaskException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TransportTaskException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.TransportTaskException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a TransportTask, an task to be completed by the engine that requires transport, fails</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.TransportTaskException.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.TransportTaskException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.OutputParsingError">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.exceptions.</code><code class="sig-name descname">OutputParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#OutputParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.OutputParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ParsingError" title="aiida.common.exceptions.ParsingError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ParsingError</span></code></a></p>
<p>Can be raised by a Parser when it fails to parse the output generated by a <cite>CalcJob</cite> process.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.OutputParsingError.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.OutputParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.extendeddicts"></span><p>Various dictionary types with extended functionality.</p>
<dl class="class">
<dt id="aiida.common.extendeddicts.AttributeDict">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.extendeddicts.</code><code class="sig-name descname">AttributeDict</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
<p>This class internally stores values in a dictionary, but exposes
the keys also as attributes, i.e. asking for attrdict.key
will return the value of attrdict[‘key’] and so on.</p>
<p>Raises an AttributeError if the key does not exist, when called as an attribute,
while the usual KeyError if the key does not exist and the dictionary syntax is
used.</p>
<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__deepcopy__">
<code class="sig-name descname">__deepcopy__</code><span class="sig-paren">(</span><em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__deepcopy__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__deepcopy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Deep copy.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__delattr__">
<code class="sig-name descname">__delattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__delattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a key as an attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.8)"><strong>AttributeError</strong></a> – if the attribute does not correspond to an existing key.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.AttributeDict.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.extendeddicts', '__doc__': &quot;\n    This class internally stores values in a dictionary, but exposes\n    the keys also as attributes, i.e. asking for attrdict.key\n    will return the value of attrdict['key'] and so on.\n\n    Raises an AttributeError if the key does not exist, when called as an attribute,\n    while the usual KeyError if the key does not exist and the dictionary syntax is\n    used.\n    &quot;, '__init__': &lt;function AttributeDict.__init__&gt;, '__repr__': &lt;function AttributeDict.__repr__&gt;, '__getattr__': &lt;function AttributeDict.__getattr__&gt;, '__setattr__': &lt;function AttributeDict.__setattr__&gt;, '__delattr__': &lt;function AttributeDict.__delattr__&gt;, '__deepcopy__': &lt;function AttributeDict.__deepcopy__&gt;, '__getstate__': &lt;function AttributeDict.__getstate__&gt;, '__setstate__': &lt;function AttributeDict.__setstate__&gt;, '__dir__': &lt;function AttributeDict.__dir__&gt;, '__dict__': &lt;attribute '__dict__' of 'AttributeDict' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'AttributeDict' objects&gt;})</em><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__dir__">
<code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__getattr__">
<code class="sig-name descname">__getattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a key as an attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.8)"><strong>AttributeError</strong></a> – if the attribute does not correspond to an existing key.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__getstate__">
<code class="sig-name descname">__getstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__getstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively turn the <cite>dict</cite> and all its nested dictionaries into <cite>AttributeDict</cite> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.AttributeDict.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the object.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__setattr__">
<code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__setstate__">
<code class="sig-name descname">__setstate__</code><span class="sig-paren">(</span><em class="sig-param">dictionary</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.AttributeDict.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.extendeddicts.</code><code class="sig-name descname">FixedFieldsAttributeDict</code><span class="sig-paren">(</span><em class="sig-param">init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with filtering
of valid attributes.
This is only the base class, without valid attributes;
use a derived class to do the actual work.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">FixedFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_valid_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__dir__">
<code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively turn the <cite>dict</cite> and all its nested dictionaries into <cite>AttributeDict</cite> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__setattr__">
<code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict._valid_fields">
<code class="sig-name descname">_valid_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict._valid_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.get_valid_fields">
<em class="property">classmethod </em><code class="sig-name descname">get_valid_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.get_valid_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.get_valid_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of valid fields.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.extendeddicts.</code><code class="sig-name descname">DefaultFieldsAttributeDict</code><span class="sig-paren">(</span><em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with an
internal value storing the ‘default’ keys to be distinguished
from extra fields.</p>
<p>Extra methods defaultkeys() and extrakeys() divide the set returned by
keys() in default keys (i.e. those defined at definition time)
and other keys.
There is also a method get_default_fields() to return the internal list.</p>
<p>Moreover, for undefined default keys, it returns None instead of raising a
KeyError/AttributeError exception.</p>
<p>Remember to define the _default_fields in a subclass!
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">DefaultFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_default_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the validate() method is called, it calls in turn all validate_KEY
methods, where KEY is one of the default keys.
If the method is not present, the field is considered to be always valid.
Each validate_KEY method should accept a single argument ‘value’ that will
contain the value to be checked.</p>
<p>It raises a ValidationError if any of the validate_KEY
function raises an exception, otherwise it simply returns.
NOTE: the <cite>validate_*</cite> functions are called also for unset fields, so if the
field can be empty on validation, you have to start your validation
function with something similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Decide behavior if I set to None a field.
Current behavior, if
<code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance and ‘def_field’ one of the default fields, that is
undefined, we get:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: ‘whatever’</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> does NOT contain ‘def_field’</p></li>
</ul>
<p>if we do <code class="docutils literal notranslate"><span class="pre">a.def_field</span> <span class="pre">=</span> <span class="pre">None</span></code>, then the behavior becomes</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: None</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> DOES contain ‘def_field’</p></li>
</ul>
<p>See if we want that setting a default field to None means deleting it.</p>
</div>
<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None instead of raising an exception if the key does not exist
but is in the list of default fields.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.__setattr__">
<code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict._default_fields">
<code class="sig-name descname">_default_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.defaultkeys">
<code class="sig-name descname">defaultkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.defaultkeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.defaultkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default keys defined in the instance.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.extrakeys">
<code class="sig-name descname">extrakeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.extrakeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.extrakeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extra keys defined in the instance.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.get_default_fields">
<em class="property">classmethod </em><code class="sig-name descname">get_default_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.get_default_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.get_default_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of default fields, either defined in the instance or not.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.validate">
<code class="sig-name descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the keys, if any <code class="docutils literal notranslate"><span class="pre">validate_*</span></code> method is available.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.files"></span><p>Utility functions to operate on filesystem files.</p>
<dl class="function">
<dt id="aiida.common.files.md5_file">
<code class="sig-prename descclassname">aiida.common.files.</code><code class="sig-name descname">md5_file</code><span class="sig-paren">(</span><em class="sig-param">filepath</em>, <em class="sig-param">block_size_factor=128</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#md5_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.md5_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the hexdigested md5 checksum of the contents from</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filepath</strong> – the filepath of the file for which we want the md5sum</p></li>
<li><p><strong>block_size_factor</strong> – the file is read at chunks of size <code class="docutils literal notranslate"><span class="pre">block_size_factor</span> <span class="pre">*</span> <span class="pre">md5.block_size</span></code>, where
<code class="docutils literal notranslate"><span class="pre">md5.block_size</span></code> is the block_size used internally by the hashlib module.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a string with the hexdigest md5.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>No checks are done on the file, so if it doesn’t exists it may
raise IOError.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.files.md5_from_filelike">
<code class="sig-prename descclassname">aiida.common.files.</code><code class="sig-name descname">md5_from_filelike</code><span class="sig-paren">(</span><em class="sig-param">filelike</em>, <em class="sig-param">block_size_factor=128</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#md5_from_filelike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.md5_from_filelike" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the hexdigested md5 checksum of the contents from a filelike object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filelike</strong> – the filelike object for whose contents to generate the md5 checksum</p></li>
<li><p><strong>block_size_factor</strong> – the file is read at chunks of size <code class="docutils literal notranslate"><span class="pre">block_size_factor</span> <span class="pre">*</span> <span class="pre">md5.block_size</span></code>, where
<code class="docutils literal notranslate"><span class="pre">md5.block_size</span></code> is the block_size used internally by the hashlib module.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a string with the hexdigest md5.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>no checks are done on the filelike object, so it may raise IOError if it cannot be read from.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.files.sha1_file">
<code class="sig-prename descclassname">aiida.common.files.</code><code class="sig-name descname">sha1_file</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">block_size_factor=128</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#sha1_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.sha1_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file and return its sha1sum (hexdigested).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – the filename of the file for which we want the sha1sum</p></li>
<li><p><strong>block_size_factor</strong> – the file is read at chunks of size
<code class="docutils literal notranslate"><span class="pre">block_size_factor</span> <span class="pre">*</span> <span class="pre">sha1.block_size</span></code>,
where <code class="docutils literal notranslate"><span class="pre">sha1.block_size</span></code> is the block_size used internally by the
hashlib module.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a string with the hexdigest sha1.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>No checks are done on the file, so if it doesn’t exists it may
raise IOError.</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-aiida.common.folders"></span><p>Utility functions to operate on filesystem folders.</p>
<dl class="class">
<dt id="aiida.common.folders.Folder">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.folders.</code><code class="sig-name descname">Folder</code><span class="sig-paren">(</span><em class="sig-param">abspath</em>, <em class="sig-param">folder_limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class to manage generic folders, avoiding to get out of
specific given folder borders.</p>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>fix this, os.path.commonprefix of /a/b/c and /a/b2/c will give
a/b, check if this is wanted or if we want to put trailing slashes.
(or if we want to use os.path.relpath and check for a string starting
with os.pardir?)</p>
</div>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>rethink whether the folder_limit option is still useful. If not, remove
it alltogether (it was a nice feature, but unfortunately all the calls
to os.path.abspath or normpath are quite slow).</p>
</div>
<dl class="attribute">
<dt id="aiida.common.folders.Folder.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.folders', '__doc__': '\n    A class to manage generic folders, avoiding to get out of\n    specific given folder borders.\n\n    .. todo::\n        fix this, os.path.commonprefix of /a/b/c and /a/b2/c will give\n        a/b, check if this is wanted or if we want to put trailing slashes.\n        (or if we want to use os.path.relpath and check for a string starting\n        with os.pardir?)\n\n    .. todo::\n        rethink whether the folder_limit option is still useful. If not, remove\n        it alltogether (it was a nice feature, but unfortunately all the calls\n        to os.path.abspath or normpath are quite slow).\n    ', '__init__': &lt;function Folder.__init__&gt;, 'mode_dir': &lt;property object&gt;, 'mode_file': &lt;property object&gt;, 'get_subfolder': &lt;function Folder.get_subfolder&gt;, 'get_content_list': &lt;function Folder.get_content_list&gt;, 'create_symlink': &lt;function Folder.create_symlink&gt;, 'insert_path': &lt;function Folder.insert_path&gt;, 'create_file_from_filelike': &lt;function Folder.create_file_from_filelike&gt;, 'remove_path': &lt;function Folder.remove_path&gt;, 'get_abs_path': &lt;function Folder.get_abs_path&gt;, 'open': &lt;function Folder.open&gt;, 'abspath': &lt;property object&gt;, 'folder_limit': &lt;property object&gt;, 'exists': &lt;function Folder.exists&gt;, 'isfile': &lt;function Folder.isfile&gt;, 'isdir': &lt;function Folder.isdir&gt;, 'erase': &lt;function Folder.erase&gt;, 'create': &lt;function Folder.create&gt;, 'replace_with_folder': &lt;function Folder.replace_with_folder&gt;, '__dict__': &lt;attribute '__dict__' of 'Folder' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Folder' objects&gt;})</em><a class="headerlink" href="#aiida.common.folders.Folder.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">abspath</em>, <em class="sig-param">folder_limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.Folder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.folders.Folder.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.abspath">
<em class="property">property </em><code class="sig-name descname">abspath</code><a class="headerlink" href="#aiida.common.folders.Folder.abspath" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute path of the folder.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.create">
<code class="sig-name descname">create</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the folder, if it does not exist on the disk yet.</p>
<p>It will also create top directories, if absent.</p>
<p>It is always safe to call it, it will do nothing if the folder
already exists.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.create_file_from_filelike">
<code class="sig-name descname">create_file_from_filelike</code><span class="sig-paren">(</span><em class="sig-param">filelike</em>, <em class="sig-param">filename</em>, <em class="sig-param">mode='wb'</em>, <em class="sig-param">encoding=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.create_file_from_filelike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.create_file_from_filelike" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a file with the given filename from a filelike object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filelike</strong> – a filelike object whose contents to copy</p></li>
<li><p><strong>filename</strong> – the filename for the file that is to be created</p></li>
<li><p><strong>mode</strong> – the mode with which the target file will be written</p></li>
<li><p><strong>encoding</strong> – the encoding with which the target file will be written</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the absolute filepath of the created file</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.create_symlink">
<code class="sig-name descname">create_symlink</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.create_symlink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symlink inside the folder to the location ‘src’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> – the location to which the symlink must point. Can be
either a relative or an absolute path. Should, however,
be relative to work properly also when the repository is
moved!</p></li>
<li><p><strong>name</strong> – the filename of the symlink to be created.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.erase">
<code class="sig-name descname">erase</code><span class="sig-paren">(</span><em class="sig-param">create_empty_folder=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.erase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.erase" title="Permalink to this definition">¶</a></dt>
<dd><p>Erases the folder. Should be called only in very specific cases,
in general folder should not be erased!</p>
<p>Doesn’t complain if the folder does not exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>create_empty_folder</strong> – if True, after erasing, creates an empty dir.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.exists">
<code class="sig-name descname">exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the folder exists, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.folder_limit">
<em class="property">property </em><code class="sig-name descname">folder_limit</code><a class="headerlink" href="#aiida.common.folders.Folder.folder_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>The folder limit that cannot be crossed when creating files and folders.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.get_abs_path">
<code class="sig-name descname">get_abs_path</code><span class="sig-paren">(</span><em class="sig-param">relpath</em>, <em class="sig-param">check_existence=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.get_abs_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.get_abs_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an absolute path for a file or folder in this folder.</p>
<p>The advantage of using this method is that it checks that filename
is a valid filename within this folder,
and not something e.g. containing slashes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – The file or directory.</p></li>
<li><p><strong>check_existence</strong> – if False, just return the file path.
Otherwise, also check if the file or directory actually exists.
Raise OSError if it does not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.get_content_list">
<code class="sig-name descname">get_content_list</code><span class="sig-paren">(</span><em class="sig-param">pattern='*'</em>, <em class="sig-param">only_paths=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.get_content_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.get_content_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of files (and subfolders) in the folder,
matching a given pattern.</p>
<p>Example: If you want to exclude files starting with a dot, you can
call this method with <code class="docutils literal notranslate"><span class="pre">pattern='[!.]*'</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – a pattern for the file/folder names, using Unix filename
pattern matching (see Python standard module fnmatch).
By default, pattern is ‘*’, matching all files and folders.</p></li>
<li><p><strong>only_paths</strong> – if False (default), return pairs (name, is_file).
if True, return only a flat list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of tuples of two elements, the first is the file name and
the second is True if the element is a file, False if it is a
directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.get_subfolder">
<code class="sig-name descname">get_subfolder</code><span class="sig-paren">(</span><em class="sig-param">subfolder</em>, <em class="sig-param">create=False</em>, <em class="sig-param">reset_limit=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.get_subfolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.get_subfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Folder object pointing to a subfolder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subfolder</strong> – a string with the relative path of the subfolder,
relative to the absolute path of this object. Note that
this may also contain ‘..’ parts,
as far as this does not go beyond the folder_limit.</p></li>
<li><p><strong>create</strong> – if True, the new subfolder is created, if it does not exist.</p></li>
<li><p><strong>reset_limit</strong> – when doing <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.get_subfolder('xxx',</span> <span class="pre">reset_limit=False)</span></code>,
the limit of b will be the same limit of a.
if True, the limit will be set to the boundaries of folder b.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a Folder object pointing to the subfolder.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.insert_path">
<code class="sig-name descname">insert_path</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dest_name=None</em>, <em class="sig-param">overwrite=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.insert_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.insert_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a file to the folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> – the source filename to copy</p></li>
<li><p><strong>dest_name</strong> – if None, the same basename of src is used. Otherwise,
the destination filename will have this file name.</p></li>
<li><p><strong>overwrite</strong> – if <code class="docutils literal notranslate"><span class="pre">False</span></code>, raises an error on existing destination;
otherwise, delete it first.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.isdir">
<code class="sig-name descname">isdir</code><span class="sig-paren">(</span><em class="sig-param">relpath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if ‘relpath’ exists inside the folder and is a directory,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.isfile">
<code class="sig-name descname">isfile</code><span class="sig-paren">(</span><em class="sig-param">relpath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.isfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.isfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if ‘relpath’ exists inside the folder and is a file,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.mode_dir">
<em class="property">property </em><code class="sig-name descname">mode_dir</code><a class="headerlink" href="#aiida.common.folders.Folder.mode_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mode with which the folders should be created</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.mode_file">
<em class="property">property </em><code class="sig-name descname">mode_file</code><a class="headerlink" href="#aiida.common.folders.Folder.mode_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mode with which the files should be created</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.open">
<code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">mode='r'</em>, <em class="sig-param">encoding='utf8'</em>, <em class="sig-param">check_existence=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file in the current folder and return the corresponding file object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>check_existence</strong> – if False, just return the file path.
Otherwise, also check if the file or directory actually exists.
Raise OSError if it does not.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.remove_path">
<code class="sig-name descname">remove_path</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.remove_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.remove_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a file or folder from the folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – the relative path name to remove</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.replace_with_folder">
<code class="sig-name descname">replace_with_folder</code><span class="sig-paren">(</span><em class="sig-param">srcdir</em>, <em class="sig-param">move=False</em>, <em class="sig-param">overwrite=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.replace_with_folder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.replace_with_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine copies or moves the source folder ‘srcdir’ to the local
folder pointed by this Folder object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>srcdir</strong> – the source folder on the disk; this must be a string with
an absolute path</p></li>
<li><p><strong>move</strong> – if True, the srcdir is moved to the repository. Otherwise, it
is only copied.</p></li>
<li><p><strong>overwrite</strong> – if True, the folder will be erased first.
if False, a IOError is raised if the folder already exists.
Whatever the value of this flag, parent directories will be
created, if needed.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>OSError or IOError: in case of problems accessing or writing
the files.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>ValueError: if the section is not recognized.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.folders.RepositoryFolder">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.folders.</code><code class="sig-name descname">RepositoryFolder</code><span class="sig-paren">(</span><em class="sig-param">section</em>, <em class="sig-param">uuid</em>, <em class="sig-param">subfolder='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#RepositoryFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.RepositoryFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.folders.Folder" title="aiida.common.folders.Folder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.Folder</span></code></a></p>
<p>A class to manage the local AiiDA repository folders.</p>
<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">section</em>, <em class="sig-param">uuid</em>, <em class="sig-param">subfolder='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#RepositoryFolder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the object by pointing it to a folder in the repository.</p>
<p>Pass the uuid as a string.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.RepositoryFolder.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.get_topdir">
<code class="sig-name descname">get_topdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#RepositoryFolder.get_topdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.get_topdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top directory, i.e., the section/uuid folder object.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.section">
<em class="property">property </em><code class="sig-name descname">section</code><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.section" title="Permalink to this definition">¶</a></dt>
<dd><p>The section to which this folder belongs.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.subfolder">
<em class="property">property </em><code class="sig-name descname">subfolder</code><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.subfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>The subfolder within the section/uuid folder.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.uuid">
<em class="property">property </em><code class="sig-name descname">uuid</code><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>The uuid to which this folder belongs.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.folders.SandboxFolder">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.folders.</code><code class="sig-name descname">SandboxFolder</code><span class="sig-paren">(</span><em class="sig-param">sandbox_in_repo=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.folders.Folder" title="aiida.common.folders.Folder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.Folder</span></code></a></p>
<p>A class to manage the creation and management of a sandbox folder.</p>
<p>Note: this class must be used within a context manager, i.e.:</p>
<dl class="simple">
<dt>with SandboxFolder as f:</dt><dd><p>## do something with f</p>
</dd>
</dl>
<p>In this way, the sandbox folder is removed from disk
(if it wasn’t removed already) when exiting the ‘with’ block.</p>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>Implement check of whether the folder has been removed.</p>
</div>
<dl class="method">
<dt id="aiida.common.folders.SandboxFolder.__enter__">
<code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when entering in the with statement</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SandboxFolder.__exit__">
<code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param">exc_type</em>, <em class="sig-param">exc_value</em>, <em class="sig-param">traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>In exit, I remove the sandbox folder from disk, if it still exists</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SandboxFolder.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">sandbox_in_repo=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the object by creating a new temporary folder in the
sandbox.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sandbox_in_repo</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a>) – If True (default), creates the folder in the repository.
If false,  relies on the defaults of tempfile.mkdtemp</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.SandboxFolder.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.folders.SubmitTestFolder">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.folders.</code><code class="sig-name descname">SubmitTestFolder</code><span class="sig-paren">(</span><em class="sig-param">basepath='submit_test'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.folders.Folder" title="aiida.common.folders.Folder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.Folder</span></code></a></p>
<p>Sandbox folder that can be used for the test submission of <cite>CalcJobs</cite>.</p>
<p>The directory will be created in the current working directory with a configurable basename.
Then a sub folder will be created within this base folder based on the current date and an index in order to
not overwrite already existing created test folders.</p>
<dl class="method">
<dt id="aiida.common.folders.SubmitTestFolder.__enter__">
<code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sub folder that should be Called when entering in the with statement.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SubmitTestFolder.__exit__">
<code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param">exc_type</em>, <em class="sig-param">exc_value</em>, <em class="sig-param">traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>When context manager is exited, do not delete the folder.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SubmitTestFolder.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">basepath='submit_test'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct and create the sandbox folder.</p>
<p>The directory will be created in the current working directory with the name given by <cite>basepath</cite>.
Then a sub folder will be created within this base folder based on the current date and an index in order to
not overwrite already existing created test folders.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>basepath</strong> – name of the base directory that will be created in the current working directory</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.SubmitTestFolder.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.SubmitTestFolder._sub_folder">
<code class="sig-name descname">_sub_folder</code><em class="property"> = None</em><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder._sub_folder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.hashing"></span><p>Common password and hash generation functions.</p>
<dl class="function">
<dt id="aiida.common.hashing._">
<code class="sig-prename descclassname">aiida.common.hashing.</code><code class="sig-name descname">_</code><span class="sig-paren">(</span><em class="sig-param">folder</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing._" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the content of a Folder object. The name of the folder itself is actually ignored
:param ignored_folder_content: list of filenames to be ignored for the hashing</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing._make_hash">
<code class="sig-prename descclassname">aiida.common.hashing.</code><code class="sig-name descname">_make_hash</code><span class="sig-paren">(</span><em class="sig-param">object_to_hash</em>, <em class="sig-param">**_</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#_make_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing._make_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the <code class="docutils literal notranslate"><span class="pre">make_hash</span></code> function. The hash is created as a
28 byte integer, and only later converted to a string.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing._single_digest">
<code class="sig-prename descclassname">aiida.common.hashing.</code><code class="sig-name descname">_single_digest</code><span class="sig-paren">(</span><em class="sig-param">obj_type</em>, <em class="sig-param">obj_bytes=b''</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#_single_digest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing._single_digest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.float_to_text">
<code class="sig-prename descclassname">aiida.common.hashing.</code><code class="sig-name descname">float_to_text</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">sig</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#float_to_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.float_to_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert float to text string for computing hash.
Preseve up to N significant number given by sig.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – the float value to convert</p></li>
<li><p><strong>sig</strong> – choose how many digits after the comma should be output</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.get_random_string">
<code class="sig-prename descclassname">aiida.common.hashing.</code><code class="sig-name descname">get_random_string</code><span class="sig-paren">(</span><em class="sig-param">length=12</em>, <em class="sig-param">allowed_chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#get_random_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.get_random_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a securely generated random string.</p>
<p>The default length of 12 with the a-z, A-Z, 0-9 character set returns
a 71-bit value. log_2((26+26+10)^12) =~ 71 bits</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.make_hash">
<code class="sig-prename descclassname">aiida.common.hashing.</code><code class="sig-name descname">make_hash</code><span class="sig-paren">(</span><em class="sig-param">object_to_hash</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#make_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.make_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a hash from a dictionary, list, tuple or set to any level, that contains
only other hashable or nonhashable types (including lists, tuples, sets, and
dictionaries).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>object_to_hash</strong> – the object to hash</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a unique hash</p>
</dd>
</dl>
<p>There are a lot of modules providing functionalities to create unique
hashes for hashable values.
However, getting hashes for nonhashable items like sets or dictionaries is
not easily doable because order is not fixed.
This leads to the peril of getting different hashes for the same
dictionary.</p>
<p>This function avoids this by recursing through nonhashable items and
hashing iteratively. Uses python’s sorted function to sort unsorted
sets and dictionaries by sorting the hashed keys.</p>
</dd></dl>

<span class="target" id="module-aiida.common.json"></span><p>Abstracts JSON usage to ensure compatibility with Python2 and Python3.</p>
<p>Use this module prefentially over standard json to ensure compatibility.</p>
<dl class="function">
<dt id="aiida.common.json.dump">
<code class="sig-prename descclassname">aiida.common.json.</code><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">fhandle</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write JSON encoded ‘data’ to a file-like object, fhandle
Use open(filename, ‘wb’) to write.
The utf8write object is used to ensure that the resulting serialised data is
encoding as UTF8.
Any strings with non-ASCII characters need to be unicode strings.
We use ensure_ascii=False to write unicode characters specifically
as this improves the readability of the json and reduces the file size.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.json.dumps">
<code class="sig-prename descclassname">aiida.common.json.</code><code class="sig-name descname">dumps</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#dumps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Write JSON encoded ‘data’ to a string.
simplejson is useful here as it always returns unicode if ensure_ascii=False is used,
unlike the standard library json, rather than being dependant on the input.
We use also ensure_ascii=False to write unicode characters specifically
as this improves the readability of the json and reduces the file size.
When writing to file, use open(filename, ‘w’, encoding=’utf8’)</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.json.load">
<code class="sig-prename descclassname">aiida.common.json.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fhandle</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialise a JSON file.</p>
<p>For encoding consistency, open(filename, ‘r’, encoding=’utf8’) should be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if no valid JSON object could be decoded</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.json.loads">
<code class="sig-prename descclassname">aiida.common.json.</code><code class="sig-name descname">loads</code><span class="sig-paren">(</span><em class="sig-param">json_string</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialise a JSON string.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if no valid JSON object could be decoded</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-aiida.common.lang"></span><p>Utilities that extend the basic python language.</p>
<dl class="class">
<dt id="aiida.common.lang.classproperty">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.lang.</code><code class="sig-name descname">classproperty</code><span class="sig-paren">(</span><em class="sig-param">getter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#classproperty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.classproperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class that, when used as a decorator, works as if the
two decorators &#64;property and &#64;classmethod where applied together
(i.e., the object works as a property, both for the Class and for any
of its instance; and is called with the class cls rather than with the
instance as its first argument).</p>
<dl class="attribute">
<dt id="aiida.common.lang.classproperty.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.lang', '__doc__': '\n    A class that, when used as a decorator, works as if the\n    two decorators &#64;property and &#64;classmethod where applied together\n    (i.e., the object works as a property, both for the Class and for any\n    of its instance; and is called with the class cls rather than with the\n    instance as its first argument).\n    ', '__init__': &lt;function classproperty.__init__&gt;, '__get__': &lt;function classproperty.__get__&gt;, '__dict__': &lt;attribute '__dict__' of 'classproperty' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'classproperty' objects&gt;})</em><a class="headerlink" href="#aiida.common.lang.classproperty.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.classproperty.__get__">
<code class="sig-name descname">__get__</code><span class="sig-paren">(</span><em class="sig-param">instance</em>, <em class="sig-param">owner</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#classproperty.__get__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.classproperty.__get__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.classproperty.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">getter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#classproperty.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.classproperty.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.classproperty.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.lang'</em><a class="headerlink" href="#aiida.common.lang.classproperty.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.classproperty.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.lang.classproperty.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.isidentifier">
<code class="sig-prename descclassname">aiida.common.lang.</code><code class="sig-name descname">isidentifier</code><span class="sig-paren">(</span><em class="sig-param">identifier</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#isidentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.isidentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given string is a valid python identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean, True if identifier is valid, False otherwise</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.8)"><strong>TypeError</strong></a> – if identifier is not string type</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.override">
<code class="sig-prename descclassname">aiida.common.lang.</code><code class="sig-name descname">override</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.lang.override" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.lang.override_decorator">
<code class="sig-prename descclassname">aiida.common.lang.</code><code class="sig-name descname">override_decorator</code><span class="sig-paren">(</span><em class="sig-param">check=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#override_decorator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.override_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to signal that a method from a base class is being overridden completely.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.type_check">
<code class="sig-prename descclassname">aiida.common.lang.</code><code class="sig-name descname">type_check</code><span class="sig-paren">(</span><em class="sig-param">what</em>, <em class="sig-param">of_type</em>, <em class="sig-param">msg=None</em>, <em class="sig-param">allow_none=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#type_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.type_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that object ‘what’ is of type ‘of_type’ and if not the case, raise a TypeError.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>what</strong> – the object to check</p></li>
<li><p><strong>of_type</strong> – the type (or tuple of types) to compare to</p></li>
<li><p><strong>msg</strong> – if specified, allows to customize the message that is passed within the TypeError exception</p></li>
<li><p><strong>allow_none</strong> – boolean, if True will not raise if the passed <cite>what</cite> is <cite>None</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-aiida.common.links"></span><p>Module with utilities and data structures pertaining to links between nodes in the provenance graph.</p>
<dl class="class">
<dt id="aiida.common.links.GraphTraversalRule">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.links.</code><code class="sig-name descname">GraphTraversalRule</code><span class="sig-paren">(</span><em class="sig-param">link_type</em>, <em class="sig-param">direction</em>, <em class="sig-param">toggleable</em>, <em class="sig-param">default</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a></p>
<p>A namedtuple that defines a graph traversal rule.</p>
<p>When starting from a certain sub set of nodes, the graph traversal rules specify which links should be followed to
add adjacent nodes to finally arrive at a set of nodes that represent a valid and consistent sub graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>link_type</strong> – the <cite>LinkType</cite> that the rule applies to</p></li>
<li><p><strong>direction</strong> – whether the link type should be followed backwards or forwards</p></li>
<li><p><strong>toggleable</strong> – boolean to indicate whether the rule can be changed from the default value. If this is <cite>False</cite> it
means the default value can never be changed as it will result in an inconsistent graph.</p></li>
<li><p><strong>default</strong> – boolean, the default value of the rule, if <cite>True</cite> means that the link type for the given direction
should be followed.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.__getnewargs__">
<code class="sig-name descname">__getnewargs__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.__getnewargs__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self as a plain tuple.  Used by copy and pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRule.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.__new__">
<em class="property">static </em><code class="sig-name descname">__new__</code><span class="sig-paren">(</span><em class="sig-param">_cls</em>, <em class="sig-param">link_type</em>, <em class="sig-param">direction</em>, <em class="sig-param">toggleable</em>, <em class="sig-param">default</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new instance of GraphTraversalRule(link_type, direction, toggleable, default)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a nicely formatted representation string</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRule.__slots__">
<code class="sig-name descname">__slots__</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.__slots__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule._asdict">
<code class="sig-name descname">_asdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule._asdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new OrderedDict which maps field names to their values.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRule._fields">
<code class="sig-name descname">_fields</code><em class="property"> = ('link_type', 'direction', 'toggleable', 'default')</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRule._fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRule._fields_defaults">
<code class="sig-name descname">_fields_defaults</code><em class="property"> = {}</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRule._fields_defaults" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule._make">
<em class="property">classmethod </em><code class="sig-name descname">_make</code><span class="sig-paren">(</span><em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule._make" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a new GraphTraversalRule object from a sequence or iterable</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule._replace">
<code class="sig-name descname">_replace</code><span class="sig-paren">(</span><em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.links.GraphTraversalRule._replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new GraphTraversalRule object replacing specified fields with new values</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.default">
<em class="property">property </em><code class="sig-name descname">default</code><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.link_type">
<em class="property">property </em><code class="sig-name descname">link_type</code><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.link_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.links.GraphTraversalRule.toggleable">
<em class="property">property </em><code class="sig-name descname">toggleable</code><a class="headerlink" href="#aiida.common.links.GraphTraversalRule.toggleable" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.links.GraphTraversalRules">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.links.</code><code class="sig-name descname">GraphTraversalRules</code><a class="reference internal" href="../_modules/aiida/common/links.html#GraphTraversalRules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.links.GraphTraversalRules" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>Graph traversal rules when deleting or exporting nodes.</p>
<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRules.DEFAULT">
<code class="sig-name descname">DEFAULT</code><em class="property"> = {'call_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='backward', toggleable=True, default=False), 'call_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='forward', toggleable=True, default=False), 'call_work_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='backward', toggleable=True, default=False), 'call_work_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='forward', toggleable=True, default=False), 'create_backward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='backward', toggleable=True, default=False), 'create_forward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='forward', toggleable=True, default=False), 'input_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='backward', toggleable=True, default=False), 'input_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='forward', toggleable=True, default=False), 'input_work_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='backward', toggleable=True, default=False), 'input_work_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='forward', toggleable=True, default=False), 'return_backward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='backward', toggleable=True, default=False), 'return_forward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='forward', toggleable=True, default=False)}</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRules.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRules.DELETE">
<code class="sig-name descname">DELETE</code><em class="property"> = {'call_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='backward', toggleable=False, default=True), 'call_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='forward', toggleable=True, default=True), 'call_work_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='backward', toggleable=False, default=True), 'call_work_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='forward', toggleable=True, default=True), 'create_backward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='backward', toggleable=False, default=True), 'create_forward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='forward', toggleable=True, default=True), 'input_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='backward', toggleable=False, default=False), 'input_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='forward', toggleable=False, default=True), 'input_work_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='backward', toggleable=False, default=False), 'input_work_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='forward', toggleable=False, default=True), 'return_backward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='backward', toggleable=False, default=True), 'return_forward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='forward', toggleable=False, default=False)}</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRules.DELETE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRules.EXPORT">
<code class="sig-name descname">EXPORT</code><em class="property"> = {'call_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='backward', toggleable=True, default=True), 'call_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_CALC: 'call_calc'&gt;, direction='forward', toggleable=False, default=True), 'call_work_backward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='backward', toggleable=True, default=True), 'call_work_forward': GraphTraversalRule(link_type=&lt;LinkType.CALL_WORK: 'call_work'&gt;, direction='forward', toggleable=False, default=True), 'create_backward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='backward', toggleable=True, default=True), 'create_forward': GraphTraversalRule(link_type=&lt;LinkType.CREATE: 'create'&gt;, direction='forward', toggleable=False, default=True), 'input_calc_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='backward', toggleable=False, default=True), 'input_calc_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_CALC: 'input_calc'&gt;, direction='forward', toggleable=True, default=False), 'input_work_backward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='backward', toggleable=False, default=True), 'input_work_forward': GraphTraversalRule(link_type=&lt;LinkType.INPUT_WORK: 'input_work'&gt;, direction='forward', toggleable=True, default=False), 'return_backward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='backward', toggleable=True, default=False), 'return_forward': GraphTraversalRule(link_type=&lt;LinkType.RETURN: 'return'&gt;, direction='forward', toggleable=False, default=True)}</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRules.EXPORT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.GraphTraversalRules.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.links.GraphTraversalRules.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.links.LinkType">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.links.</code><code class="sig-name descname">LinkType</code><a class="reference internal" href="../_modules/aiida/common/links.html#LinkType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.links.LinkType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a></p>
<p>A simple enum of allowed link types.</p>
<dl class="attribute">
<dt id="aiida.common.links.LinkType.CALL_CALC">
<code class="sig-name descname">CALL_CALC</code><em class="property"> = 'call_calc'</em><a class="headerlink" href="#aiida.common.links.LinkType.CALL_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.CALL_WORK">
<code class="sig-name descname">CALL_WORK</code><em class="property"> = 'call_work'</em><a class="headerlink" href="#aiida.common.links.LinkType.CALL_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.CREATE">
<code class="sig-name descname">CREATE</code><em class="property"> = 'create'</em><a class="headerlink" href="#aiida.common.links.LinkType.CREATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.INPUT_CALC">
<code class="sig-name descname">INPUT_CALC</code><em class="property"> = 'input_calc'</em><a class="headerlink" href="#aiida.common.links.LinkType.INPUT_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.INPUT_WORK">
<code class="sig-name descname">INPUT_WORK</code><em class="property"> = 'input_work'</em><a class="headerlink" href="#aiida.common.links.LinkType.INPUT_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.RETURN">
<code class="sig-name descname">RETURN</code><em class="property"> = 'return'</em><a class="headerlink" href="#aiida.common.links.LinkType.RETURN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.links.LinkType.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.links.validate_link_label">
<code class="sig-prename descclassname">aiida.common.links.</code><code class="sig-name descname">validate_link_label</code><span class="sig-paren">(</span><em class="sig-param">link_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/links.html#validate_link_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.links.validate_link_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the given link label.</p>
<p>Valid link labels adhere to the following restrictions:</p>
<blockquote>
<div><ul class="simple">
<li><p>Has to be a valid python identifier</p></li>
<li><p>Can only contain alphanumeric characters and underscores</p></li>
<li><p>Can not start or end with an underscore</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.8)"><strong>TypeError</strong></a> – if the link label is not a string type</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the link label is invalid</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-aiida.common.log"></span><p>Module for all logging methods/classes that don’t need the ORM.</p>
<dl class="function">
<dt id="aiida.common.log.override_log_level">
<code class="sig-prename descclassname">aiida.common.log.</code><code class="sig-name descname">override_log_level</code><span class="sig-paren">(</span><em class="sig-param">level=50</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/log.html#override_log_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.log.override_log_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Temporarily adjust the log-level of logger.</p>
</dd></dl>

<span class="target" id="module-aiida.common.timezone"></span><p>Utility functions to operate on datetime objects.</p>
<dl class="function">
<dt id="aiida.common.timezone.datetime_to_isoformat">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">datetime_to_isoformat</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#datetime_to_isoformat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.datetime_to_isoformat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a datetime object to string representations in ISO format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> – a datetime object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.delta">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">delta</code><span class="sig-paren">(</span><em class="sig-param">from_time</em>, <em class="sig-param">to_time=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the datetime object representing the different between two datetime objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_time</strong> – starting datetime object</p></li>
<li><p><strong>to_time</strong> – end datetime object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the delta datetime object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.get_current_timezone">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">get_current_timezone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#get_current_timezone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.get_current_timezone" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current timezone.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>current timezone</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.is_aware">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">is_aware</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#is_aware"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.is_aware" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given datetime object is timezone aware</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean, True if aware, False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.is_naive">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">is_naive</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#is_naive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.is_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given datetime object is timezone naive</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean, True if naive, False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.isoformat_to_datetime">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">isoformat_to_datetime</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#isoformat_to_datetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.isoformat_to_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert string representation of a datetime in ISO format to a datetime object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> – a ISO format string representation of a datetime object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.localtime">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">localtime</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">timezone=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#localtime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.localtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an aware datetime.datetime to local time.</p>
<p>Local time is defined by the current time zone, unless another time zone is specified.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.make_aware">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">make_aware</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">timezone=None</em>, <em class="sig-param">is_dst=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#make_aware"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.make_aware" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the given datetime object timezone aware.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – datetime object to make aware</p></li>
<li><p><strong>timezone</strong> – </p></li>
<li><p><strong>is_dst</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.now">
<code class="sig-prename descclassname">aiida.common.timezone.</code><code class="sig-name descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#now"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the datetime object of the current time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>datetime object represeting current time</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-aiida.common.utils"></span><p>Miscellaneous generic utility functions and classes.</p>
<dl class="class">
<dt id="aiida.common.utils.ArrayCounter">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">ArrayCounter</code><a class="reference internal" href="../_modules/aiida/common/utils.html#ArrayCounter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ArrayCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A counter &amp; a method that increments it and returns its value.
It is used in various tests.</p>
<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    A counter &amp; a method that increments it and returns its value.\n    It is used in various tests.\n    ', 'seq': None, '__init__': &lt;function ArrayCounter.__init__&gt;, 'array_counter': &lt;function ArrayCounter.array_counter&gt;, '__dict__': &lt;attribute '__dict__' of 'ArrayCounter' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'ArrayCounter' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ArrayCounter.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ArrayCounter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ArrayCounter.array_counter">
<code class="sig-name descname">array_counter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ArrayCounter.array_counter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ArrayCounter.array_counter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.seq">
<code class="sig-name descname">seq</code><em class="property"> = None</em><a class="headerlink" href="#aiida.common.utils.ArrayCounter.seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.utils.Capturing">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">Capturing</code><span class="sig-paren">(</span><em class="sig-param">capture_stderr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>This class captures stdout and returns it
(as a list, split by lines).</p>
<p>Note: if you raise a SystemExit, you have to catch it outside.
E.g., in our tests, this works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">SystemExit</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Capturing</span><span class="p">()</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</pre></div>
</div>
<p>But out of the testing environment, the code instead just exits.</p>
<p>To use it, access the obj.stdout_lines, or just iterate over the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>capture_stderr</strong> – if True, also captures sys.stderr. To access the
lines, use obj.stderr_lines. If False, obj.stderr_lines is None.</p>
</dd>
</dl>
<dl class="attribute">
<dt id="aiida.common.utils.Capturing.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    This class captures stdout and returns it\n    (as a list, split by lines).\n\n    Note: if you raise a SystemExit, you have to catch it outside.\n    E.g., in our tests, this works::\n\n        import sys\n        with self.assertRaises(SystemExit):\n            with Capturing() as output:\n                sys.exit()\n\n    But out of the testing environment, the code instead just exits.\n\n    To use it, access the obj.stdout_lines, or just iterate over the object\n\n    :param capture_stderr: if True, also captures sys.stderr. To access the\n        lines, use obj.stderr_lines. If False, obj.stderr_lines is None.\n    ', '__init__': &lt;function Capturing.__init__&gt;, '__enter__': &lt;function Capturing.__enter__&gt;, '__exit__': &lt;function Capturing.__exit__&gt;, '__str__': &lt;function Capturing.__str__&gt;, '__iter__': &lt;function Capturing.__iter__&gt;, '__dict__': &lt;attribute '__dict__' of 'Capturing' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Capturing' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.Capturing.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__enter__">
<code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter the context where all output is captured.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__exit__">
<code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit the context where all output is captured.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">capture_stderr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Capturing.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.Capturing.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Capturing.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.Capturing.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.utils.ErrorAccumulator">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">ErrorAccumulator</code><span class="sig-paren">(</span><em class="sig-param">*error_cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Allows to run a number of functions and collect all the errors they raise</p>
<p>This allows to validate multiple things and tell the user about all the
errors encountered at once. Works best if the individual functions do not depend on each other.</p>
<p>Does not allow to trace the stack of each error, therefore do not use for debugging, but for
semantical checking with user friendly error messages.</p>
<dl class="attribute">
<dt id="aiida.common.utils.ErrorAccumulator.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    Allows to run a number of functions and collect all the errors they raise\n\n    This allows to validate multiple things and tell the user about all the\n    errors encountered at once. Works best if the individual functions do not depend on each other.\n\n    Does not allow to trace the stack of each error, therefore do not use for debugging, but for\n    semantical checking with user friendly error messages.\n    ', '__init__': &lt;function ErrorAccumulator.__init__&gt;, 'run': &lt;function ErrorAccumulator.run&gt;, 'success': &lt;function ErrorAccumulator.success&gt;, 'result': &lt;function ErrorAccumulator.result&gt;, 'raise_errors': &lt;function ErrorAccumulator.raise_errors&gt;, '__dict__': &lt;attribute '__dict__' of 'ErrorAccumulator' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'ErrorAccumulator' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*error_cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ErrorAccumulator.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ErrorAccumulator.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.raise_errors">
<code class="sig-name descname">raise_errors</code><span class="sig-paren">(</span><em class="sig-param">raise_cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.raise_errors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.raise_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.result">
<code class="sig-name descname">result</code><span class="sig-paren">(</span><em class="sig-param">raise_error=&lt;class 'Exception'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.success">
<code class="sig-name descname">success</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.success"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.utils.Prettifier">
<em class="property">class </em><code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">Prettifier</code><span class="sig-paren">(</span><em class="sig-param">format</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class to manage prettifiers (typically for labels of kpoints
in band plots)</p>
<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.__dict__">
<code class="sig-name descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    Class to manage prettifiers (typically for labels of kpoints\n    in band plots)\n    ', '_prettify_label_pass': &lt;classmethod object&gt;, '_prettify_label_agr': &lt;classmethod object&gt;, '_prettify_label_agr_simple': &lt;classmethod object&gt;, '_prettify_label_gnuplot': &lt;classmethod object&gt;, '_prettify_label_gnuplot_simple': &lt;classmethod object&gt;, '_prettify_label_latex': &lt;classmethod object&gt;, '_prettify_label_latex_simple': &lt;classmethod object&gt;, 'prettifiers': &lt;aiida.common.lang.classproperty object&gt;, 'get_prettifiers': &lt;classmethod object&gt;, '__init__': &lt;function Prettifier.__init__&gt;, 'prettify': &lt;function Prettifier.prettify&gt;, '__dict__': &lt;attribute '__dict__' of 'Prettifier' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Prettifier' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.Prettifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">format</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a class to pretttify strings of a given format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>format</strong> – a string with the format to use to prettify.
Valid formats are obtained from self.prettifiers</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.Prettifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.Prettifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_agr">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_agr</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_agr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_agr" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for XMGrace</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_agr_simple">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_agr_simple</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_agr_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_agr_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for XMGrace (for old label names)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_gnuplot">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_gnuplot</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_gnuplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_gnuplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for Gnuplot</p>
<dl class="field-list simple">
<dt class="field-odd">Note</dt>
<dd class="field-odd"><p>uses unicode, returns unicode strings (potentially, if needed)</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_gnuplot_simple">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_gnuplot_simple</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_gnuplot_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_gnuplot_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for Gnuplot (for old label names)</p>
<dl class="field-list simple">
<dt class="field-odd">Note</dt>
<dd class="field-odd"><p>uses unicode, returns unicode strings (potentially, if needed)</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_latex">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_latex</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_latex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_latex" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for matplotlib, using LaTeX syntax</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_latex_simple">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_latex_simple</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_latex_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_latex_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for matplotlib, using LaTeX syntax (for old label names)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier._prettify_label_pass">
<em class="property">classmethod </em><code class="sig-name descname">_prettify_label_pass</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_pass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_pass" title="Permalink to this definition">¶</a></dt>
<dd><p>No-op prettifier, simply returns  the same label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> – a string to prettify</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier.get_prettifiers">
<em class="property">classmethod </em><code class="sig-name descname">get_prettifiers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier.get_prettifiers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier.get_prettifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of valid prettifier strings</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of strings</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.prettifiers">
<code class="sig-name descname">prettifiers</code><em class="property"> = {'agr_seekpath': &lt;bound method Prettifier._prettify_label_agr of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'agr_simple': &lt;bound method Prettifier._prettify_label_agr_simple of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'gnuplot_seekpath': &lt;bound method Prettifier._prettify_label_gnuplot of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'gnuplot_simple': &lt;bound method Prettifier._prettify_label_gnuplot_simple of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'latex_seekpath': &lt;bound method Prettifier._prettify_label_latex of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'latex_simple': &lt;bound method Prettifier._prettify_label_latex_simple of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'pass': &lt;bound method Prettifier._prettify_label_pass of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;}</em><a class="headerlink" href="#aiida.common.utils.Prettifier.prettifiers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier.prettify">
<code class="sig-name descname">prettify</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier.prettify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier.prettify" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettify a label using the format passed in the initializer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> – the string to prettify</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a prettified string</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.are_dir_trees_equal">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">are_dir_trees_equal</code><span class="sig-paren">(</span><em class="sig-param">dir1</em>, <em class="sig-param">dir2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#are_dir_trees_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.are_dir_trees_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two directories recursively. Files in each directory are
assumed to be equal if their names and contents are equal.</p>
<p>&#64;param dir1: First directory path
&#64;param dir2: Second directory path</p>
<dl class="simple">
<dt>&#64;return: True if the directory trees are the same and</dt><dd><p>there were no errors while accessing the directories or files,
False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_class_string">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">get_class_string</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_class_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_class_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the string identifying the class of the object (module + object name,
joined by dots).</p>
<p>It works both for classes and for class instances.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_new_uuid">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">get_new_uuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_new_uuid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_new_uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new UUID (typically to be used for new nodes).
It uses the UUID version specified in
aiida.backends.settings.AIIDANODES_UUID_VERSION</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_object_from_string">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">get_object_from_string</code><span class="sig-paren">(</span><em class="sig-param">class_string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_object_from_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_object_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a string identifying an object (as returned by the get_class_string
method) load and return the actual object.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_unique_filename">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">get_unique_filename</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">list_of_filenames</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_unique_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_unique_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unique filename that can be added to the list_of_filenames.</p>
<p>If filename is not in list_of_filenames, it simply returns the filename
string itself. Otherwise, it appends a integer number to the filename
(before the extension) until it finds a unique filename.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – the filename to add</p></li>
<li><p><strong>list_of_filenames</strong> – the list of filenames to which filename
should be added, without name duplicates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Either filename or its modification, with a number appended
between the name and the extension.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.grouper">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">grouper</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#grouper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.grouper" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an iterable, returns an iterable that returns tuples of groups of
elements from iterable of length n, except the last one that has the
required length to exaust iterable (i.e., there is no filling applied).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – length of each tuple (except the last one,that will have length
&lt;= n</p></li>
<li><p><strong>iterable</strong> – the iterable to divide in groups</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.join_labels">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">join_labels</code><span class="sig-paren">(</span><em class="sig-param">labels</em>, <em class="sig-param">join_symbol='|'</em>, <em class="sig-param">threshold=1e-06</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#join_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.join_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Join labels with a joining symbol when they are very close</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> – a list of length-2 tuples, in the format(position, label)</p></li>
<li><p><strong>join_symbol</strong> – the string to use to join different paths. By default, a pipe</p></li>
<li><p><strong>threshold</strong> – the threshold to decide if two float values are the same and should
be joined</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the same list as labels, but with the second value possibly replaced
with strings joined when close enough</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.prettify_labels">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">prettify_labels</code><span class="sig-paren">(</span><em class="sig-param">labels</em>, <em class="sig-param">format=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#prettify_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.prettify_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettify label for typesetting in various formats</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> – a list of length-2 tuples, in the format(position, label)</p></li>
<li><p><strong>format</strong> – a string with the format for the prettifier (e.g. ‘agr’,
‘matplotlib’, …)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the same list as labels, but with the second value possibly replaced
with a prettified version that typesets nicely in the selected format</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.str_timedelta">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">str_timedelta</code><span class="sig-paren">(</span><em class="sig-param">dt</em>, <em class="sig-param">max_num_fields=3</em>, <em class="sig-param">short=False</em>, <em class="sig-param">negative_to_zero=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#str_timedelta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.str_timedelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a dt in seconds, return it in a HH:MM:SS format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> – a TimeDelta object</p></li>
<li><p><strong>max_num_fields</strong> – maximum number of non-zero fields to show
(for instance if the number of days is non-zero, shows only
days, hours and minutes, but not seconds)</p></li>
<li><p><strong>short</strong> – if False, print always <code class="docutils literal notranslate"><span class="pre">max_num_fields</span></code> fields, even
if they are zero. If True, do not print the first fields, if they
are zero.</p></li>
<li><p><strong>negative_to_zero</strong> – if True, set dt = 0 if dt &lt; 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.strip_prefix">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">strip_prefix</code><span class="sig-paren">(</span><em class="sig-param">full_string</em>, <em class="sig-param">prefix</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#strip_prefix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.strip_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip the prefix from the given string and return it. If the prefix is not present
the original string will be returned unaltered</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_string</strong> – the string from which to remove the prefix</p></li>
<li><p><strong>prefix</strong> – the prefix to remove</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the string with prefix removed</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.validate_list_of_string_tuples">
<code class="sig-prename descclassname">aiida.common.utils.</code><code class="sig-name descname">validate_list_of_string_tuples</code><span class="sig-paren">(</span><em class="sig-param">val</em>, <em class="sig-param">tuple_length</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#validate_list_of_string_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.validate_list_of_string_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code> is a list or tuple</p></li>
<li><p>each element of the list:</p></li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>is a list or tuple</p></li>
<li><p>is of length equal to the parameter tuple_length</p></li>
<li><p>each of the two elements is a string</p></li>
</ol>
</div></blockquote>
<p>Return if valid, raise ValidationError if invalid</p>
</dd></dl>

<span class="target" id="module-aiida.common.warnings"></span><p>Define warnings that can be thrown by AiiDA.</p>
<dl class="exception">
<dt id="aiida.common.warnings.AiidaDeprecationWarning">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.warnings.</code><code class="sig-name descname">AiidaDeprecationWarning</code><a class="reference internal" href="../_modules/aiida/common/warnings.html#AiidaDeprecationWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.warnings.AiidaDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Warning" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></a></p>
<p>Class for AiiDA deprecations.</p>
<p>It does <em>not</em> inherit, on purpose, from <cite>DeprecationWarning</cite> as
this would be filtered out by default.
Enabled by default, you can disable it by running in the shell:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">verdi</span> <span class="n">config</span> <span class="n">warnings</span><span class="o">.</span><span class="n">showdeprecations</span> <span class="kc">False</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.warnings.AiidaDeprecationWarning.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.warnings'</em><a class="headerlink" href="#aiida.common.warnings.AiidaDeprecationWarning.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.warnings.AiidaDeprecationWarning.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.warnings.AiidaDeprecationWarning.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.warnings.AiidaEntryPointWarning">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.warnings.</code><code class="sig-name descname">AiidaEntryPointWarning</code><a class="reference internal" href="../_modules/aiida/common/warnings.html#AiidaEntryPointWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.warnings.AiidaEntryPointWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Warning" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></a></p>
<p>Class for warnings concerning AiiDA entry points.</p>
<dl class="attribute">
<dt id="aiida.common.warnings.AiidaEntryPointWarning.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.warnings'</em><a class="headerlink" href="#aiida.common.warnings.AiidaEntryPointWarning.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.warnings.AiidaEntryPointWarning.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.warnings.AiidaEntryPointWarning.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.warnings.AiidaTestWarning">
<em class="property">exception </em><code class="sig-prename descclassname">aiida.common.warnings.</code><code class="sig-name descname">AiidaTestWarning</code><a class="reference internal" href="../_modules/aiida/common/warnings.html#AiidaTestWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.warnings.AiidaTestWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Warning" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></a></p>
<p>Class for warnings concerning the AiiDA testing infrastructure.</p>
<dl class="attribute">
<dt id="aiida.common.warnings.AiidaTestWarning.__module__">
<code class="sig-name descname">__module__</code><em class="property"> = 'aiida.common.warnings'</em><a class="headerlink" href="#aiida.common.warnings.AiidaTestWarning.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.warnings.AiidaTestWarning.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#aiida.common.warnings.AiidaTestWarning.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>