

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.autogroup &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/togglebutton.js"></script>
        <script src="../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.autogroup</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.autogroup</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Module to manage the autogrouping functionality by ``verdi run``.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">exceptions</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="kn">import</span> <span class="n">escape_for_sql_like</span><span class="p">,</span> <span class="n">get_regex_pattern_from_sql</span>
<span class="kn">from</span> <span class="nn">aiida.common.warnings</span> <span class="kn">import</span> <span class="n">AiidaDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">AutoGroup</span>
<span class="kn">from</span> <span class="nn">aiida.plugins.entry_point</span> <span class="kn">import</span> <span class="n">get_entry_point_string_from_class</span>

<span class="n">CURRENT_AUTOGROUP</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="Autogroup"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup">[docs]</a><span class="k">class</span> <span class="nc">Autogroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class to create a new `AutoGroup` instance that will, while active, automatically contain all nodes being stored.</span>

<span class="sd">    The autogrouping is checked by the `Node.store()` method which, if `CURRENT_AUTOGROUP is not None` the method</span>
<span class="sd">    `Autogroup.is_to_be_grouped` is called to decide whether to put the current node being stored in the current</span>
<span class="sd">    `AutoGroup` instance.</span>

<span class="sd">    The exclude/include lists are lists of strings like:</span>
<span class="sd">    ``aiida.data:int``, ``aiida.calculation:quantumespresso.pw``,</span>
<span class="sd">    ``aiida.data:array.%``, ...</span>
<span class="sd">    i.e.: a string identifying the base class, followed a colona and by the path to the class</span>
<span class="sd">    as accepted by CalculationFactory/DataFactory.</span>
<span class="sd">    Each string can contain one or more wildcard characters ``%``;</span>
<span class="sd">    in this case this is used in a ``like`` comparison with the QueryBuilder.</span>
<span class="sd">    Note that in this case you have to remember that ``_`` means &quot;any character&quot;</span>
<span class="sd">    in the QueryBuilder, and you need to escape it if you mean a literal underscore.</span>

<span class="sd">    Only one of the two (between exclude and include) can be set.</span>
<span class="sd">    If none of the two is set, everything is included.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Autogroup.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize with defaults.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exclude</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">default_label_prefix</span> <span class="o">=</span> <span class="s1">&#39;Verdi autogroup on &#39;</span> <span class="o">+</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_label_prefix</span> <span class="o">=</span> <span class="n">default_label_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_label</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Actual group label, set by `get_or_create_group`</span></div>

<div class="viewcode-block" id="Autogroup.validate"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.validate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate the list of strings passed to set_include and set_exclude.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">valid_prefixes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;aiida.node&#39;</span><span class="p">,</span> <span class="s1">&#39;aiida.calculations&#39;</span><span class="p">,</span> <span class="s1">&#39;aiida.workflows&#39;</span><span class="p">,</span> <span class="s1">&#39;aiida.data&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pieces</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is not a valid include/exclude filter, must contain two parts split by a colon&quot;</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_prefixes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; has an invalid prefix, must be among: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">valid_prefixes</span><span class="p">))</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Autogroup.get_exclude"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.get_exclude">[docs]</a>    <span class="k">def</span> <span class="nf">get_exclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of classes to exclude from autogrouping.</span>

<span class="sd">        Returns ``None`` if no exclusion list has been set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exclude</span></div>

<div class="viewcode-block" id="Autogroup.get_include"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.get_include">[docs]</a>    <span class="k">def</span> <span class="nf">get_include</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of classes to include in the autogrouping.</span>

<span class="sd">        Returns ``None`` if no inclusion list has been set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include</span></div>

<div class="viewcode-block" id="Autogroup.get_group_label_prefix"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.get_group_label_prefix">[docs]</a>    <span class="k">def</span> <span class="nf">get_group_label_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the prefix of the label of the group.</span>
<span class="sd">        If no group label prefix was set, it will set a default one by itself.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_label_prefix</span></div>

<div class="viewcode-block" id="Autogroup.get_group_name"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.get_group_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_group_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the label of the group.</span>
<span class="sd">        If no group label was set, it will set a default one by itself.</span>

<span class="sd">        .. deprecated:: 1.2.0</span>
<span class="sd">            Will be removed in `v2.0.0`, use :py:meth:`.get_group_label_prefix` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;function is deprecated, use `get_group_label_prefix` instead&#39;</span><span class="p">,</span> <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_group_label_prefix</span><span class="p">()</span></div>

<div class="viewcode-block" id="Autogroup.set_exclude"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.set_exclude">[docs]</a>    <span class="k">def</span> <span class="nf">set_exclude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the list of classes to exclude in the autogrouping.</span>

<span class="sd">        :param exclude: a list of valid entry point strings (might contain &#39;%&#39; to be used as</span>
<span class="sd">          string to be matched using SQL&#39;s ``LIKE`` pattern-making logic), or ``None``</span>
<span class="sd">          to specify no include list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_include</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># It&#39;s ok to set None, both as a default, or to &#39;undo&#39; the exclude list</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span><span class="s1">&#39;Cannot both specify exclude and include&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exclude</span> <span class="o">=</span> <span class="n">exclude</span></div>

<div class="viewcode-block" id="Autogroup.set_include"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.set_include">[docs]</a>    <span class="k">def</span> <span class="nf">set_include</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the list of classes to include in the autogrouping.</span>

<span class="sd">        :param include: a list of valid entry point strings (might contain &#39;%&#39; to be used as</span>
<span class="sd">          string to be matched using SQL&#39;s ``LIKE`` pattern-making logic), or ``None``</span>
<span class="sd">          to specify no include list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">include</span> <span class="o">=</span> <span class="p">[</span><span class="n">include</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">include</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_exclude</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># It&#39;s ok to set None, both as a default, or to &#39;undo&#39; the include list</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span><span class="s1">&#39;Cannot both specify exclude and include&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_include</span> <span class="o">=</span> <span class="n">include</span></div>

<div class="viewcode-block" id="Autogroup.set_group_label_prefix"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.set_group_label_prefix">[docs]</a>    <span class="k">def</span> <span class="nf">set_group_label_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_prefix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the label of the group to be created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_prefix</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span><span class="s1">&#39;group label must be a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_label_prefix</span> <span class="o">=</span> <span class="n">label_prefix</span></div>

<div class="viewcode-block" id="Autogroup.set_group_name"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.set_group_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_group_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the group.</span>

<span class="sd">        .. deprecated:: 1.2.0</span>
<span class="sd">            Will be removed in `v2.0.0`, use :py:meth:`.set_group_label_prefix` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;function is deprecated, use `set_group_label_prefix` instead&#39;</span><span class="p">,</span> <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_group_label_prefix</span><span class="p">(</span><span class="n">label_prefix</span><span class="o">=</span><span class="n">gname</span><span class="p">)</span></div>

<div class="viewcode-block" id="Autogroup._matches"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup._matches">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_matches</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if &#39;string&#39; matches the &#39;filter_string&#39; (used for include and exclude filters).</span>

<span class="sd">        If &#39;filter_string&#39; does not contain any % sign, perform an exact match.</span>
<span class="sd">        Otherwise, match with a SQL-like query, where % means any character sequence,</span>
<span class="sd">        and _ means a single character (these caracters can be escaped with a backslash).</span>

<span class="sd">        :param string: the string to match.</span>
<span class="sd">        :param filter_string: the filter string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;%&#39;</span> <span class="ow">in</span> <span class="n">filter_string</span><span class="p">:</span>
            <span class="n">regex_filter</span> <span class="o">=</span> <span class="n">get_regex_pattern_from_sql</span><span class="p">(</span><span class="n">filter_string</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex_filter</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">string</span> <span class="o">==</span> <span class="n">filter_string</span></div>

<div class="viewcode-block" id="Autogroup.is_to_be_grouped"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.is_to_be_grouped">[docs]</a>    <span class="k">def</span> <span class="nf">is_to_be_grouped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the given node has to be included in the autogroup according to include/exclude list</span>

<span class="sd">        :return (bool): True if ``node`` is to be included in the autogroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># strings, including possibly &#39;all&#39;</span>
        <span class="n">include</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_include</span><span class="p">()</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_exclude</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Include all classes by default if nothing is explicitly specified.</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># We should never be here, anyway - this should be catched by the `set_include/exclude` methods</span>
        <span class="k">assert</span> <span class="n">include</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;You cannot specify both an &#39;include&#39; and an &#39;exclude&#39; list&quot;</span>

        <span class="n">entry_point_string</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">process_type</span>
        <span class="c1"># If there is no `process_type` we are dealing with a `Data` node so we get the entry point from the class</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_point_string</span><span class="p">:</span>
            <span class="n">entry_point_string</span> <span class="o">=</span> <span class="n">get_entry_point_string_from_class</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># As soon as a filter string matches, we include the class</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_matches</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">)</span> <span class="k">for</span> <span class="n">filter_string</span> <span class="ow">in</span> <span class="n">include</span><span class="p">)</span>
        <span class="c1"># If we are here, exclude is not None</span>
        <span class="c1"># include *only* in *none* of the filters match (that is, exclude as</span>
        <span class="c1"># soon as any of the filters matches)</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_matches</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">,</span> <span class="n">filter_string</span><span class="p">)</span> <span class="k">for</span> <span class="n">filter_string</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">)</span></div>

<div class="viewcode-block" id="Autogroup.clear_group_cache"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.clear_group_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_group_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the cache of the group name.</span>

<span class="sd">        This is mostly used by tests when they reset the database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_label</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Autogroup.get_or_create_group"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.autogroup.Autogroup.get_or_create_group">[docs]</a>    <span class="k">def</span> <span class="nf">get_or_create_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current `AutoGroup`, or create one if None has been set yet.</span>

<span class="sd">        This function implements a somewhat complex logic that is however needed</span>
<span class="sd">        to make sure that, even if `verdi run` is called at the same time multiple</span>
<span class="sd">        times, e.g. in a for loop in bash, there is never the risk that two ``verdi run``</span>
<span class="sd">        Unix processes try to create the same group, with the same label, ending</span>
<span class="sd">        up in a crash of the code (see PR #3650).</span>

<span class="sd">        Here, instead, we make sure that if this concurrency issue happens,</span>
<span class="sd">        one of the two will get a IntegrityError from the DB, and then recover</span>
<span class="sd">        trying to create a group with a different label (with a numeric suffix appended),</span>
<span class="sd">        until it manages to create it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">QueryBuilder</span>

        <span class="c1"># When this function is called, if it is the first time, just generate</span>
        <span class="c1"># a new group name (later on, after this ``if`` block`).</span>
        <span class="c1"># In that case, we will later cache in ``self._group_label`` the group label,</span>
        <span class="c1"># So the group with the same name can be returned quickly in future</span>
        <span class="c1"># calls of this method.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AutoGroup</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_label</span><span class="p">})</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">iterall</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
                <span class="c1"># If it is not empty, it should have only one result due to the uniqueness constraints</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;I got more than one autogroup with the same label!&#39;</span>
                <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># There are no results: probably the group has been deleted.</span>
            <span class="c1"># I continue as if it was not cached</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group_label</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">label_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_group_label_prefix</span><span class="p">()</span>
        <span class="c1"># Try to do a preliminary QB query to avoid to do too many try/except</span>
        <span class="c1"># if many of the prefix_NUMBER groups already exist</span>
        <span class="n">queryb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">AutoGroup</span><span class="p">,</span>
            <span class="n">filters</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="p">[{</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">label_prefix</span>
                    <span class="p">}</span>
                <span class="p">},</span> <span class="p">{</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">label_prefix</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span>
                    <span class="p">}</span>
                <span class="p">}]</span>
            <span class="p">},</span>
            <span class="n">project</span><span class="o">=</span><span class="s1">&#39;label&#39;</span>
        <span class="p">)</span>
        <span class="n">existing_group_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">label_prefix</span><span class="p">):]</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">queryb</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
        <span class="n">existing_group_ints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">existing_group_labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># This is just the prefix without name - corresponds to counter = 0</span>
                <span class="n">existing_group_ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">existing_group_ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># It&#39;s not an integer, so it will never collide - just ignore it</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">existing_group_ints</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">existing_group_ints</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label_prefix</span> <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label_prefix</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">AutoGroup</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group_label</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">label</span>
            <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">group</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>