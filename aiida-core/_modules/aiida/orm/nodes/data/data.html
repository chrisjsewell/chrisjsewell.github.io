

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.nodes.data.data &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
        <script src="../../../../../_static/togglebutton.js"></script>
        <script src="../../../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.nodes.data.data</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.nodes.data.data</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Module with `Node` sub class `Data` to be used as a base class for data structures.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="kn">import</span> <span class="n">LinkType</span>
<span class="kn">from</span> <span class="nn">aiida.common.lang</span> <span class="kn">import</span> <span class="n">override</span>

<span class="kn">from</span> <span class="nn">..node</span> <span class="kn">import</span> <span class="n">Node</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Data&#39;</span><span class="p">,)</span>


<div class="viewcode-block" id="Data"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data">[docs]</a><span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for all Data nodes.</span>

<span class="sd">    AiiDA Data classes are subclasses of Node and must support multiple inheritance.</span>

<span class="sd">    Architecture note:</span>
<span class="sd">    Calculation plugins are responsible for converting raw output data from simulation codes to Data nodes.</span>
<span class="sd">    Data nodes are responsible for validating their content (see _validate method).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_source_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;db_name&#39;</span><span class="p">,</span> <span class="s1">&#39;db_uri&#39;</span><span class="p">,</span> <span class="s1">&#39;uri&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;version&#39;</span><span class="p">,</span> <span class="s1">&#39;extras&#39;</span><span class="p">,</span> <span class="s1">&#39;source_md5&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;license&#39;</span><span class="p">]</span>

    <span class="c1"># Replace this with a dictionary in each subclass that, given a file</span>
    <span class="c1"># extension, returns the corresponding fileformat string.</span>
    <span class="c1">#</span>
    <span class="c1"># This is used in the self.export() method.</span>
    <span class="c1"># By default, if not found here,</span>
    <span class="c1"># The fileformat string is assumed to match the extension.</span>
    <span class="c1"># Example: {&#39;dat&#39;: &#39;dat_multicolumn&#39;}</span>
    <span class="n">_export_format_replacements</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Data nodes are storable</span>
    <span class="n">_storable</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_unstorable_message</span> <span class="o">=</span> <span class="s1">&#39;storing for this node has been disabled&#39;</span>

<div class="viewcode-block" id="Data.__copy__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copying a Data node is not supported, use copy.deepcopy or call Data.clone().&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InvalidOperation</span><span class="p">(</span><span class="s1">&#39;copying a Data node is not supported, use copy.deepcopy&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data.__deepcopy__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.__deepcopy__">[docs]</a>    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a clone of the Data node by pipiong through to the clone method and return the result.</span>

<span class="sd">        :returns: an unstored clone of this Data node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span></div>

<div class="viewcode-block" id="Data.clone"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a clone of the Data node.</span>

<span class="sd">        :returns: an unstored clone of this Data node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=no-member</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="n">backend_clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_backend_entity</span><span class="p">(</span><span class="n">backend_clone</span><span class="p">)</span>

        <span class="n">clone</span><span class="o">.</span><span class="n">reset_attributes</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">))</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">put_object_from_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">_get_base_folder</span><span class="p">()</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span>  <span class="c1"># pylint: disable=protected-access</span>

        <span class="k">return</span> <span class="n">clone</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the dictionary describing the source of Data object. Possible fields:</span>

<span class="sd">        * **db_name**: name of the source database.</span>
<span class="sd">        * **db_uri**: URI of the source database.</span>
<span class="sd">        * **uri**: URI of the object&#39;s source. Should be a permanent link.</span>
<span class="sd">        * **id**: object&#39;s source identifier in the source database.</span>
<span class="sd">        * **version**: version of the object&#39;s source.</span>
<span class="sd">        * **extras**: a dictionary with other fields for source description.</span>
<span class="sd">        * **source_md5**: MD5 checksum of object&#39;s source.</span>
<span class="sd">        * **description**: human-readable free form description of the object&#39;s source.</span>
<span class="sd">        * **license**: a string with a type of license.</span>

<span class="sd">        .. note:: some limitations for setting the data source exist, see ``_validate`` method.</span>

<span class="sd">        :return: dictionary describing the source of Data object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@source</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the dictionary describing the source of Data object.</span>

<span class="sd">        :raise KeyError: if dictionary contains unknown field.</span>
<span class="sd">        :raise ValueError: if supplied source description is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Source must be supplied as a dictionary&#39;</span><span class="p">)</span>
        <span class="n">unknown_attrs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_attributes</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">unknown_attrs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Unknown source parameters: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unknown_attrs</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<div class="viewcode-block" id="Data.set_source"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.set_source">[docs]</a>    <span class="k">def</span> <span class="nf">set_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the dictionary describing the source of Data object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">creator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the creator of this node or None if it does not exist.</span>

<span class="sd">        :return: the creating node or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_incoming</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inputs</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">node</span>

        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Data._exportcontent"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data._exportcontent">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">_exportcontent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileformat</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Data node to one (or multiple) files.</span>

<span class="sd">        Note: Export plugins should return utf8-encoded **bytes**, which can be</span>
<span class="sd">        directly dumped to file.</span>

<span class="sd">        :param fileformat: the extension, uniquely specifying the file format.</span>
<span class="sd">        :type fileformat: str</span>
<span class="sd">        :param main_file_name: (empty by default) Can be used by plugin to</span>
<span class="sd">            infer sensible names for additional files, if necessary.  E.g. if the</span>
<span class="sd">            main file is &#39;../myplot.gnu&#39;, the plugin may decide to store the dat</span>
<span class="sd">            file under &#39;../myplot_data.dat&#39;.</span>
<span class="sd">        :type main_file_name: str</span>
<span class="sd">        :param kwargs: other parameters are passed down to the plugin</span>
<span class="sd">        :returns: a tuple of length 2. The first element is the content of the</span>
<span class="sd">            otuput file. The second is a dictionary (possibly empty) in the format</span>
<span class="sd">            {filename: filecontent} for any additional file that should be produced.</span>
<span class="sd">        :rtype: (bytes, dict)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exporters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_exporters</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">exporters</span><span class="p">[</span><span class="n">fileformat</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exporters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The format </span><span class="si">{}</span><span class="s1"> is not implemented for </span><span class="si">{}</span><span class="s1">. &#39;</span>
                    <span class="s1">&#39;Currently implemented are: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">fileformat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">exporters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The format </span><span class="si">{}</span><span class="s1"> is not implemented for </span><span class="si">{}</span><span class="s1">. &#39;</span>
                    <span class="s1">&#39;No formats are implemented yet.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fileformat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">string</span><span class="p">,</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">main_file_name</span><span class="o">=</span><span class="n">main_file_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">),</span> <span class="s1">&#39;export function `</span><span class="si">{}</span><span class="s1">` did not return the content as a byte string.&#39;</span>

        <span class="k">return</span> <span class="n">string</span><span class="p">,</span> <span class="n">dictionary</span></div>

<div class="viewcode-block" id="Data.export"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.export">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">fileformat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a Data object to a file.</span>

<span class="sd">        :param fname: string with file name. Can be an absolute or relative path.</span>
<span class="sd">        :param fileformat: kind of format to use for the export. If not present,</span>
<span class="sd">            it will try to use the extension of the file name.</span>
<span class="sd">        :param overwrite: if set to True, overwrites file found at path. Default=False</span>
<span class="sd">        :param kwargs: additional parameters to be passed to the</span>
<span class="sd">            _exportcontent method</span>
<span class="sd">        :return: the list of files created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">os</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Path not recognized&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;A file was already found at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fileformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span><span class="p">):</span>
                <span class="n">extension</span> <span class="o">=</span> <span class="n">extension</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span><span class="p">):]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">extension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot recognized the fileformat from the extension&#39;</span><span class="p">)</span>

            <span class="c1"># Replace the fileformat using the replacements specified in the</span>
            <span class="c1"># _export_format_replacements dictionary. If not found there,</span>
            <span class="c1"># by default assume the fileformat string is identical to the extension</span>
            <span class="n">fileformat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_format_replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">extension</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span>

        <span class="n">retlist</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">filetext</span><span class="p">,</span> <span class="n">extra_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exportcontent</span><span class="p">(</span><span class="n">fileformat</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">extra_files</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;The file </span><span class="si">{}</span><span class="s1"> already exists, stopping.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;The file </span><span class="si">{}</span><span class="s1"> already exists, stopping.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">additional_fname</span><span class="p">,</span> <span class="n">additional_fcontent</span> <span class="ow">in</span> <span class="n">extra_files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">retlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_fname</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">additional_fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
                <span class="n">fhandle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">additional_fcontent</span><span class="p">)</span>  <span class="c1"># This is up to each specific plugin</span>
        <span class="n">retlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
            <span class="n">fhandle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filetext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retlist</span></div>

<div class="viewcode-block" id="Data._get_exporters"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data._get_exporters">[docs]</a>    <span class="k">def</span> <span class="nf">_get_exporters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all implemented export formats.</span>
<span class="sd">        The convention is to find all _prepare_... methods.</span>
<span class="sd">        Returns a dictionary of method_name: method_function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: To add support for a new format, write a new function called as</span>
        <span class="c1"># _prepare_&quot;&quot; with the name of the new format</span>
        <span class="n">exporter_prefix</span> <span class="o">=</span> <span class="s1">&#39;_prepare_&#39;</span>
        <span class="n">valid_format_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_export_formats</span><span class="p">()</span>
        <span class="n">valid_formats</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exporter_prefix</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">valid_format_names</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">valid_formats</span></div>

<div class="viewcode-block" id="Data.get_export_formats"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.get_export_formats">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_export_formats</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the list of valid export format strings</span>

<span class="sd">        :return: a list of valid formats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exporter_prefix</span> <span class="o">=</span> <span class="s1">&#39;_prepare_&#39;</span>
        <span class="n">method_names</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>  <span class="c1"># get list of class methods names</span>
        <span class="n">valid_format_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">exporter_prefix</span><span class="p">):]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">method_names</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">exporter_prefix</span><span class="p">)</span>
        <span class="p">]</span>  <span class="c1"># filter them</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">valid_format_names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data.importstring"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.importstring">[docs]</a>    <span class="k">def</span> <span class="nf">importstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputstring</span><span class="p">,</span> <span class="n">fileformat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Data object to other text format.</span>

<span class="sd">        :param fileformat: a string (the extension) to describe the file format.</span>
<span class="sd">        :returns: a string with the structure description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">importers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_importers</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">importers</span><span class="p">[</span><span class="n">fileformat</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">importers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The format </span><span class="si">{}</span><span class="s1"> is not implemented for </span><span class="si">{}</span><span class="s1">. &#39;</span>
                    <span class="s1">&#39;Currently implemented are: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">fileformat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">importers</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The format </span><span class="si">{}</span><span class="s1"> is not implemented for </span><span class="si">{}</span><span class="s1">. &#39;</span>
                    <span class="s1">&#39;No formats are implemented yet.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fileformat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># func is bound to self by getattr in _get_importers()</span>
        <span class="n">func</span><span class="p">(</span><span class="n">inputstring</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data.importfile"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.importfile">[docs]</a>    <span class="k">def</span> <span class="nf">importfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fileformat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate a Data object from a file.</span>

<span class="sd">        :param fname: string with file name. Can be an absolute or relative path.</span>
<span class="sd">        :param fileformat: kind of format to use for the export. If not present,</span>
<span class="sd">            it will try to use the extension of the file name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fileformat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fileformat</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>  <span class="c1"># reads in cwd, if fname is not absolute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">importstring</span><span class="p">(</span><span class="n">fhandle</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">fileformat</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data._get_importers"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data._get_importers">[docs]</a>    <span class="k">def</span> <span class="nf">_get_importers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all implemented import formats.</span>
<span class="sd">        The convention is to find all _parse_... methods.</span>
<span class="sd">        Returns a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: To add support for a new format, write a new function called as</span>
        <span class="c1"># _parse_&quot;&quot; with the name of the new format</span>
        <span class="n">importer_prefix</span> <span class="o">=</span> <span class="s1">&#39;_parse_&#39;</span>
        <span class="n">method_names</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># get list of class methods names</span>
        <span class="n">valid_format_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">importer_prefix</span><span class="p">):]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">method_names</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">importer_prefix</span><span class="p">)]</span>
        <span class="n">valid_formats</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">importer_prefix</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">valid_format_names</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">valid_formats</span></div>

<div class="viewcode-block" id="Data.convert"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the AiiDA StructureData into another python object</span>

<span class="sd">        :param object_format: Specify the output format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=keyword-arg-before-vararg</span>

        <span class="k">if</span> <span class="n">object_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object_format must be provided&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_format</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object_format should be a string&#39;</span><span class="p">)</span>

        <span class="n">converters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_converters</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">converters</span><span class="p">[</span><span class="n">object_format</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">converters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The format </span><span class="si">{}</span><span class="s1"> is not implemented for </span><span class="si">{}</span><span class="s1">. &#39;</span>
                    <span class="s1">&#39;Currently implemented are: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">object_format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">converters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The format </span><span class="si">{}</span><span class="s1"> is not implemented for </span><span class="si">{}</span><span class="s1">. &#39;</span>
                    <span class="s1">&#39;No formats are implemented yet.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">object_format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Data._get_converters"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data._get_converters">[docs]</a>    <span class="k">def</span> <span class="nf">_get_converters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all implemented converter formats.</span>
<span class="sd">        The convention is to find all _get_object_... methods.</span>
<span class="sd">        Returns a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: To add support for a new format, write a new function called as</span>
        <span class="c1"># _prepare_&quot;&quot; with the name of the new format</span>
        <span class="n">exporter_prefix</span> <span class="o">=</span> <span class="s1">&#39;_get_object_&#39;</span>
        <span class="n">method_names</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># get list of class methods names</span>
        <span class="n">valid_format_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">exporter_prefix</span><span class="p">):]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">method_names</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">exporter_prefix</span><span class="p">)]</span>
        <span class="n">valid_formats</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exporter_prefix</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">valid_format_names</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">valid_formats</span></div>

<div class="viewcode-block" id="Data._validate"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.orm.Data._validate">[docs]</a>    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform validation of the Data object.</span>

<span class="sd">        .. note:: validation of data source checks license and requires</span>
<span class="sd">            attribution to be provided in field &#39;description&#39; of source in</span>
<span class="sd">            the case of any CC-BY* license. If such requirement is too</span>
<span class="sd">            strict, one can remove/comment it out.</span>
<span class="sd">        &quot;&quot;&quot;</span></div></div>
        <span class="c1"># Validation of ``source`` is commented out due to Issue #9</span>
        <span class="c1"># (https://bitbucket.org/epfl_theos/aiida_epfl/issues/9/)</span>
        <span class="c1"># super()._validate()</span>
        <span class="c1"># if self.source is not None and \</span>
        <span class="c1">#    self.source.get(&#39;license&#39;, None) and \</span>
        <span class="c1">#    self.source[&#39;license&#39;].startswith(&#39;CC-BY&#39;) and \</span>
        <span class="c1">#    self.source.get(&#39;description&#39;, None) is None:</span>
        <span class="c1">#     raise ValidationError(&quot;License of the object ({}) requires &quot;</span>
        <span class="c1">#                           &quot;attribution, while none is given in the &quot;</span>
        <span class="c1">#                           &quot;description&quot;.format(self.source[&#39;license&#39;]))</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>