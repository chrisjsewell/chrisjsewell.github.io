

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.nodes.data.array.kpoints &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../../" src="../../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../../_static/jquery.js"></script>
        <script src="../../../../../../_static/underscore.js"></script>
        <script src="../../../../../../_static/doctools.js"></script>
        <script src="../../../../../../_static/language_data.js"></script>
        <script src="../../../../../../_static/togglebutton.js"></script>
        <script src="../../../../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.nodes.data.array.kpoints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.nodes.data.array.kpoints</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module of the KpointsData class, defining the AiiDA data type for storing</span>
<span class="sd">lists and meshes of k-points (i.e., points in the reciprocal space of a</span>
<span class="sd">periodic crystal structure).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">.array</span> <span class="kn">import</span> <span class="n">ArrayData</span>

<span class="n">_DEFAULT_EPSILON_LENGTH</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="n">_DEFAULT_EPSILON_ANGLE</span> <span class="o">=</span> <span class="mf">1e-5</span>


<div class="viewcode-block" id="KpointsData"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData">[docs]</a><span class="k">class</span> <span class="nc">KpointsData</span><span class="p">(</span><span class="n">ArrayData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to handle array of kpoints in the Brillouin zone. Provide methods to</span>
<span class="sd">    generate either user-defined k-points or path of k-points along symmetry</span>
<span class="sd">    lines.</span>
<span class="sd">    Internally, all k-points are defined in terms of crystal (fractional)</span>
<span class="sd">    coordinates.</span>
<span class="sd">    Cell and lattice vector coordinates are in Angstroms, reciprocal lattice</span>
<span class="sd">    vectors in Angstrom^-1 .</span>
<span class="sd">    :note: The methods setting and using the Bravais lattice info assume the</span>
<span class="sd">    PRIMITIVE unit cell is provided in input to the set_cell or</span>
<span class="sd">    set_cell_from_structure methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KpointsData.get_description"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.get_description">[docs]</a>    <span class="k">def</span> <span class="nf">get_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string with infos retrieved from  kpoints node&#39;s properties.</span>
<span class="sd">        :param node:</span>
<span class="sd">        :return: retstr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints_mesh</span><span class="p">()</span>
            <span class="k">return</span> <span class="s1">&#39;Kpoints mesh: </span><span class="si">{}</span><span class="s1">x</span><span class="si">{}</span><span class="s1">x</span><span class="si">{}</span><span class="s1"> (+</span><span class="si">{:.1f}</span><span class="s1">,</span><span class="si">{:.1f}</span><span class="s1">,</span><span class="si">{:.1f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;(Path of </span><span class="si">{}</span><span class="s1"> kpts)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">()))</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The crystal unit cell. Rows are the crystal vectors in Angstroms.</span>
<span class="sd">        :return: a 3x3 numpy.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">))</span>

    <span class="nd">@cell</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the crystal unit cell</span>
<span class="sd">        :param value: a 3x3 list/tuple/array of numbers (units = Angstroms).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_cell"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData._set_cell">[docs]</a>    <span class="k">def</span> <span class="nf">_set_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate if &#39;value&#39; is a allowed crystal unit cell</span>
<span class="sd">        :param value: something compatible with a 3x3 tuple of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="kn">import</span> <span class="n">ModificationNotAllowed</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.nodes.data.structure</span> <span class="kn">import</span> <span class="n">_get_valid_cell</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;KpointsData cannot be modified, it has already been stored&#39;</span><span class="p">)</span>

        <span class="n">the_cell</span> <span class="o">=</span> <span class="n">_get_valid_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">the_cell</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The periodic boundary conditions along the vectors a1,a2,a3.</span>

<span class="sd">        :return: a tuple of three booleans, each one tells if there are periodic</span>
<span class="sd">            boundary conditions for the i-th real-space direction (i=1,2,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return copy.deepcopy(self._pbc)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc1&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc2&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc3&#39;</span><span class="p">))</span>

    <span class="nd">@pbc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of pbc, i.e. a tuple of three booleans, indicating if the</span>
<span class="sd">        cell is periodic in the 1,2,3 crystal direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_pbc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_pbc"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData._set_pbc">[docs]</a>    <span class="k">def</span> <span class="nf">_set_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        validate the pbc, then store them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="kn">import</span> <span class="n">ModificationNotAllowed</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.nodes.data.structure</span> <span class="kn">import</span> <span class="n">get_valid_pbc</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;The KpointsData object cannot be modified, it has already been stored&#39;</span><span class="p">)</span>
        <span class="n">the_pbc</span> <span class="o">=</span> <span class="n">get_valid_pbc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc1&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc2&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc3&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Labels associated with the list of kpoints.</span>
<span class="sd">        List of tuples with kpoint index and kpoint name: ``[(0,&#39;G&#39;),(13,&#39;M&#39;),...]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_numbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;label_numbers&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">label_numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">label_numbers</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>

    <span class="nd">@labels</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_labels</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_labels"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData._set_labels">[docs]</a>    <span class="k">def</span> <span class="nf">_set_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set label names. Must pass in input a list like: ``[[0,&#39;X&#39;],[34,&#39;L&#39;],... ]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if kpoints were set</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Kpoints must be set before the labels&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">label_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The input must contain an integer index, to map the labels into the kpoint list&#39;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">label_numbers</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Index of label exceeding the list of kpoints&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;label_numbers&#39;</span><span class="p">,</span> <span class="n">label_numbers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData._change_reference"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData._change_reference">[docs]</a>    <span class="k">def</span> <span class="nf">_change_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">to_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change reference system, from cartesian to crystal coordinates (units of b1,b2,b3) or viceversa.</span>
<span class="sd">        :param kpoints: a list of (3) point coordinates</span>
<span class="sd">        :return kpoints: a list of (3) point coordinates in the new reference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kpoints must be a numpy.array for method change_reference()&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">rec_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_cell</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># rec_cell = numpy.eye(3)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Cannot use cartesian coordinates without having defined a cell&#39;</span><span class="p">)</span>

        <span class="n">trec_cell</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rec_cell</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">to_cartesian</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">trec_cell</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">trec_cell</span><span class="p">)</span>

        <span class="c1"># note: kpoints is a list Nx3, matrix is 3x3.</span>
        <span class="c1"># hence, first transpose kpoints, then multiply, finally transpose it back</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)))</span></div>

<div class="viewcode-block" id="KpointsData.set_cell_from_structure"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.set_cell_from_structure">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell_from_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structuredata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a cell to be used for symmetry analysis from an AiiDA structure.</span>
<span class="sd">        Inherits both the cell and the pbc&#39;s.</span>
<span class="sd">        To set manually a cell, use &quot;set_cell&quot;</span>

<span class="sd">        :param structuredata: an instance of StructureData</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">StructureData</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structuredata</span><span class="p">,</span> <span class="n">StructureData</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;An instance of StructureData should be passed to &#39;</span>
                <span class="s1">&#39;the KpointsData, found instead </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">structuredata</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">structuredata</span><span class="o">.</span><span class="n">cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">structuredata</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData.set_cell"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.set_cell">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a cell to be used for symmetry analysis.</span>
<span class="sd">        To set a cell from an AiiDA structure, use &quot;set_cell_from_structure&quot;.</span>

<span class="sd">        :param cell: 3x3 matrix of cell vectors. Orientation: each row</span>
<span class="sd">                     represent a lattice vector. Units are Angstroms.</span>
<span class="sd">        :param pbc: list of 3 booleans, True if in the nth crystal direction the</span>
<span class="sd">                    structure is periodic. Default = [True,True,True]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute reciprocal cell from the internally set cell.</span>

<span class="sd">        :returns: reciprocal cell in units of 1/Angstrom with cell vectors stored as rows.</span>
<span class="sd">            Use e.g. reciprocal_cell[0] to access the first reciprocal cell vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">the_cell</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">reciprocal_cell</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">the_cell</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">reciprocal_cell</span>

<div class="viewcode-block" id="KpointsData.set_kpoints_mesh"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.set_kpoints_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set KpointsData to represent a uniformily spaced mesh of kpoints in the</span>
<span class="sd">        Brillouin zone. This excludes the possibility of set/get kpoints</span>

<span class="sd">        :param mesh: a list of three integers, representing the size of the</span>
<span class="sd">            kpoint mesh along b1,b2,b3.</span>
<span class="sd">        :param offset: (optional) a list of three floats between 0 and 1.</span>
<span class="sd">            [0.,0.,0.] is Gamma centered mesh</span>
<span class="sd">            [0.5,0.5,0.5] is half shifted</span>
<span class="sd">            [1.,1.,1.] by periodicity should be equivalent to [0.,0.,0.]</span>
<span class="sd">            Default = [0.,0.,0.].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="kn">import</span> <span class="n">ModificationNotAllowed</span>
        <span class="c1"># validate</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">the_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_mesh</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The kpoint mesh must be a list of three integers&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">the_offset</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">offset</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_offset</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The offset must be a list of three floats&#39;</span><span class="p">)</span>
        <span class="c1"># check that there is no list of kpoints saved already</span>
        <span class="c1"># I cannot have both of them at the same time</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s1">&#39;kpoints&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;KpointsData has already a kpoint-list stored&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="n">the_mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="n">the_offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData.get_kpoints_mesh"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.get_kpoints_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_kpoints_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the mesh of kpoints.</span>

<span class="sd">        :param print_list: default=False. If True, prints the mesh of kpoints as a list</span>

<span class="sd">        :raise AttributeError: if no mesh has been set</span>
<span class="sd">        :return mesh,offset: (if print_list=False) a list of 3 integers and a list of three</span>
<span class="sd">                floats 0&lt;x&lt;1, representing the mesh and the offset of kpoints</span>
<span class="sd">        :return kpoints: (if print_list = True) an explicit list of kpoints coordinates,</span>
<span class="sd">                similar to what returned by get_kpoints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">print_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">offset</span>

        <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">kpoints</span> <span class="o">=</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">offset_kpoints</span> <span class="o">=</span> <span class="n">kpoints</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">offset_kpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">offset_kpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">offset_kpoints</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">offset_kpoints</span></div>

<div class="viewcode-block" id="KpointsData.set_kpoints_mesh_from_density"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.set_kpoints_mesh_from_density">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints_mesh_from_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_parity</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a kpoints mesh using a kpoints density, expressed as the maximum</span>
<span class="sd">        distance between adjacent points along a reciprocal axis</span>

<span class="sd">        :param distance: distance (in 1/Angstrom) between adjacent</span>
<span class="sd">            kpoints, i.e. the number of kpoints along each reciprocal</span>
<span class="sd">            axis i is :math:`|b_i|/distance`</span>
<span class="sd">            where :math:`|b_i|` is the norm of the reciprocal cell vector.</span>
<span class="sd">        :param offset: (optional) a list of three floats between 0 and 1.</span>
<span class="sd">            [0.,0.,0.] is Gamma centered mesh</span>
<span class="sd">            [0.5,0.5,0.5] is half shifted</span>
<span class="sd">            Default = [0.,0.,0.].</span>
<span class="sd">        :param force_parity: (optional) if True, force each integer in the mesh</span>
<span class="sd">            to be even (except for the non-periodic directions).</span>

<span class="sd">        :note: a cell should be defined first.</span>
<span class="sd">        :note: the number of kpoints along non-periodic axes is always 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">rec_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_cell</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># rec_cell = numpy.eye(3)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Cannot define a mesh from a density without having defined a cell&#39;</span><span class="p">)</span>
        <span class="c1"># I first round to the fifth digit |b|/distance (to avoid that e.g.</span>
        <span class="c1"># 3.00000001 becomes 4)</span>
        <span class="n">kpointsmesh</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">distance</span><span class="p">,</span> <span class="mi">5</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span> <span class="n">rec_cell</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">force_parity</span><span class="p">:</span>
            <span class="n">kpointsmesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span> <span class="n">kpointsmesh</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kpoints_mesh</span><span class="p">(</span><span class="n">kpointsmesh</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dimensionality of the structure, found from its pbc (i.e. 1 if it&#39;s a 1D</span>
<span class="sd">        structure, 2 if its 2D, 3 if it&#39;s 3D ...).</span>
<span class="sd">        :return dimensionality: 0, 1, 2 or 3</span>
<span class="sd">        :note: will return 3 if pbc has not been set beforehand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span>

<div class="viewcode-block" id="KpointsData._validate_kpoints_weights"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData._validate_kpoints_weights">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_kpoints_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the list of kpoints and of weights before storage.</span>
<span class="sd">        Kpoints and weights must be convertible respectively to an array of</span>
<span class="sd">        N x dimension and N floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>

        <span class="c1"># I cannot just use `if not kpoints` because it&#39;s a numpy array and</span>
        <span class="c1"># `not` of a numpy array does not work</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pylint: disable=len-as-condition</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># replace empty list by Gamma point</span>
                <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;empty kpoints list is valid only in zero dimension&#39;</span>
                    <span class="s1">&#39;; instead here with have </span><span class="si">{}</span><span class="s1"> dimensions&#39;</span>
                    <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># list of scalars is accepted only in the 0D and 1D cases</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># replace by singletons</span>
                <span class="n">kpoints</span> <span class="o">=</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kpoints must be a list of lists in </span><span class="si">{}</span><span class="s1">D case&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kpoints must be an array of type floats. Found instead </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kpoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;In a system which has </span><span class="si">{0}</span><span class="s1"> dimensions, kpoint need&#39;</span>
                <span class="s1">&#39;more than </span><span class="si">{0}</span><span class="s1"> coordinates (found instead </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">,</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found </span><span class="si">{}</span><span class="s1"> weights but </span><span class="si">{}</span><span class="s1"> kpoints&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weights must be an array of type floats. Found instead </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span></div>

<div class="viewcode-block" id="KpointsData.set_kpoints"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.set_kpoints">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_values</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the list of kpoints. If a mesh has already been stored, raise a</span>
<span class="sd">        ModificationNotAllowed</span>

<span class="sd">        :param kpoints: a list of kpoints, each kpoint being a list of one, two</span>
<span class="sd">            or three coordinates, depending on self.pbc: if structure is 1D</span>
<span class="sd">            (only one True in self.pbc) one allows singletons or scalars for</span>
<span class="sd">            each k-point, if it&#39;s 2D it can be a length-2 list, and in all</span>
<span class="sd">            cases it can be a length-3 list.</span>
<span class="sd">            Examples:</span>

<span class="sd">                * [[0.,0.,0.],[0.1,0.1,0.1],...] for 1D, 2D or 3D</span>
<span class="sd">                * [[0.,0.],[0.1,0.1,],...] for 1D or 2D</span>
<span class="sd">                * [[0.],[0.1],...] for 1D</span>
<span class="sd">                * [0., 0.1, ...] for 1D (list of scalars)</span>

<span class="sd">            For 0D (all pbc are False), the list can be any of the above</span>
<span class="sd">            or empty - then only Gamma point is set.</span>
<span class="sd">            The value of k for the non-periodic dimension(s) is set by</span>
<span class="sd">            fill_values</span>
<span class="sd">        :param cartesian: if True, the coordinates given in input are treated</span>
<span class="sd">            as in cartesian units. If False, the coordinates are crystal,</span>
<span class="sd">            i.e. in units of b1,b2,b3. Default = False</span>
<span class="sd">        :param labels: optional, the list of labels to be set for some of the</span>
<span class="sd">            kpoints. See labels for more info</span>
<span class="sd">        :param weights: optional, a list of floats with the weight associated</span>
<span class="sd">            to the kpoint list</span>
<span class="sd">        :param fill_values: scalar to be set to all</span>
<span class="sd">            non-periodic dimensions (indicated by False in self.pbc), or list of</span>
<span class="sd">            values for each of the non-periodic dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="kn">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="c1"># check that it is a &#39;dim&#39;x #kpoints dimensional array</span>
        <span class="n">the_kpoints</span><span class="p">,</span> <span class="n">the_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_kpoints_weights</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="c1"># if k-points have less than 3 coordinates (low dimensionality), fill</span>
        <span class="c1"># with constant values the non-periodic dimensions</span>
        <span class="k">if</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">fill_values</span><span class="p">):</span>
                <span class="c1"># replace scalar by a list of 3-the_kpoints.shape[1] identical</span>
                <span class="c1"># elements</span>
                <span class="n">fill_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">fill_values</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_values</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;fill_values should be either a scalar or a &#39;</span>
                    <span class="s1">&#39;length-</span><span class="si">{}</span><span class="s1"> list&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">i_kpts</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">i_fill</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="c1"># check periodic boundary condition of each of the 3 dimensions:</span>
                    <span class="c1"># - if it&#39;s a periodic one, fill with the k-points values</span>
                    <span class="c1"># defined in input</span>
                    <span class="c1"># - if it&#39;s non-periodic, fill with one of the values in</span>
                    <span class="c1"># fill_values</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span>
                        <span class="n">tmp_kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">tmp_kpoints</span><span class="p">,</span> <span class="n">the_kpoints</span><span class="p">[:,</span> <span class="n">i_kpts</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span>
                        <span class="p">)</span>
                        <span class="n">i_kpts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp_kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">tmp_kpoints</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">fill_values</span><span class="p">[</span><span class="n">i_fill</span><span class="p">])</span>
                        <span class="p">)</span>
                        <span class="n">i_fill</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">the_kpoints</span> <span class="o">=</span> <span class="n">tmp_kpoints</span>

        <span class="c1"># change reference and always store in crystal coords</span>
        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="n">the_kpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_reference</span><span class="p">(</span><span class="n">the_kpoints</span><span class="p">,</span> <span class="n">to_cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># check that we did not saved a mesh already</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;KpointsData has already a mesh stored&#39;</span><span class="p">)</span>

        <span class="c1"># store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="s1">&#39;kpoints&#39;</span><span class="p">,</span> <span class="n">the_kpoints</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="n">the_weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="KpointsData.get_kpoints"><a class="viewcode-back" href="../../../../../../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.KpointsData.get_kpoints">[docs]</a>    <span class="k">def</span> <span class="nf">get_kpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">also_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of kpoints</span>

<span class="sd">        :param also_weights: if True, returns also the list of weights.</span>
<span class="sd">            Default = False</span>
<span class="sd">        :param cartesian: if True, returns points in cartesian coordinates,</span>
<span class="sd">            otherwise, returns in crystal coordinates. Default = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s1">&#39;kpoints&#39;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Before the get, first set a list of kpoints&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_reference</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">to_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">also_weights</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">the_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;No weights were set&#39;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">the_weights</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span>

        <span class="k">return</span> <span class="n">kpoints</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>