

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.plugins.entry_point &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/togglebutton.js"></script>
        <script src="../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.plugins.entry_point</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.plugins.entry_point</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Module to manage loading entrypoints.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">reentry.default_manager</span> <span class="kn">import</span> <span class="n">PluginManager</span>
    <span class="c1"># I don&#39;t use the default manager as it has scan_for_not_found=True</span>
    <span class="c1"># by default, which re-runs scan if no entrypoints are found</span>
    <span class="n">ENTRYPOINT_MANAGER</span> <span class="o">=</span> <span class="n">PluginManager</span><span class="p">(</span><span class="n">scan_for_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pkg_resources</span> <span class="k">as</span> <span class="nn">ENTRYPOINT_MANAGER</span>

<span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="kn">import</span> <span class="n">MissingEntryPointError</span><span class="p">,</span> <span class="n">MultipleEntryPointError</span><span class="p">,</span> <span class="n">LoadingEntryPointError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;load_entry_point&#39;</span><span class="p">,</span> <span class="s1">&#39;load_entry_point_from_string&#39;</span><span class="p">)</span>

<span class="n">ENTRY_POINT_GROUP_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;aiida.&#39;</span>
<span class="n">ENTRY_POINT_STRING_SEPARATOR</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>


<span class="k">class</span> <span class="nc">EntryPointFormat</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum to distinguish between the various possible entry point string formats. An entry point string</span>
<span class="sd">    is fully qualified by its group and name concatenated by the entry point string separator character.</span>
<span class="sd">    The group in AiiDA has the prefix `aiida.` and the separator character is the colon `:`.</span>

<span class="sd">    Under these definitions a potentially valid entry point string may have the following formats:</span>

<span class="sd">        * FULL:    prefixed group plus entry point name     aiida.transports:ssh</span>
<span class="sd">        * PARTIAL: unprefixed group plus entry point name   transports:ssh</span>
<span class="sd">        * MINIMAL: no group but only entry point name:      ssh</span>

<span class="sd">    Note that the MINIMAL format can potentially lead to ambiguity if the name appears in multiple</span>
<span class="sd">    entry point groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">INVALID</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">FULL</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">PARTIAL</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">MINIMAL</span> <span class="o">=</span> <span class="mi">3</span>


<span class="n">ENTRY_POINT_GROUP_TO_MODULE_PATH_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;aiida.calculations&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.nodes.process.calculation.calcjob&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.cmdline.data&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.cmdline.data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.data&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.nodes.data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.groups&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.groups&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.node&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.nodes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.parsers&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.parsers.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.schedulers&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.schedulers.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.tools.dbexporters&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.tools.dbexporters&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.tools.dbimporters&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.tools.dbimporters.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.transports&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.transports.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.workflows&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.workflows&#39;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">validate_registered_entry_points</span><span class="p">():</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;Validate all registered entry points by loading them with the corresponding factory.</span>

<span class="sd">    :raises EntryPointError: if any of the registered entry points cannot be loaded. This can happen if:</span>
<span class="sd">        * The entry point cannot uniquely be resolved</span>
<span class="sd">        * The resource registered at the entry point cannot be imported</span>
<span class="sd">        * The resource&#39;s type is incompatible with the entry point group that it is defined in.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">factories</span>

    <span class="n">factory_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;aiida.calculations&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">CalculationFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.data&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">DataFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.groups&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">GroupFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.parsers&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">ParserFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.schedulers&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">SchedulerFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.transports&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">TransportFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.tools.dbimporters&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">DbImporterFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.tools.data.orbital&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">OrbitalFactory</span><span class="p">,</span>
        <span class="s1">&#39;aiida.workflows&#39;</span><span class="p">:</span> <span class="n">factories</span><span class="o">.</span><span class="n">WorkflowFactory</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">entry_point_group</span><span class="p">,</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factory_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">entry_points</span> <span class="o">=</span> <span class="n">get_entry_points</span><span class="p">(</span><span class="n">entry_point_group</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">entry_point</span> <span class="ow">in</span> <span class="n">entry_points</span><span class="p">:</span>
            <span class="n">factory</span><span class="p">(</span><span class="n">entry_point</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">format_entry_point_string</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">FULL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format an entry point string for a given entry point group and name, based on the specified format</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param name: the name of the entry point</span>
<span class="sd">    :param fmt: the desired output format</span>
<span class="sd">    :raises TypeError: if fmt is not instance of EntryPointFormat</span>
<span class="sd">    :raises ValueError: if fmt value is invalid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">EntryPointFormat</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;fmt should be an instance of EntryPointFormat&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">FULL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">PARTIAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ENTRY_POINT_GROUP_PREFIX</span><span class="p">):],</span> <span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">MINIMAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid EntryPointFormat&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the entry point string and attempt to parse the entry point group and name</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :return: the entry point group and name if the string is valid</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the entry_point_string should be a string&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">entry_point_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid entry_point_string format&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">group</span><span class="p">,</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">get_entry_point_string_format</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the format of an entry point string. Note that it does not validate the actual entry point</span>
<span class="sd">    string and it may not correspond to any actual entry point. This will only assess the string format</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :returns: the entry point type</span>
<span class="sd">    :rtype: EntryPointFormat</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">entry_point_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">MINIMAL</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ENTRY_POINT_GROUP_PREFIX</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">FULL</span>
        <span class="k">return</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">PARTIAL</span>


<span class="k">def</span> <span class="nf">get_entry_point_from_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an entry point for the given entry point string</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :return: the entry point if it exists else None</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">parse_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="load_entry_point_from_string"><a class="viewcode-back" href="../../../apidoc/aiida.plugins.html#aiida.plugins.load_entry_point_from_string">[docs]</a><span class="k">def</span> <span class="nf">load_entry_point_from_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the class registered for a given entry point string that determines group and name</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :return: class registered at the given entry point</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    :raises aiida.common.LoadingEntryPointError: entry point could not be loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">parse_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">load_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_entry_point"><a class="viewcode-back" href="../../../apidoc/aiida.plugins.html#aiida.plugins.load_entry_point">[docs]</a><span class="k">def</span> <span class="nf">load_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the class registered under the entry point for a given name and group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param name: the name of the entry point</span>
<span class="sd">    :return: class registered at the given entry point</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    :raises aiida.common.LoadingEntryPointError: entry point could not be loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entry_point</span> <span class="o">=</span> <span class="n">get_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">loaded_entry_point</span> <span class="o">=</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LoadingEntryPointError</span><span class="p">(</span><span class="s2">&quot;Failed to load entry point &#39;</span><span class="si">{}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">loaded_entry_point</span></div>


<span class="k">def</span> <span class="nf">get_entry_point_groups</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of all the recognized entry point groups</span>

<span class="sd">    :return: a list of valid entry point groups</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ENTRY_POINT_GROUP_TO_MODULE_PATH_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">get_entry_point_names</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of all the entry point names within a specific group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param sort: if True, the returned list will be sorted alphabetically</span>
<span class="sd">    :return: a list of entry point names</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entry_point_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ep</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">get_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">entry_point_names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">entry_point_names</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of all the entry points within a specific group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :return: a list of entry points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">iter_entry_points</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">))</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an entry point with a given name within a specific group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param name: the name of the entry point</span>
<span class="sd">    :return: the entry point if it exists else None</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entry_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">ep</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">get_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">if</span> <span class="n">ep</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_points</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MissingEntryPointError</span><span class="p">(</span>
            <span class="s2">&quot;Entry point &#39;</span><span class="si">{}</span><span class="s2">&#39; not found in group &#39;</span><span class="si">{}</span><span class="s2">&#39;. Try running `reentry scan` to update &quot;</span>
            <span class="s1">&#39;the entry point cache.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entry_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MultipleEntryPointError</span><span class="p">(</span>
            <span class="s2">&quot;Multiple entry points &#39;</span><span class="si">{}</span><span class="s2">&#39; found in group &#39;</span><span class="si">{}</span><span class="s2">&#39;.Try running `reentry scan` to &quot;</span>
            <span class="s1">&#39;repopulate the entry point cache.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">entry_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">get_entry_point_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the module and name of a class, attempt to obtain the corresponding entry point if it exists</span>

<span class="sd">    :param class_module: module of the class</span>
<span class="sd">    :param class_name: name of the class</span>
<span class="sd">    :return: a tuple of the corresponding group and entry point or None if not found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">get_entry_map</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">entry_point</span> <span class="ow">in</span> <span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">iter_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">module_name</span> <span class="o">!=</span> <span class="n">class_module</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">entry_point_class_name</span> <span class="ow">in</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entry_point_class_name</span> <span class="o">==</span> <span class="n">class_name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">group</span><span class="p">,</span> <span class="n">entry_point</span>

    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">get_entry_point_string_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the module and name of a class, attempt to obtain the corresponding entry point if it</span>
<span class="sd">    exists and return the entry point string which will be the entry point group and entry point</span>
<span class="sd">    name concatenated by the entry point string separator</span>

<span class="sd">        entry_point_string = &#39;{group:}:{entry_point_name:}&#39;</span>

<span class="sd">    This ensures that given the entry point string, one can load the corresponding class</span>
<span class="sd">    by splitting on the separator, which will give the group and entry point, which should</span>
<span class="sd">    the corresponding factory to uniquely determine and load the class</span>


<span class="sd">    :param class_module: module of the class</span>
<span class="sd">    :param class_name: name of the class</span>
<span class="sd">    :return: the corresponding entry point string or None</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span><span class="p">,</span> <span class="n">entry_point</span> <span class="o">=</span> <span class="n">get_entry_point_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">group</span> <span class="ow">and</span> <span class="n">entry_point</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">group</span><span class="p">,</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">is_valid_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify whether the given entry point string is a valid one. For the string to be valid means that it is composed</span>
<span class="sd">    of two strings, the entry point group and name, concatenated by the entry point string separator. If that is the</span>
<span class="sd">    case, the group name will be verified to see if it is known. If the group can be retrieved and it is known, the</span>
<span class="sd">    string is considered to be valid. It is invalid otherwise</span>

<span class="sd">    :param entry_point_string: the entry point string, generated by get_entry_point_string_from_class</span>
<span class="sd">    :return: True if the string is considered valid, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">entry_point_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="c1"># Either `entry_point_string` is not a string or it does not contain the separator</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">ENTRY_POINT_GROUP_TO_MODULE_PATH_MAP</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_registered_entry_point</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verify whether the class with the given module and class name is a registered entry point.</span>

<span class="sd">    .. note:: this function only checks whether the class has a registered entry point. It does explicitly not verify</span>
<span class="sd">        if the corresponding class is also importable. Use `load_entry_point` for this purpose instead.</span>

<span class="sd">    :param class_module: the module of the class</span>
<span class="sd">    :param class_name: the name of the class</span>
<span class="sd">    :param groups: optionally consider only these entry point groups to look for the class</span>
<span class="sd">    :return: boolean, True if the class is a registered entry point, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ENTRY_POINT_GROUP_TO_MODULE_PATH_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">entry_point</span> <span class="ow">in</span> <span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">iter_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">class_module</span> <span class="o">==</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">module_name</span> <span class="ow">and</span> <span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>