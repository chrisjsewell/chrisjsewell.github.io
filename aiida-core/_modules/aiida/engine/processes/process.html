

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.engine.processes.process &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/togglebutton.js"></script>
        <script src="../../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.engine.processes.process</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.engine.processes.process</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;The AiiDA process class&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<span class="kn">from</span> <span class="nn">pika.exceptions</span> <span class="kn">import</span> <span class="n">ConnectionClosed</span>

<span class="kn">import</span> <span class="nn">plumpy</span>
<span class="kn">from</span> <span class="nn">plumpy</span> <span class="kn">import</span> <span class="n">ProcessState</span>
<span class="kn">from</span> <span class="nn">kiwipy.communications</span> <span class="kn">import</span> <span class="n">UnroutableError</span>

<span class="kn">from</span> <span class="nn">aiida</span> <span class="kn">import</span> <span class="n">orm</span>
<span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">aiida.common.extendeddicts</span> <span class="kn">import</span> <span class="n">AttributeDict</span>
<span class="kn">from</span> <span class="nn">aiida.common.lang</span> <span class="kn">import</span> <span class="n">classproperty</span><span class="p">,</span> <span class="n">override</span>
<span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="kn">import</span> <span class="n">LinkType</span>
<span class="kn">from</span> <span class="nn">aiida.common.log</span> <span class="kn">import</span> <span class="n">LOG_LEVEL_REPORT</span>

<span class="kn">from</span> <span class="nn">.exit_code</span> <span class="kn">import</span> <span class="n">ExitCode</span>
<span class="kn">from</span> <span class="nn">.builder</span> <span class="kn">import</span> <span class="n">ProcessBuilder</span>
<span class="kn">from</span> <span class="nn">.ports</span> <span class="kn">import</span> <span class="n">InputPort</span><span class="p">,</span> <span class="n">OutputPort</span><span class="p">,</span> <span class="n">PortNamespace</span><span class="p">,</span> <span class="n">PORT_NAMESPACE_SEPARATOR</span>
<span class="kn">from</span> <span class="nn">.process_spec</span> <span class="kn">import</span> <span class="n">ProcessSpec</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Process&#39;</span><span class="p">,</span> <span class="s1">&#39;ProcessState&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Process"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process">[docs]</a><span class="nd">@plumpy</span><span class="o">.</span><span class="n">auto_persist</span><span class="p">(</span><span class="s1">&#39;_parent_pid&#39;</span><span class="p">,</span> <span class="s1">&#39;_enable_persistence&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Process</span><span class="p">(</span><span class="n">plumpy</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents an AiiDA process which can be executed and will</span>
<span class="sd">    have full provenance saved in the database.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-public-methods</span>

    <span class="n">_node_class</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">ProcessNode</span>
    <span class="n">_spec_class</span> <span class="o">=</span> <span class="n">ProcessSpec</span>

    <span class="n">SINGLE_OUTPUT_LINKNAME</span> <span class="o">=</span> <span class="s1">&#39;result&#39;</span>

<div class="viewcode-block" id="Process.SaveKeys"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.SaveKeys">[docs]</a>    <span class="k">class</span> <span class="nc">SaveKeys</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keys used to identify things in the saved instance state bundle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-few-public-methods</span>
        <span class="n">CALC_ID</span> <span class="o">=</span> <span class="s1">&#39;calc_id&#39;</span></div>

<div class="viewcode-block" id="Process.define"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.define">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="c1"># yapf: disable</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input_namespace</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">metadata_key</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">non_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.store_provenance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">metadata_key</span><span class="p">),</span> <span class="n">valid_type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;If set to `False` provenance will not be stored in the database.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.description&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">metadata_key</span><span class="p">),</span> <span class="n">valid_type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Description to set on the process node.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.label&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">metadata_key</span><span class="p">),</span> <span class="n">valid_type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Label to set on the process node.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.call_link_label&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">metadata_key</span><span class="p">),</span> <span class="n">valid_type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;CALL&#39;</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The label to use for the `CALL` link if the process is called by another process.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">exit_code</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ERROR_UNSPECIFIED&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;The process has failed with an unspecified error.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">exit_code</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ERROR_LEGACY_FAILURE&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;The process failed with legacy failure mode.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">exit_code</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;ERROR_INVALID_OUTPUT&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;The process returned an invalid output.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">exit_code</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;ERROR_MISSING_OUTPUT&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;The process did not register a required output.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.get_builder"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.get_builder">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_builder</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ProcessBuilder</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.get_or_create_db_record"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.get_or_create_db_record">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_or_create_db_record</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a process node that represents what happened in this process.</span>

<span class="sd">        :return: A process node</span>
<span class="sd">        :rtype: :class:`aiida.orm.ProcessNode`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_node_class</span><span class="p">()</span></div>

<div class="viewcode-block" id="Process.__init__"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">runner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_pid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enable_persistence</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Process constructor.</span>

<span class="sd">        :param inputs: process inputs</span>
<span class="sd">        :type inputs: dict</span>

<span class="sd">        :param logger: aiida logger</span>
<span class="sd">        :type logger: :class:`logging.Logger`</span>

<span class="sd">        :param runner: process runner</span>
<span class="sd">        :type: :class:`aiida.engine.runners.Runner`</span>

<span class="sd">        :param parent_pid: id of parent process</span>
<span class="sd">        :type parent_pid: int</span>

<span class="sd">        :param enable_persistence: whether to persist this process</span>
<span class="sd">        :type enable_persistence: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.manage</span> <span class="kn">import</span> <span class="n">manager</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span> <span class="o">=</span> <span class="n">runner</span> <span class="k">if</span> <span class="n">runner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">manager</span><span class="o">.</span><span class="n">get_manager</span><span class="p">()</span><span class="o">.</span><span class="n">get_runner</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">inputs</span><span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="o">.</span><span class="n">loop</span><span class="p">,</span>
            <span class="n">communicator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">communicator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_pid</span> <span class="o">=</span> <span class="n">parent_pid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_persistence</span> <span class="o">=</span> <span class="n">enable_persistence</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_persistence</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">persister</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Disabling persistence, runner does not have a persister&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_persistence</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Process.init"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.init">[docs]</a>    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_logger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.get_exit_statuses"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.get_exit_statuses">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_exit_statuses</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">exit_code_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the exit status (integers) for the given exit code labels.</span>

<span class="sd">        :param exit_code_labels: a list of strings that reference exit code labels of this process class</span>
<span class="sd">        :return: list of exit status integers that correspond to the given exit code labels</span>
<span class="sd">        :raises AttributeError: if at least one of the labels does not correspond to an existing exit code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exit_codes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">exit_codes</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">exit_codes</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">status</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">exit_code_labels</span><span class="p">]</span></div>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">exit_codes</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>  <span class="c1"># pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;Return the namespace of exit codes defined for this WorkChain through its ProcessSpec.</span>

<span class="sd">        The namespace supports getitem and getattr operations with an ExitCode label to retrieve a specific code.</span>
<span class="sd">        Additionally, the namespace can also be called with either the exit code integer status to retrieve it.</span>

<span class="sd">        :returns: ExitCodesNamespace of ExitCode named tuples</span>
<span class="sd">        :rtype: :class:`aiida.engine.ExitCodesNamespace`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">exit_codes</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">spec_metadata</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>  <span class="c1"># pylint: disable=no-self-argument</span>
        <span class="sd">&quot;&quot;&quot;Return the metadata port namespace of the process specification of this process.</span>

<span class="sd">        :return: metadata dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the ProcessNode used by this process to represent itself in the database.</span>

<span class="sd">        :return: instance of sub class of ProcessNode</span>
<span class="sd">        :rtype: :class:`aiida.orm.ProcessNode`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the UUID of the process which corresponds to the UUID of its associated `ProcessNode`.</span>

<span class="sd">        :return: the UUID associated to this process instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the metadata that were specified when this process instance was launched.</span>

<span class="sd">        :return: metadata dictionary</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AttributeDict</span><span class="p">()</span>

<div class="viewcode-block" id="Process._save_checkpoint"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._save_checkpoint">[docs]</a>    <span class="k">def</span> <span class="nf">_save_checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the current state in a chechpoint if persistence is enabled and the process state is not terminal</span>

<span class="sd">        If the persistence call excepts with a PersistenceError, it will be caught and a warning will be logged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_persistence</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">persister</span><span class="o">.</span><span class="n">save_checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">plumpy</span><span class="o">.</span><span class="n">PersistenceError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Exception trying to save checkpoint, this means you will &#39;</span>
                                      <span class="s1">&#39;not be able to restart in case of a crash until the next successful checkpoint.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.save_instance_state"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.save_instance_state">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">save_instance_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_state</span><span class="p">,</span> <span class="n">save_context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save instance state.</span>

<span class="sd">        See documentation of :meth:`!plumpy.processes.Process.save_instance_state`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save_instance_state</span><span class="p">(</span><span class="n">out_state</span><span class="p">,</span> <span class="n">save_context</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">store_provenance</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_stored</span>

        <span class="n">out_state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SaveKeys</span><span class="o">.</span><span class="n">CALC_ID</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span></div>

<div class="viewcode-block" id="Process.get_provenance_inputs_iterator"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.get_provenance_inputs_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">get_provenance_inputs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get provenance input iterator.</span>

<span class="sd">        :rtype: filter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="ow">not</span> <span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span></div>

<div class="viewcode-block" id="Process.load_instance_state"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.load_instance_state">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">load_instance_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">saved_state</span><span class="p">,</span> <span class="n">load_context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load instance state.</span>

<span class="sd">        :param saved_state: saved instance state</span>

<span class="sd">        :param load_context:</span>
<span class="sd">        :type load_context: :class:`!plumpy.persistence.LoadSaveContext`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.manage</span> <span class="kn">import</span> <span class="n">manager</span>

        <span class="k">if</span> <span class="s1">&#39;runner&#39;</span> <span class="ow">in</span> <span class="n">load_context</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span> <span class="o">=</span> <span class="n">load_context</span><span class="o">.</span><span class="n">runner</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">get_manager</span><span class="p">()</span><span class="o">.</span><span class="n">get_runner</span><span class="p">()</span>

        <span class="n">load_context</span> <span class="o">=</span> <span class="n">load_context</span><span class="o">.</span><span class="n">copyextend</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="o">.</span><span class="n">loop</span><span class="p">,</span> <span class="n">communicator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_runner</span><span class="o">.</span><span class="n">communicator</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_instance_state</span><span class="p">(</span><span class="n">saved_state</span><span class="p">,</span> <span class="n">load_context</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SaveKeys</span><span class="o">.</span><span class="n">CALC_ID</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">saved_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">load_node</span><span class="p">(</span><span class="n">saved_state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SaveKeys</span><span class="o">.</span><span class="n">CALC_ID</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_and_setup_db_record</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Loaded process&lt;</span><span class="si">{}</span><span class="s1">&gt; from saved state&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span></div>

<div class="viewcode-block" id="Process.kill"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.kill">[docs]</a>    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kill the process and all the children calculations it called</span>

<span class="sd">        :param msg: message</span>
<span class="sd">        :type msg: str</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Request to kill Process&lt;</span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span>

        <span class="n">had_been_terminated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_terminated</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Only kill children if we could be killed ourselves</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">had_been_terminated</span><span class="p">:</span>
            <span class="n">killing</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">called</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">controller</span><span class="o">.</span><span class="n">kill_process</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="s1">&#39;Killed by parent&lt;</span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">plumpy</span><span class="o">.</span><span class="n">Future</span><span class="p">):</span>
                        <span class="n">killing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ConnectionClosed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;no connection available to kill child&lt;</span><span class="si">%s</span><span class="s1">&gt;&#39;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">UnroutableError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;kill signal was unable to reach child&lt;</span><span class="si">%s</span><span class="s1">&gt;&#39;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">plumpy</span><span class="o">.</span><span class="n">Future</span><span class="p">):</span>
                <span class="c1"># We ourselves are waiting to be killed so add it to the list</span>
                <span class="n">killing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">killing</span><span class="p">:</span>
                <span class="c1"># We are waiting for things to be killed, so return the &#39;gathered&#39; future</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">plumpy</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">killing</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Process.out"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.out">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_port</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attach output to output port.</span>

<span class="sd">        The name of the port will be used as the link label.</span>

<span class="sd">        :param output_port: name of output port</span>
<span class="sd">        :type output_port: str</span>

<span class="sd">        :param value: value to put inside output port</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># In this case assume that output_port is the actual value and there is just one return value</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">output_port</span>
            <span class="n">output_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SINGLE_OUTPUT_LINKNAME</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">output_port</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.out_many"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.out_many">[docs]</a>    <span class="k">def</span> <span class="nf">out_many</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attach outputs to multiple output ports.</span>

<span class="sd">        Keys of the dictionary will be used as output port names, values as outputs.</span>

<span class="sd">        :param out_dict: output dictionary</span>
<span class="sd">        :type out_dict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">out_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.on_create"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_create">[docs]</a>    <span class="k">def</span> <span class="nf">on_create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when a Process is created.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_create</span><span class="p">()</span>
        <span class="c1"># If parent PID hasn&#39;t been supplied try to get it from the stack</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_pid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Process</span><span class="o">.</span><span class="n">current</span><span class="p">():</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">Process</span><span class="o">.</span><span class="n">current</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">Process</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">pid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_and_setup_db_record</span><span class="p">()</span></div>

<div class="viewcode-block" id="Process.on_entering"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_entering">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_entering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_entering</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></div>
        <span class="c1"># Update the node attributes every time we enter a new state</span>

<div class="viewcode-block" id="Process.on_entered"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_entered">[docs]</a>    <span class="k">def</span> <span class="nf">on_entered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_state</span><span class="p">):</span>
        <span class="c1"># pylint: disable=cyclic-import</span>
        <span class="kn">from</span> <span class="nn">aiida.engine.utils</span> <span class="kn">import</span> <span class="n">set_process_state_change_timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_node_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_checkpoint</span><span class="p">()</span>
        <span class="c1"># Update the latest process state change timestamp</span>
        <span class="n">set_process_state_change_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_entered</span><span class="p">(</span><span class="n">from_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.on_terminated"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_terminated">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_terminated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when a Process enters a terminal state.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_terminated</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_persistence</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">persister</span><span class="o">.</span><span class="n">delete_checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Failed to delete checkpoint&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">seal</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="Process.on_except"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_except">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_except</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log the exception by calling the report method with formatted stack trace from exception info object</span>
<span class="sd">        and store the exception string as a node attribute</span>

<span class="sd">        :param exc_info: the sys.exc_info() object (type, value, traceback)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_except</span><span class="p">(</span><span class="n">exc_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="n">exc_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exc_info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="o">*</span><span class="n">exc_info</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Process.on_finish"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_finish">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">successful</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the finish status on the process node.</span>

<span class="sd">        :param result: result of the process</span>
<span class="sd">        :type result: int or :class:`aiida.engine.ExitCode`</span>

<span class="sd">        :param successful: whether execution was successful</span>
<span class="sd">        :type successful: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_finish</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">successful</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">successful</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_codes</span><span class="o">.</span><span class="n">ERROR_MISSING_OUTPUT</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ExitCode</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_exit_status</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">ExitCode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_exit_status</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_exit_message</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the result should be an integer, ExitCode or None, got </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span></div>

<div class="viewcode-block" id="Process.on_paused"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_paused">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_paused</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Process was paused so set the paused attribute on the process node</span>

<span class="sd">        :param msg: message</span>
<span class="sd">        :type msg: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_paused</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_checkpoint</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span></div>

<div class="viewcode-block" id="Process.on_playing"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_playing">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_playing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Process was unpaused so remove the paused attribute on the process node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_playing</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">unpause</span><span class="p">()</span></div>

<div class="viewcode-block" id="Process.on_output_emitting"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.on_output_emitting">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">on_output_emitting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_port</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The process has emitted a value on the given output port.</span>

<span class="sd">        :param output_port: The output port name the value was emitted on</span>
<span class="sd">        :type output_port: str</span>

<span class="sd">        :param value: The value emitted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">on_output_emitting</span><span class="p">(</span><span class="n">output_port</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Note that `PortNamespaces` should be able to receive non `Data` types such as a normal dictionary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_port</span><span class="p">,</span> <span class="n">OutputPort</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">Data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Processes can only return `orm.Data` instances as output, got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>

<div class="viewcode-block" id="Process.set_status"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.set_status">[docs]</a>    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The status of the Process is about to be changed, so we reflect this is in node&#39;s attribute proxy.</span>

<span class="sd">        :param status: the status message</span>
<span class="sd">        :type status: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_process_status</span><span class="p">(</span><span class="n">status</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.submit"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.submit">[docs]</a>    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submit process for execution.</span>

<span class="sd">        :param process: process</span>
<span class="sd">        :type process: :class:`aiida.engine.Process`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get process runner.</span>

<span class="sd">        :rtype: :class:`aiida.engine.runners.Runner`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runner</span>

<div class="viewcode-block" id="Process.get_parent_calc"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.get_parent_calc">[docs]</a>    <span class="k">def</span> <span class="nf">get_parent_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the parent process node</span>

<span class="sd">        :return: the parent process node if there is one</span>
<span class="sd">        :rtype: :class:`aiida.orm.ProcessNode`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Can&#39;t get it if we don&#39;t know our parent</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_pid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">orm</span><span class="o">.</span><span class="n">load_node</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_pid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.build_process_type"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.build_process_type">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_process_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The process type.</span>

<span class="sd">        :return: string of the process type</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Note: This could be made into a property &#39;process_type&#39; but in order to have it be a property of the class</span>
<span class="sd">        it would need to be defined in the metaclass, see https://bugs.python.org/issue20659</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.plugins.entry_point</span> <span class="kn">import</span> <span class="n">get_entry_point_string_from_class</span>

        <span class="n">class_module</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># If the process is a registered plugin the corresponding entry point will be used as process type</span>
        <span class="n">process_type</span> <span class="o">=</span> <span class="n">get_entry_point_string_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">)</span>

        <span class="c1"># If no entry point was found, default to fully qualified path name</span>
        <span class="k">if</span> <span class="n">process_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">process_type</span></div>

<div class="viewcode-block" id="Process.report"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.report">[docs]</a>    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log a message to the logger, which should get saved to the database through the attached DbLogHandler.</span>

<span class="sd">        The pk, class name and function name of the caller are prepended to the given message</span>

<span class="sd">        :param msg: message to log</span>
<span class="sd">        :type msg: str</span>

<span class="sd">        :param args: args to pass to the log call</span>
<span class="sd">        :type args: list</span>

<span class="sd">        :param kwargs: kwargs to pass to the log call</span>
<span class="sd">        :type kwargs: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">|</span><span class="si">{}</span><span class="s1">|</span><span class="si">{}</span><span class="s1">]: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">LOG_LEVEL_REPORT</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process._create_and_setup_db_record"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._create_and_setup_db_record">[docs]</a>    <span class="k">def</span> <span class="nf">_create_and_setup_db_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and setup the database record for this process</span>

<span class="sd">        :return: the uuid of the process</span>
<span class="sd">        :rtype: :class:`!uuid.UUID`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_or_create_db_record</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_db_record</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">store_provenance</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">store_all</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_finished_ok</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">ProcessState</span><span class="o">.</span><span class="n">FINISHED</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">link_label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_</span><span class="si">{pk}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">)):</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">link_label</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
                    <span class="c1"># This is needed for CalcJob. In that case, the outputs are</span>
                    <span class="c1"># returned regardless of whether they end in &#39;_pk&#39;</span>
                    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">link_label</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">:</span>
                <span class="c1"># The calculation was already stored</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Cannot persist the process if were not storing provenance because that would require a stored node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_persistence</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span>

        <span class="k">return</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.encode_input_args"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.encode_input_args">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">encode_input_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode input arguments such that they may be saved in a Bundle</span>

<span class="sd">        :param inputs: A mapping of the inputs as passed to the process</span>
<span class="sd">        :return: The encoded (serialized) inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.utils</span> <span class="kn">import</span> <span class="n">serialize</span>
        <span class="k">return</span> <span class="n">serialize</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.decode_input_args"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.decode_input_args">[docs]</a>    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">decode_input_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoded</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decode saved input arguments as they came from the saved instance state Bundle</span>

<span class="sd">        :param encoded: encoded (serialized) inputs</span>
<span class="sd">        :return: The decoded input args</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.utils</span> <span class="kn">import</span> <span class="n">serialize</span>
        <span class="k">return</span> <span class="n">serialize</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.update_node_state"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.update_node_state">[docs]</a>    <span class="k">def</span> <span class="nf">update_node_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_outputs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_process_state</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">LABEL</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.update_outputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.update_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">update_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attach new outputs to the node since the last call.</span>

<span class="sd">        Does nothing, if self.metadata.store_provenance is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">store_provenance</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">outputs_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flat_outputs</span><span class="p">()</span>
        <span class="n">outputs_stored</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="p">(</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">))</span><span class="o">.</span><span class="n">all_link_labels</span><span class="p">()</span>
        <span class="n">outputs_new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outputs_flat</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">outputs_stored</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs_flat</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">link_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outputs_new</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">CalculationNode</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">WorkflowNode</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>

            <span class="n">output</span><span class="o">.</span><span class="n">store</span><span class="p">()</span></div>

<div class="viewcode-block" id="Process._setup_db_record"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._setup_db_record">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_db_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the database record for this process and the links with respect to its inputs</span>

<span class="sd">        This function will set various attributes on the node that serve as a proxy for attributes of the Process.</span>
<span class="sd">        This is essential as otherwise this information could only be introspected through the Process itself, which</span>
<span class="sd">        is only available to the interpreter that has it in memory. To make this data introspectable from any</span>
<span class="sd">        interpreter, for example for the command line interface, certain Process attributes are proxied through the</span>
<span class="sd">        calculation node.</span>

<span class="sd">        In addition, the parent calculation will be setup with a CALL link if applicable and all inputs will be</span>
<span class="sd">        linked up as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_sealed</span><span class="p">,</span> <span class="s1">&#39;process node cannot be sealed when setting up the database record&#39;</span>

        <span class="c1"># Store important process attributes in the node proxy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_process_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_process_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_process_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">build_process_type</span><span class="p">())</span>

        <span class="n">parent_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_calc</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">parent_calc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">store_provenance</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent_calc</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">CalculationNode</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InvalidOperation</span><span class="p">(</span><span class="s1">&#39;calling processes from a calculation type process is forbidden.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">CalculationNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="n">parent_calc</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_CALC</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">call_link_label</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">WorkflowNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="n">parent_calc</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_WORK</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">call_link_label</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_metadata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_inputs</span><span class="p">()</span></div>

<div class="viewcode-block" id="Process._setup_metadata"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._setup_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the metadata on the ProcessNode.&quot;&quot;&quot;</span>
        <span class="n">version_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">plugin_version_provider</span><span class="o">.</span><span class="n">get_version_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_attribute_many</span><span class="p">(</span><span class="n">version_info</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;store_provenance&#39;</span><span class="p">,</span> <span class="s1">&#39;dry_run&#39;</span><span class="p">,</span> <span class="s1">&#39;call_link_label&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">metadata</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;description&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">metadata</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;computer&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">computer</span> <span class="o">=</span> <span class="n">metadata</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;options&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">option_name</span><span class="p">,</span> <span class="n">option_value</span> <span class="ow">in</span> <span class="n">metadata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">option_name</span><span class="p">,</span> <span class="n">option_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;unsupported metadata key: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="Process._setup_inputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._setup_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the links between the input nodes and the ProcessNode that represents this process.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flat_inputs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Certain processes allow to specify ports with `None` as acceptable values</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Special exception: set computer if node is a remote Code and our node does not yet have a computer set</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">Code</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_local</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">computer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">computer</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_remote_computer</span><span class="p">()</span>

            <span class="c1"># Need this special case for tests that use ProcessNodes as classes</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">CalculationNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">WorkflowNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_WORK</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process._flat_inputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._flat_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">_flat_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a flattened version of the parsed inputs dictionary.</span>

<span class="sd">        The eventual keys will be a concatenation of the nested keys. Note that the `metadata` dictionary, if present,</span>
<span class="sd">        is not passed, as those are dealt with separately in `_setup_metadata`.</span>

<span class="sd">        :return: flat dictionary of parsed inputs</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">metadata_key</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatten_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span></div>

<div class="viewcode-block" id="Process._flat_outputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._flat_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">_flat_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a flattened version of the registered outputs dictionary.</span>

<span class="sd">        The eventual keys will be a concatenation of the nested keys.</span>

<span class="sd">        :return: flat dictionary of parsed outputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatten_outputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span></div>

<div class="viewcode-block" id="Process._flatten_inputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._flatten_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">_flatten_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">port_value</span><span class="p">,</span> <span class="n">parent_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">PORT_NAMESPACE_SEPARATOR</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will recursively flatten the inputs dictionary, omitting inputs for ports that</span>
<span class="sd">        are marked as being non database storable</span>

<span class="sd">        :param port: port against which to map the port value, can be InputPort or PortNamespace</span>
<span class="sd">        :type port: :class:`plumpy.ports.Port`</span>

<span class="sd">        :param port_value: value for the current port, can be a Mapping</span>

<span class="sd">        :param parent_name: the parent key with which to prefix the keys</span>
<span class="sd">        :type parent_name: str</span>

<span class="sd">        :param separator: character to use for the concatenation of keys</span>
<span class="sd">        :type separator: str</span>

<span class="sd">        :return: flat list of inputs</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port_value</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">InputPort</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">port</span><span class="o">.</span><span class="n">non_db</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">parent_name</span><span class="p">,</span> <span class="n">port_value</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port_value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PortNamespace</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">port_value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">prefixed_key</span> <span class="o">=</span> <span class="n">parent_name</span> <span class="o">+</span> <span class="n">separator</span> <span class="o">+</span> <span class="n">name</span> <span class="k">if</span> <span class="n">parent_name</span> <span class="k">else</span> <span class="n">name</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nested_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                    <span class="n">nested_port</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">sub_items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_inputs</span><span class="p">(</span>
                    <span class="n">port</span><span class="o">=</span><span class="n">nested_port</span><span class="p">,</span> <span class="n">port_value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">parent_name</span><span class="o">=</span><span class="n">prefixed_key</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span>
                <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_items</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">items</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">InputPort</span><span class="p">)</span> <span class="ow">and</span> <span class="n">port</span><span class="o">.</span><span class="n">non_db</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Process._flatten_outputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._flatten_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">_flatten_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">port_value</span><span class="p">,</span> <span class="n">parent_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">PORT_NAMESPACE_SEPARATOR</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will recursively flatten the outputs dictionary.</span>

<span class="sd">        :param port: port against which to map the port value, can be OutputPort or PortNamespace</span>
<span class="sd">        :type port: :class:`plumpy.ports.Port`</span>

<span class="sd">        :param port_value: value for the current port, can be a Mapping</span>
<span class="sd">        :type parent_name: str</span>

<span class="sd">        :param parent_name: the parent key with which to prefix the keys</span>
<span class="sd">        :type parent_name: str</span>

<span class="sd">        :param separator: character to use for the concatenation of keys</span>
<span class="sd">        :type separator: str</span>

<span class="sd">        :return: flat list of outputs</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port_value</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">OutputPort</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">parent_name</span><span class="p">,</span> <span class="n">port_value</span><span class="p">)]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port_value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PortNamespace</span><span class="p">)):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">port_value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">prefixed_key</span> <span class="o">=</span> <span class="n">parent_name</span> <span class="o">+</span> <span class="n">separator</span> <span class="o">+</span> <span class="n">name</span> <span class="k">if</span> <span class="n">parent_name</span> <span class="k">else</span> <span class="n">name</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nested_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                    <span class="n">nested_port</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">sub_items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_outputs</span><span class="p">(</span>
                    <span class="n">port</span><span class="o">=</span><span class="n">nested_port</span><span class="p">,</span> <span class="n">port_value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">parent_name</span><span class="o">=</span><span class="n">prefixed_key</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span>
                <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_items</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">items</span>

        <span class="k">assert</span> <span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="n">port</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Process.exposed_inputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.exposed_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">exposed_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">agglomerate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gather a dictionary of the inputs that were exposed for a given Process class under an optional namespace.</span>

<span class="sd">        :param process_class: Process class whose inputs to try and retrieve</span>
<span class="sd">        :type process_class: :class:`aiida.engine.Process`</span>

<span class="sd">        :param namespace: PortNamespace in which to look for the inputs</span>
<span class="sd">        :type namespace: str</span>

<span class="sd">        :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also be</span>
<span class="sd">            searched for inputs. Inputs in lower-lying namespaces take precedence.</span>
<span class="sd">        :type agglomerate: bool</span>

<span class="sd">        :returns: exposed inputs</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exposed_inputs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">namespace_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace_list</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span> <span class="n">agglomerate</span><span class="o">=</span><span class="n">agglomerate</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sub_namespace</span> <span class="ow">in</span> <span class="n">namespace_list</span><span class="p">:</span>

            <span class="c1"># The sub_namespace None indicates the base level sub_namespace</span>
            <span class="k">if</span> <span class="n">sub_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
                <span class="n">port_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">inputs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">sub_namespace</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
                    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">part</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">port_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">get_port</span><span class="p">(</span><span class="n">sub_namespace</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;this process does not contain the &quot;</span><span class="si">{}</span><span class="s1">&quot; input namespace&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sub_namespace</span><span class="p">))</span>

            <span class="c1"># Get the list of ports that were exposed for the given Process class in the current sub_namespace</span>
            <span class="n">exposed_inputs_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">_exposed_inputs</span><span class="p">[</span><span class="n">sub_namespace</span><span class="p">][</span><span class="n">process_class</span><span class="p">]</span>  <span class="c1"># pylint: disable=protected-access</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">port_namespace</span><span class="o">.</span><span class="n">ports</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">exposed_inputs_list</span><span class="p">:</span>
                    <span class="n">exposed_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">AttributeDict</span><span class="p">(</span><span class="n">exposed_inputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process.exposed_outputs"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.exposed_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">exposed_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">process_class</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">agglomerate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the outputs which were exposed from the ``process_class`` and emitted by the specific ``node``</span>

<span class="sd">        :param node: process node whose outputs to try and retrieve</span>
<span class="sd">        :type node: :class:`aiida.orm.nodes.process.ProcessNode`</span>

<span class="sd">        :param namespace: Namespace in which to search for exposed outputs.</span>
<span class="sd">        :type namespace: str</span>

<span class="sd">        :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also</span>
<span class="sd">            be searched for outputs. Outputs in lower-lying namespaces take precedence.</span>
<span class="sd">        :type agglomerate: bool</span>

<span class="sd">        :returns: exposed outputs</span>
<span class="sd">        :rtype: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">namespace_separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">namespace_separator</span>

        <span class="n">output_key_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># maps the exposed name to all outputs that belong to it</span>
        <span class="n">top_namespace_map</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">link_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">)</span>
        <span class="n">process_outputs_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">link_label</span><span class="p">:</span> <span class="n">entry</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="n">link_types</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">port_name</span> <span class="ow">in</span> <span class="n">process_outputs_dict</span><span class="p">:</span>
            <span class="n">top_namespace</span> <span class="o">=</span> <span class="n">port_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">namespace_separator</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">top_namespace_map</span><span class="p">[</span><span class="n">top_namespace</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">port_namespace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_namespace_list</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span> <span class="n">agglomerate</span><span class="o">=</span><span class="n">agglomerate</span><span class="p">):</span>
            <span class="c1"># only the top-level key is stored in _exposed_outputs</span>
            <span class="k">for</span> <span class="n">top_name</span> <span class="ow">in</span> <span class="n">top_namespace_map</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">top_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">_exposed_outputs</span><span class="p">[</span><span class="n">port_namespace</span><span class="p">][</span><span class="n">process_class</span><span class="p">]:</span>  <span class="c1"># pylint: disable=protected-access</span>
                    <span class="n">output_key_map</span><span class="p">[</span><span class="n">top_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_namespace</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">top_name</span><span class="p">,</span> <span class="n">port_namespace</span> <span class="ow">in</span> <span class="n">output_key_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># collect all outputs belonging to the given top_name</span>
            <span class="k">for</span> <span class="n">port_name</span> <span class="ow">in</span> <span class="n">top_namespace_map</span><span class="p">[</span><span class="n">top_name</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">port_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_outputs_dict</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">port_namespace</span> <span class="o">+</span> <span class="n">namespace_separator</span> <span class="o">+</span> <span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_outputs_dict</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">AttributeDict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="Process._get_namespace_list"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process._get_namespace_list">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_namespace_list</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">agglomerate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the list of namespaces in a given namespace.</span>

<span class="sd">        :param namespace: name space</span>
<span class="sd">        :type namespace: str</span>

<span class="sd">        :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also</span>
<span class="sd">            be searched.</span>
<span class="sd">        :type agglomerate: bool</span>

<span class="sd">        :returns: namespace list</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">agglomerate</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">namespace</span><span class="p">]</span>

        <span class="n">namespace_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">split_ns</span> <span class="o">=</span> <span class="n">namespace</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="n">namespace_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">split_ns</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_ns</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">namespace_list</span></div>

<div class="viewcode-block" id="Process.is_valid_cache"><a class="viewcode-back" href="../../../../apidoc/aiida.engine.processes.html#aiida.engine.Process.is_valid_cache">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_valid_cache</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the given node can be cached from.</span>

<span class="sd">        .. warning :: When overriding this method, make sure to call</span>
<span class="sd">            super().is_valid_cache(node) and respect its output. Otherwise,</span>
<span class="sd">            the &#39;invalidates_cache&#39; keyword on exit codes will not work.</span>

<span class="sd">        This method allows extending the behavior of `ProcessNode.is_valid_cache`</span>
<span class="sd">        from `Process` sub-classes, for example in plug-ins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">spec</span><span class="p">()</span><span class="o">.</span><span class="n">exit_codes</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exit_status</span><span class="p">)</span><span class="o">.</span><span class="n">invalidates_cache</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div></div>


<span class="k">def</span> <span class="nf">get_query_string_from_process_type_string</span><span class="p">(</span><span class="n">process_type_string</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take the process type string of a Node and create the queryable type string.</span>

<span class="sd">    :param process_type_string: the process type string</span>
<span class="sd">    :type process_type_string: str</span>

<span class="sd">    :return: string that can be used to query for subclasses of the process type using &#39;LIKE &lt;string&gt;&#39;</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">process_type_string</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process_type_string</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">process_type_string</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>