

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.restapi.common.identifiers &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/togglebutton.js"></script>
        <script src="../../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.restapi.common.identifiers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.restapi.common.identifiers</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Utility functions to work with node &quot;full types&quot; which are unique node identifiers.</span>

<span class="sd">A node&#39;s `full_type` is defined as a string that uniquely defines the node type. A valid `full_type` is constructed by</span>
<span class="sd">concatenating the `node_type` and `process_type` of a node with the `FULL_TYPE_CONCATENATOR`. Each segment of the full</span>
<span class="sd">type can optionally be terminated by a single `LIKE_OPERATOR_CHARACTER` to indicate that the `node_type` or</span>
<span class="sd">`process_type` should start with that value but can be followed by any amount of other characters. A full type is</span>
<span class="sd">invalid if it does not contain exactly one `FULL_TYPE_CONCATENATOR` character. Additionally, each segment can contain</span>
<span class="sd">at most one occurrence of the `LIKE_OPERATOR_CHARACTER` and it has to be at the end of the segment.</span>

<span class="sd">Examples of valid full types:</span>

<span class="sd">    &#39;data.bool.Bool.|&#39;</span>
<span class="sd">    &#39;process.calculation.calcfunction.%|%&#39;</span>
<span class="sd">    &#39;process.calculation.calcjob.CalcJobNode.|aiida.calculations:arithmetic.add&#39;</span>
<span class="sd">    &#39;process.calculation.calcfunction.CalcFunctionNode.|aiida.workflows:codtools.primitive_structure_from_cif&#39;</span>

<span class="sd">Examples of invalid full types:</span>

<span class="sd">    &#39;data.bool&#39;  # Only a single segment without concatenator</span>
<span class="sd">    &#39;data.|bool.Bool.|process.&#39;  # More than one concatenator</span>
<span class="sd">    &#39;process.calculation%.calcfunction.|aiida.calculations:arithmetic.add&#39;  # Like operator not at end of segment</span>
<span class="sd">    &#39;process.calculation%.calcfunction.%|aiida.calculations:arithmetic.add&#39;  # More than one operator in segment</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="kn">import</span> <span class="n">escape_for_sql_like</span>

<span class="n">FULL_TYPE_CONCATENATOR</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span>
<span class="n">LIKE_OPERATOR_CHARACTER</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span>
<span class="n">DEFAULT_NAMESPACE_LABEL</span> <span class="o">=</span> <span class="s1">&#39;~no-entry-point~&#39;</span>


<div class="viewcode-block" id="validate_full_type"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.validate_full_type">[docs]</a><span class="k">def</span> <span class="nf">validate_full_type</span><span class="p">(</span><span class="n">full_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validate that the `full_type` is a valid full type unique node identifier.</span>

<span class="sd">    :param full_type: a `Node` full type</span>
<span class="sd">    :raises ValueError: if the `full_type` is invalid</span>
<span class="sd">    :raises TypeError: if the `full_type` is not a string type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.common.lang</span> <span class="kn">import</span> <span class="n">type_check</span>

    <span class="n">type_check</span><span class="p">(</span><span class="n">full_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">FULL_TYPE_CONCATENATOR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">full_type</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;full type `</span><span class="si">{}</span><span class="s1">` does not include the required concatenator symbol `</span><span class="si">{}</span><span class="s1">`.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">full_type</span><span class="p">,</span> <span class="n">FULL_TYPE_CONCATENATOR</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">full_type</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">FULL_TYPE_CONCATENATOR</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;full type `</span><span class="si">{}</span><span class="s1">` includes the concatenator symbol `</span><span class="si">{}</span><span class="s1">` more than once.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">full_type</span><span class="p">,</span> <span class="n">FULL_TYPE_CONCATENATOR</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="construct_full_type"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.construct_full_type">[docs]</a><span class="k">def</span> <span class="nf">construct_full_type</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the full type, which uniquely identifies any `Node` with the given `node_type` and `process_type`.</span>

<span class="sd">    :param node_type: the `node_type` of the `Node`</span>
<span class="sd">    :param process_type: the `process_type` of the `Node`</span>
<span class="sd">    :return: the full type, which is a unique identifier</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">process_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="n">process_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">process_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">FULL_TYPE_CONCATENATOR</span><span class="p">,</span> <span class="n">process_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_full_type_filters"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.get_full_type_filters">[docs]</a><span class="k">def</span> <span class="nf">get_full_type_filters</span><span class="p">(</span><span class="n">full_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the `QueryBuilder` filters that will return all `Nodes` identified by the given `full_type`.</span>

<span class="sd">    :param full_type: the `full_type` unique node identifier</span>
<span class="sd">    :return: dictionary of filters to be passed for the `filters` keyword in `QueryBuilder.append`</span>
<span class="sd">    :raises ValueError: if the `full_type` is invalid</span>
<span class="sd">    :raises TypeError: if the `full_type` is not a string type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">validate_full_type</span><span class="p">(</span><span class="n">full_type</span><span class="p">)</span>

    <span class="n">filters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span> <span class="o">=</span> <span class="n">full_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">FULL_TYPE_CONCATENATOR</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">LIKE_OPERATOR_CHARACTER</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;full type component `</span><span class="si">{}</span><span class="s1">` contained more than one like-operator character&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">LIKE_OPERATOR_CHARACTER</span> <span class="ow">in</span> <span class="n">entry</span> <span class="ow">and</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LIKE_OPERATOR_CHARACTER</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;like-operator character in full type component `</span><span class="si">{}</span><span class="s1">` is not at the end&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">LIKE_OPERATOR_CHARACTER</span> <span class="ow">in</span> <span class="n">node_type</span><span class="p">:</span>
        <span class="c1"># Remove the trailing `LIKE_OPERATOR_CHARACTER`, escape the string and reattach the character</span>
        <span class="n">node_type</span> <span class="o">=</span> <span class="n">node_type</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">node_type</span> <span class="o">=</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span> <span class="o">+</span> <span class="n">LIKE_OPERATOR_CHARACTER</span>
        <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;node_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">node_type</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;node_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">LIKE_OPERATOR_CHARACTER</span> <span class="ow">in</span> <span class="n">process_type</span><span class="p">:</span>
        <span class="c1"># Remove the trailing `LIKE_OPERATOR_CHARACTER`, escape the string and reattach the character</span>
        <span class="n">process_type</span> <span class="o">=</span> <span class="n">process_type</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">process_type</span> <span class="o">=</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">process_type</span><span class="p">)</span> <span class="o">+</span> <span class="n">LIKE_OPERATOR_CHARACTER</span>
        <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;process_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">process_type</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">process_type</span><span class="p">:</span>
            <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;process_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">process_type</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filters</span></div>


<div class="viewcode-block" id="load_entry_point_from_full_type"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.load_entry_point_from_full_type">[docs]</a><span class="k">def</span> <span class="nf">load_entry_point_from_full_type</span><span class="p">(</span><span class="n">full_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the loaded entry point for the given `full_type` unique node identifier.</span>

<span class="sd">    :param full_type: the `full_type` unique node identifier</span>
<span class="sd">    :raises ValueError: if the `full_type` is invalid</span>
<span class="sd">    :raises TypeError: if the `full_type` is not a string type</span>
<span class="sd">    :raises `~aiida.common.exceptions.EntryPointError`: if the corresponding entry point cannot be loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">EntryPointError</span>
    <span class="kn">from</span> <span class="nn">aiida.common.utils</span> <span class="kn">import</span> <span class="n">strip_prefix</span>
    <span class="kn">from</span> <span class="nn">aiida.plugins.entry_point</span> <span class="kn">import</span> <span class="n">is_valid_entry_point_string</span><span class="p">,</span> <span class="n">load_entry_point</span><span class="p">,</span> <span class="n">load_entry_point_from_string</span>

    <span class="n">data_prefix</span> <span class="o">=</span> <span class="s1">&#39;data.&#39;</span>

    <span class="n">validate_full_type</span><span class="p">(</span><span class="n">full_type</span><span class="p">)</span>

    <span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span> <span class="o">=</span> <span class="n">full_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">FULL_TYPE_CONCATENATOR</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_valid_entry_point_string</span><span class="p">(</span><span class="n">process_type</span><span class="p">):</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">load_entry_point_from_string</span><span class="p">(</span><span class="n">process_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">EntryPointError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EntryPointError</span><span class="p">(</span><span class="s1">&#39;could not load entry point `</span><span class="si">{}</span><span class="s1">`&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">process_type</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">node_type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">data_prefix</span><span class="p">):</span>

        <span class="n">base_name</span> <span class="o">=</span> <span class="n">strip_prefix</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">data_prefix</span><span class="p">)</span>
        <span class="n">entry_point_name</span> <span class="o">=</span> <span class="n">base_name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">load_entry_point</span><span class="p">(</span><span class="s1">&#39;aiida.data&#39;</span><span class="p">,</span> <span class="n">entry_point_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">EntryPointError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EntryPointError</span><span class="p">(</span><span class="s1">&#39;could not load entry point `</span><span class="si">{}</span><span class="s1">`&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">process_type</span><span class="p">))</span>

    <span class="c1"># Here we are dealing with a `ProcessNode` with a `process_type` that is not an entry point string.</span>
    <span class="c1"># Which means it is most likely a full module path (the fallback option) and we cannot necessarily load the</span>
    <span class="c1"># class from this. We could try with `importlib` but not sure that we should</span>
    <span class="k">raise</span> <span class="n">EntryPointError</span><span class="p">(</span><span class="s1">&#39;entry point of the given full type cannot be loaded&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Namespace"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace">[docs]</a><span class="k">class</span> <span class="nc">Namespace</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Namespace that can be used to map the node class hierarchy.&quot;&quot;&quot;</span>

    <span class="n">namespace_separator</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

    <span class="c1"># Very ugly ad-hoc mapping of `path` to `label` for the non-leaf entries in the nested `Namespace` mapping:</span>
    <span class="n">mapping_path_to_label</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.data&#39;</span><span class="p">:</span> <span class="s1">&#39;Data&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process&#39;</span><span class="p">:</span> <span class="s1">&#39;Process&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process.calculation&#39;</span><span class="p">:</span> <span class="s1">&#39;Calculation&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process.calculation.calcjob&#39;</span><span class="p">:</span> <span class="s1">&#39;Calculation job&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process.calculation.calcfunction&#39;</span><span class="p">:</span> <span class="s1">&#39;Calculation function&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process.workflow&#39;</span><span class="p">:</span> <span class="s1">&#39;Workflow&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process.workflow.workchain&#39;</span><span class="p">:</span> <span class="s1">&#39;Work chain&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node.process.workflow.workfunction&#39;</span><span class="p">:</span> <span class="s1">&#39;Work function&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># This is a hard-coded mapping to generate the correct full types for process node namespaces of external</span>
    <span class="c1"># plugins. The `node_type` in that case is fixed and the `process_type` should start with the entry point group</span>
    <span class="c1"># followed by the plugin name and the wildcard.</span>
    <span class="n">process_full_type_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;process.calculation.calcjob.&#39;</span><span class="p">:</span> <span class="s1">&#39;process.calculation.calcjob.CalcJobNode.|aiida.calculations:</span><span class="si">{plugin_name}</span><span class="s1">.%&#39;</span><span class="p">,</span>
        <span class="s1">&#39;process.calculation.calcfunction.&#39;</span><span class="p">:</span>
        <span class="s1">&#39;process.calculation.calcfunction.CalcFunctionNode.|aiida.calculations:</span><span class="si">{plugin_name}</span><span class="s1">.%&#39;</span><span class="p">,</span>
        <span class="s1">&#39;process.workflow.workfunction.&#39;</span><span class="p">:</span>
        <span class="s1">&#39;process.workflow.workfunction.WorkFunctionNode.|aiida.workflows:</span><span class="si">{plugin_name}</span><span class="s1">.%&#39;</span><span class="p">,</span>
        <span class="s1">&#39;process.workflow.workchain.&#39;</span><span class="p">:</span> <span class="s1">&#39;process.workflow.workchain.WorkChainNode.|aiida.workflows:</span><span class="si">{plugin_name}</span><span class="s1">.%&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="Namespace.__str__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_description</span><span class="p">(),</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></div>

<div class="viewcode-block" id="Namespace.__init__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new node class namespace.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=super-init-not-called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="n">namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_full_type</span><span class="p">(</span><span class="n">full_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span> <span class="o">=</span> <span class="n">is_leaf</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_path_to_label</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Manual override for process subspaces that contain entries corresponding to nodes with &quot;unregistered&quot; process</span>
        <span class="c1"># types. In this case, the label should become `Unregistered` and the full type set to `None` because we cannot</span>
        <span class="c1"># query for all nodes that fall under this category.</span>
        <span class="k">if</span> <span class="n">namespace</span> <span class="o">==</span> <span class="n">DEFAULT_NAMESPACE_LABEL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="s1">&#39;Unregistered&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_full_type</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Namespace._infer_full_type"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace._infer_full_type">[docs]</a>    <span class="k">def</span> <span class="nf">_infer_full_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Infer the full type based on the current namespace path and the given full type of the leaf.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.utils</span> <span class="kn">import</span> <span class="n">strip_prefix</span>

        <span class="k">if</span> <span class="n">full_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_type</span>

        <span class="n">full_type</span> <span class="o">=</span> <span class="n">strip_prefix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="s1">&#39;node.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full_type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;process.&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">basepath</span><span class="p">,</span> <span class="n">full_type_template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_full_type_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">full_type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">basepath</span><span class="p">):</span>
                    <span class="n">plugin_name</span> <span class="o">=</span> <span class="n">strip_prefix</span><span class="p">(</span><span class="n">full_type</span><span class="p">,</span> <span class="n">basepath</span><span class="p">)</span>
                    <span class="n">full_type</span> <span class="o">=</span> <span class="n">full_type_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">plugin_name</span><span class="o">=</span><span class="n">plugin_name</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">full_type</span>

        <span class="n">full_type</span> <span class="o">+=</span> <span class="s1">&#39;.</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">LIKE_OPERATOR_CHARACTER</span><span class="p">,</span> <span class="n">FULL_TYPE_CONCATENATOR</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full_type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;process.&#39;</span><span class="p">):</span>
            <span class="n">full_type</span> <span class="o">+=</span> <span class="n">LIKE_OPERATOR_CHARACTER</span>

        <span class="k">return</span> <span class="n">full_type</span></div>

<div class="viewcode-block" id="Namespace.__iter__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span></div>

<div class="viewcode-block" id="Namespace.__len__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span><span class="p">)</span></div>

<div class="viewcode-block" id="Namespace.__delitem__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__delitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="Namespace.__getitem__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="Namespace.__setitem__"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">port</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span>

<div class="viewcode-block" id="Namespace.get_description"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.get_description">[docs]</a>    <span class="k">def</span> <span class="nf">get_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary with a description of the ports this namespace contains.</span>

<span class="sd">        Nested PortNamespaces will be properly recursed and Ports will print their properties in a list</span>

<span class="sd">        :returns: a dictionary of descriptions of the Ports contained within this PortNamespace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;namespace&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span><span class="p">,</span>
            <span class="s1">&#39;full_type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_type</span><span class="p">,</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span>
            <span class="s1">&#39;subspaces&#39;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">port</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subspaces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;subspaces&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port</span><span class="o">.</span><span class="n">get_description</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Namespace.create_namespace"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.Namespace.create_namespace">[docs]</a>    <span class="k">def</span> <span class="nf">create_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create and return a new `Namespace` in this `Namespace`.</span>

<span class="sd">        If the name is namespaced, the sub `Namespaces` will be created recursively, except if one of the namespaces is</span>
<span class="sd">        already occupied at any level by a Port in which case a ValueError will be thrown</span>

<span class="sd">        :param name: name (potentially namespaced) of the port to create and return</span>
<span class="sd">        :param kwargs: constructor arguments that will be used *only* for the construction of the terminal Namespace</span>
<span class="sd">        :returns: Namespace</span>
<span class="sd">        :raises: ValueError if any sub namespace is occupied by a non-Namespace port</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;name has to be a string type, not </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;name cannot be an empty string&#39;</span><span class="p">)</span>

        <span class="n">namespace</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="p">)</span>
        <span class="n">port_name</span> <span class="o">=</span> <span class="n">namespace</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="p">,</span> <span class="n">port_name</span><span class="p">)</span>

        <span class="c1"># If this is True, the (sub) port namespace does not yet exist, so we create it</span>
        <span class="k">if</span> <span class="n">port_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>

            <span class="c1"># If there still is a `namespace`, we create a sub namespace, *without* the constructor arguments</span>
            <span class="k">if</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Otherwise it is the terminal port and we construct *with* the keyword arugments</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;is_leaf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The port does already exist: if it is a leaf and `namespace` is not empty, then the current leaf node is</span>
            <span class="c1"># also a namespace itself, so create a namespace with the same name and put the leaf within itself</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">is_leaf</span> <span class="ow">and</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">][</span><span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">clone</span>

            <span class="c1"># If the current existing port is not a leaf and we do not have remaining namespace, that means the current</span>
            <span class="c1"># namespace is the &quot;concrete&quot; version of the namespace, so we add the leaf version to the namespace.</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">is_leaf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;is_leaf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">][</span><span class="n">port_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">port_name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">port_name</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If there is still `namespace` left, we create the next namespace</span>
        <span class="k">if</span> <span class="n">namespace</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;is_leaf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span><span class="o">.</span><span class="n">create_namespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">namespace</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">port_name</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="get_node_namespace"><a class="viewcode-back" href="../../../../apidoc/aiida.restapi.common.html#aiida.restapi.common.identifiers.get_node_namespace">[docs]</a><span class="k">def</span> <span class="nf">get_node_namespace</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the full namespace of all available nodes in the current database.</span>

<span class="sd">    :return: complete node `Namespace`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida</span> <span class="kn">import</span> <span class="n">orm</span>
    <span class="kn">from</span> <span class="nn">aiida.plugins.entry_point</span> <span class="kn">import</span> <span class="n">is_valid_entry_point_string</span><span class="p">,</span> <span class="n">parse_entry_point_string</span>

    <span class="n">builder</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;node_type&#39;</span><span class="p">,</span> <span class="s1">&#39;process_type&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
    <span class="n">unique_types</span> <span class="o">=</span> <span class="p">{(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span> <span class="k">if</span> <span class="n">process_type</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>

    <span class="c1"># First we create a flat list of all &quot;leaf&quot; node types.</span>
    <span class="n">namespaces</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span> <span class="ow">in</span> <span class="n">unique_types</span><span class="p">:</span>

        <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">process_type</span><span class="p">:</span>
            <span class="c1"># Process nodes</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">node_type</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_valid_entry_point_string</span><span class="p">(</span><span class="n">process_type</span><span class="p">):</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">entry_point_name</span> <span class="o">=</span> <span class="n">parse_entry_point_string</span><span class="p">(</span><span class="n">process_type</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">entry_point_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">entry_point_name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">process_type</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">DEFAULT_NAMESPACE_LABEL</span><span class="p">,</span> <span class="n">label</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Data nodes</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">node_type</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="n">full_type</span> <span class="o">=</span> <span class="n">construct_full_type</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">process_type</span><span class="p">)</span>
        <span class="n">namespaces</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">namespace</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">full_type</span><span class="p">))</span>

    <span class="n">node_namespace</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">full_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">namespaces</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">node_namespace</span><span class="o">.</span><span class="n">create_namespace</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">full_type</span><span class="o">=</span><span class="n">full_type</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">node_namespace</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>