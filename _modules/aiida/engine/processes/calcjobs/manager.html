

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.engine.processes.calcjobs.manager &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
        <script src="../../../../../_static/togglebutton.js"></script>
        <script src="../../../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.engine.processes.calcjobs.manager</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.engine.processes.calcjobs.manager</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Module containing utilities and classes relating to job calculations running on systems that require transport.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">tornado</span> <span class="kn">import</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">gen</span>

<span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">lang</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;JobsList&#39;</span><span class="p">,</span> <span class="s1">&#39;JobManager&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="JobsList"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList">[docs]</a><span class="k">class</span> <span class="nc">JobsList</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manager of calculation jobs submitted with a specific ``AuthInfo``, i.e. computer configured for a specific user.</span>

<span class="sd">    This container of active calculation jobs is used to update their status periodically in batches, ensuring that</span>
<span class="sd">    even when a lot of jobs are running, the scheduler update command is not triggered for each job individually.</span>

<span class="sd">    In addition, the :py:class:`~aiida.orm.computers.Computer` for which the :py:class:`~aiida.orm.authinfos.AuthInfo`</span>
<span class="sd">    is configured, can define a minimum polling interval. This class will guarantee that the time between update calls</span>
<span class="sd">    to the scheduler is larger or equal to that minimum interval.</span>

<span class="sd">    Note that since each instance operates on a specific authinfo, the guarantees of batching scheduler update calls</span>
<span class="sd">    and the limiting of number of calls per unit time, through the minimum polling interval, is only applicable for jobs</span>
<span class="sd">    launched with that particular authinfo. If multiple authinfo instances with the same computer, have active jobs</span>
<span class="sd">    these limitations are not respected between them, since there is no communication between ``JobsList`` instances.</span>
<span class="sd">    See the :py:class:`~aiida.engine.processes.calcjobs.manager.JobManager` for example usage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="JobsList.__init__"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">authinfo</span><span class="p">,</span> <span class="n">transport_queue</span><span class="p">,</span> <span class="n">last_updated</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct an instance for the given authinfo and transport queue.</span>

<span class="sd">        :param authinfo: The authinfo used to check the jobs list</span>
<span class="sd">        :type authinfo: :class:`aiida.orm.AuthInfo`</span>
<span class="sd">        :param transport_queue: A transport queue</span>
<span class="sd">        :type: :class:`aiida.engine.transports.TransportQueue`</span>
<span class="sd">        :param last_updated: initialize the last updated timestamp</span>
<span class="sd">        :type: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lang</span><span class="o">.</span><span class="n">type_check</span><span class="p">(</span><span class="n">last_updated</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_authinfo</span> <span class="o">=</span> <span class="n">authinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transport_queue</span> <span class="o">=</span> <span class="n">transport_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span> <span class="o">=</span> <span class="n">transport_queue</span><span class="o">.</span><span class="n">loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_jobs_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Mapping: {job_id: Future}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_updated</span> <span class="o">=</span> <span class="n">last_updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_handle</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the logger configured for this instance.</span>

<span class="sd">        :return: the logger</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>

<div class="viewcode-block" id="JobsList.get_minimum_update_interval"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList.get_minimum_update_interval">[docs]</a>    <span class="k">def</span> <span class="nf">get_minimum_update_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the minimum interval that should be respected between updates of the list.</span>

<span class="sd">        :return: the minimum interval</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_authinfo</span><span class="o">.</span><span class="n">computer</span><span class="o">.</span><span class="n">get_minimum_job_poll_interval</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_updated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the timestamp of when the list was last updated as produced by `time.time()`</span>

<span class="sd">        :return: The last update point</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_updated</span>

<div class="viewcode-block" id="JobsList._get_jobs_from_scheduler"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_from_scheduler">[docs]</a>    <span class="nd">@gen</span><span class="o">.</span><span class="n">coroutine</span>
    <span class="k">def</span> <span class="nf">_get_jobs_from_scheduler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current jobs list from the scheduler.</span>

<span class="sd">        :return: a mapping of job ids to :py:class:`~aiida.schedulers.datastructures.JobInfo` instances</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transport_queue</span><span class="o">.</span><span class="n">request_transport</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_authinfo</span><span class="p">)</span> <span class="k">as</span> <span class="n">request</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;waiting for transport&#39;</span><span class="p">)</span>
            <span class="n">transport</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">request</span>

            <span class="n">scheduler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_authinfo</span><span class="o">.</span><span class="n">computer</span><span class="o">.</span><span class="n">get_scheduler</span><span class="p">()</span>
            <span class="n">scheduler</span><span class="o">.</span><span class="n">set_transport</span><span class="p">(</span><span class="n">transport</span><span class="p">)</span>

            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;as_dict&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">get_feature</span><span class="p">(</span><span class="s1">&#39;can_query_by_user&#39;</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;user&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;$USER&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;jobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_jobs_with_scheduler</span><span class="p">()</span>

            <span class="n">scheduler_response</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">get_jobs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Update the last update time and clear the jobs cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_updated</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">jobs_cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;AuthInfo&lt;</span><span class="si">{}</span><span class="s1">&gt;: successfully retrieved status of active jobs&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_authinfo</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">job_info</span> <span class="ow">in</span> <span class="n">scheduler_response</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">jobs_cache</span><span class="p">[</span><span class="n">job_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">job_info</span>

            <span class="k">raise</span> <span class="n">gen</span><span class="o">.</span><span class="n">Return</span><span class="p">(</span><span class="n">jobs_cache</span><span class="p">)</span></div>

<div class="viewcode-block" id="JobsList._update_job_info"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._update_job_info">[docs]</a>    <span class="nd">@gen</span><span class="o">.</span><span class="n">coroutine</span>
    <span class="k">def</span> <span class="nf">_update_job_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update all of the job information objects.</span>

<span class="sd">        This will set the futures for all pending update requests where the corresponding job has a new status compared</span>
<span class="sd">        to the last update.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_requests_outstanding</span><span class="p">():</span>
                <span class="k">return</span>

            <span class="c1"># Update our cache of the job states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jobs_cache</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_jobs_from_scheduler</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exception</span><span class="p">:</span>
            <span class="c1"># Set the exception on all the update futures</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                    <span class="n">future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">exception</span><span class="p">)</span>

            <span class="c1"># Reset the `_update_handle` manually. Normally this is done in the `updating` coroutine, but since we</span>
            <span class="c1"># reraise this exception, that code path is never hit. If the next time a request comes in, the method</span>
            <span class="c1"># `_ensure_updating` will falsely conclude we are still updating, since the handle is not `None` and so it</span>
            <span class="c1"># will not schedule the next update, causing the job update futures to never be resolved.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_handle</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">future</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                    <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jobs_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">job_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="JobsList.request_job_info_update"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update">[docs]</a>    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">request_job_info_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Request job info about a job when the job next changes state.</span>

<span class="sd">        If the job is not found in the jobs list at the update, the future will resolve to `None`.</span>

<span class="sd">        :param job_id: job identifier</span>
<span class="sd">        :return: future that will resolve to a `JobInfo` object when the job changes state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get or create the future</span>
        <span class="n">request</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">job_id</span><span class="p">,</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">Future</span><span class="p">())</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">request</span><span class="o">.</span><span class="n">done</span><span class="p">(),</span> <span class="s1">&#39;Expected pending job info future, found in done state.&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_updating</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">request</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="JobsList._ensure_updating"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._ensure_updating">[docs]</a>    <span class="k">def</span> <span class="nf">_ensure_updating</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that we are updating the job list from the remote resource.</span>

<span class="sd">        This will automatically stop if there are no outstanding requests.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@gen</span><span class="o">.</span><span class="n">coroutine</span>
        <span class="k">def</span> <span class="nf">updating</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Do the actual update, stop if not requests left.&quot;&quot;&quot;</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_job_info</span><span class="p">()</span>
            <span class="c1"># Any outstanding requests?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_requests_outstanding</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_next_update_delay</span><span class="p">(),</span> <span class="n">updating</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_handle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Check if we&#39;re already updating</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_handle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_next_update_delay</span><span class="p">(),</span> <span class="n">updating</span><span class="p">)</span></div>

<div class="viewcode-block" id="JobsList._has_job_state_changed"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._has_job_state_changed">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_has_job_state_changed</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the states `old` and `new` are different.</span>

<span class="sd">        :type old: :class:`aiida.schedulers.JobInfo` or `None`</span>
<span class="sd">        :type new: :class:`aiida.schedulers.JobInfo` or `None`</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># One is None and the other isn&#39;t</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">old</span><span class="o">.</span><span class="n">job_state</span> <span class="o">!=</span> <span class="n">new</span><span class="o">.</span><span class="n">job_state</span> <span class="ow">or</span> <span class="n">old</span><span class="o">.</span><span class="n">job_substate</span> <span class="o">!=</span> <span class="n">new</span><span class="o">.</span><span class="n">job_substate</span></div>

<div class="viewcode-block" id="JobsList._get_next_update_delay"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._get_next_update_delay">[docs]</a>    <span class="k">def</span> <span class="nf">_get_next_update_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate when we are next allowed to poll the scheduler.</span>

<span class="sd">        This delay is calculated as the minimum polling interval defined by the authentication info for this instance,</span>
<span class="sd">        minus time elapsed since the last update.</span>

<span class="sd">        :return: delay (in seconds) after which the scheduler may be polled again</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_updated</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Never updated, so do it straight away</span>
            <span class="k">return</span> <span class="mf">0.</span>

        <span class="c1"># Make sure to actually &#39;get&#39; the minimum interval here, in case the user changed since last time</span>
        <span class="n">minimum_interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_minimum_update_interval</span><span class="p">()</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_updated</span>

        <span class="n">delay</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimum_interval</span> <span class="o">-</span> <span class="n">elapsed</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">delay</span></div>

<div class="viewcode-block" id="JobsList._update_requests_outstanding"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._update_requests_outstanding">[docs]</a>    <span class="k">def</span> <span class="nf">_update_requests_outstanding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">request</span><span class="o">.</span><span class="n">done</span><span class="p">()</span> <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="JobsList._get_jobs_with_scheduler"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_with_scheduler">[docs]</a>    <span class="k">def</span> <span class="nf">_get_jobs_with_scheduler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all the jobs that are currently with scheduler.</span>

<span class="sd">        :return: the list of jobs with the scheduler</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_update_requests</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span></div></div>


<div class="viewcode-block" id="JobManager"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobManager">[docs]</a><span class="k">class</span> <span class="nc">JobManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A manager for :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` submitted to ``Computer`` instances.</span>

<span class="sd">    When a calculation job is submitted to a :py:class:`~aiida.orm.computers.Computer`, it actually uses a specific</span>
<span class="sd">    :py:class:`~aiida.orm.authinfos.AuthInfo`, which is a computer configured for a :py:class:`~aiida.orm.users.User`.</span>
<span class="sd">    The ``JobManager`` maintains a mapping of :py:class:`~aiida.engine.processes.calcjobs.manager.JobsList` instances</span>
<span class="sd">    for each authinfo that has active calculation jobs. These jobslist instances are then responsible for bundling</span>
<span class="sd">    scheduler updates for all the jobs they maintain (i.e. that all share the same authinfo) and update their status.</span>

<span class="sd">    As long as a :py:class:`~aiida.engine.runners.Runner` will create a single ``JobManager`` instance and use that for</span>
<span class="sd">    its lifetime, the guarantees made by the ``JobsList`` about respecting the minimum polling interval of the scheduler</span>
<span class="sd">    will be maintained. Note, however, that since each ``Runner`` will create its own job manager, these guarantees</span>
<span class="sd">    only hold per runner.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="JobManager.__init__"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobManager.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport_queue</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transport_queue</span> <span class="o">=</span> <span class="n">transport_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_job_lists</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="JobManager.get_jobs_list"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobManager.get_jobs_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_jobs_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">authinfo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get or create a new `JobLists` instance for the given authinfo.</span>

<span class="sd">        :param authinfo: the `AuthInfo`</span>
<span class="sd">        :return: a `JobsList` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">authinfo</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_lists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_job_lists</span><span class="p">[</span><span class="n">authinfo</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">JobsList</span><span class="p">(</span><span class="n">authinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transport_queue</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_job_lists</span><span class="p">[</span><span class="n">authinfo</span><span class="o">.</span><span class="n">id</span><span class="p">]</span></div>

<div class="viewcode-block" id="JobManager.request_job_info_update"><a class="viewcode-back" href="../../../../../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.manager.JobManager.request_job_info_update">[docs]</a>    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">request_job_info_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">authinfo</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a future that will resolve to information about a given job.</span>

<span class="sd">        This is a context manager so that if the user leaves the context the request is automatically cancelled.</span>

<span class="sd">        :return: A tuple containing the `JobInfo` object and detailed job info. Both can be None.</span>
<span class="sd">        :rtype: :class:`tornado.concurrent.Future`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_jobs_list</span><span class="p">(</span><span class="n">authinfo</span><span class="p">)</span><span class="o">.</span><span class="n">request_job_info_update</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">request</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">request</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">request</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                    <span class="n">request</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>