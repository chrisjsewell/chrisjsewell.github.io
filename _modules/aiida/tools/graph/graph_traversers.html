

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.tools.graph.graph_traversers &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script src="../../../../_static/togglebutton.js"></script>
        <script src="../../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.tools.graph.graph_traversers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.tools.graph.graph_traversers</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Module for functions to traverse AiiDA graphs.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">inf</span>
<span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="kn">import</span> <span class="n">GraphTraversalRules</span><span class="p">,</span> <span class="n">LinkType</span>


<div class="viewcode-block" id="get_nodes_delete"><a class="viewcode-back" href="../../../../apidoc/aiida.tools.graph.html#aiida.tools.graph.graph_traversers.get_nodes_delete">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_delete</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">,</span> <span class="n">get_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return the set of all nodes that can be connected</span>
<span class="sd">    to a list of initial nodes through any sequence of specified authorized</span>
<span class="sd">    links and directions for deletion.</span>

<span class="sd">    :type starting_pks: list or tuple or set</span>
<span class="sd">    :param starting_pks: Contains the (valid) pks of the starting nodes.</span>

<span class="sd">    :param bool get_links:</span>
<span class="sd">        Pass True to also return the links between all nodes (found + initial).</span>

<span class="sd">    :param bool create_forward: will traverse CREATE links in the forward direction.</span>
<span class="sd">    :param bool call_calc_forward: will traverse CALL_CALC links in the forward direction.</span>
<span class="sd">    :param bool call_work_forward: will traverse CALL_WORK links in the forward direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">traverse_links</span> <span class="o">=</span> <span class="n">validate_traversal_rules</span><span class="p">(</span><span class="n">GraphTraversalRules</span><span class="o">.</span><span class="n">DELETE</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">traverse_output</span> <span class="o">=</span> <span class="n">traverse_graph</span><span class="p">(</span>
        <span class="n">starting_pks</span><span class="p">,</span>
        <span class="n">get_links</span><span class="o">=</span><span class="n">get_links</span><span class="p">,</span>
        <span class="n">links_forward</span><span class="o">=</span><span class="n">traverse_links</span><span class="p">[</span><span class="s1">&#39;forward&#39;</span><span class="p">],</span>
        <span class="n">links_backward</span><span class="o">=</span><span class="n">traverse_links</span><span class="p">[</span><span class="s1">&#39;backward&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">function_output</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">traverse_output</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">],</span>
        <span class="s1">&#39;links&#39;</span><span class="p">:</span> <span class="n">traverse_output</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">],</span>
        <span class="s1">&#39;rules&#39;</span><span class="p">:</span> <span class="n">traverse_links</span><span class="p">[</span><span class="s1">&#39;rules_applied&#39;</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">function_output</span></div>


<div class="viewcode-block" id="get_nodes_export"><a class="viewcode-back" href="../../../../apidoc/aiida.tools.graph.html#aiida.tools.graph.graph_traversers.get_nodes_export">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_export</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">,</span> <span class="n">get_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return the set of all nodes that can be connected</span>
<span class="sd">    to a list of initial nodes through any sequence of specified authorized</span>
<span class="sd">    links and directions for export. This will also return the links and</span>
<span class="sd">    the traversal rules parsed.</span>

<span class="sd">    :type starting_pks: list or tuple or set</span>
<span class="sd">    :param starting_pks: Contains the (valid) pks of the starting nodes.</span>

<span class="sd">    :param bool get_links:</span>
<span class="sd">        Pass True to also return the links between all nodes (found + initial).</span>

<span class="sd">    :param bool input_calc_forward: will traverse INPUT_CALC links in the forward direction.</span>
<span class="sd">    :param bool create_backward: will traverse CREATE links in the backward direction.</span>
<span class="sd">    :param bool return_backward: will traverse RETURN links in the backward direction.</span>
<span class="sd">    :param bool input_work_forward: will traverse INPUT_WORK links in the forward direction.</span>
<span class="sd">    :param bool call_calc_backward: will traverse CALL_CALC links in the backward direction.</span>
<span class="sd">    :param bool call_work_backward: will traverse CALL_WORK links in the backward direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">traverse_links</span> <span class="o">=</span> <span class="n">validate_traversal_rules</span><span class="p">(</span><span class="n">GraphTraversalRules</span><span class="o">.</span><span class="n">EXPORT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">traverse_output</span> <span class="o">=</span> <span class="n">traverse_graph</span><span class="p">(</span>
        <span class="n">starting_pks</span><span class="p">,</span>
        <span class="n">get_links</span><span class="o">=</span><span class="n">get_links</span><span class="p">,</span>
        <span class="n">links_forward</span><span class="o">=</span><span class="n">traverse_links</span><span class="p">[</span><span class="s1">&#39;forward&#39;</span><span class="p">],</span>
        <span class="n">links_backward</span><span class="o">=</span><span class="n">traverse_links</span><span class="p">[</span><span class="s1">&#39;backward&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">function_output</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="n">traverse_output</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">],</span>
        <span class="s1">&#39;links&#39;</span><span class="p">:</span> <span class="n">traverse_output</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">],</span>
        <span class="s1">&#39;rules&#39;</span><span class="p">:</span> <span class="n">traverse_links</span><span class="p">[</span><span class="s1">&#39;rules_applied&#39;</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">function_output</span></div>


<div class="viewcode-block" id="validate_traversal_rules"><a class="viewcode-back" href="../../../../apidoc/aiida.tools.graph.html#aiida.tools.graph.graph_traversers.validate_traversal_rules">[docs]</a><span class="k">def</span> <span class="nf">validate_traversal_rules</span><span class="p">(</span><span class="n">ruleset</span><span class="o">=</span><span class="n">GraphTraversalRules</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validates the keywords with a ruleset template and returns a parsed dictionary</span>
<span class="sd">    ready to be used.</span>

<span class="sd">    :type ruleset: :py:class:`aiida.common.links.GraphTraversalRules`</span>
<span class="sd">    :param ruleset: Ruleset template used to validate the set of rules.</span>
<span class="sd">    :param bool input_calc_forward: will traverse INPUT_CALC links in the forward direction.</span>
<span class="sd">    :param bool input_calc_backward: will traverse INPUT_CALC links in the backward direction.</span>
<span class="sd">    :param bool create_forward: will traverse CREATE links in the forward direction.</span>
<span class="sd">    :param bool create_backward: will traverse CREATE links in the backward direction.</span>
<span class="sd">    :param bool return_forward: will traverse RETURN links in the forward direction.</span>
<span class="sd">    :param bool return_backward: will traverse RETURN links in the backward direction.</span>
<span class="sd">    :param bool input_work_forward: will traverse INPUT_WORK links in the forward direction.</span>
<span class="sd">    :param bool input_work_backward: will traverse INPUT_WORK links in the backward direction.</span>
<span class="sd">    :param bool call_calc_forward: will traverse CALL_CALC links in the forward direction.</span>
<span class="sd">    :param bool call_calc_backward: will traverse CALL_CALC links in the backward direction.</span>
<span class="sd">    :param bool call_work_forward: will traverse CALL_WORK links in the forward direction.</span>
<span class="sd">    :param bool call_work_backward: will traverse CALL_WORK links in the backward direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">exceptions</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ruleset</span><span class="p">,</span> <span class="n">GraphTraversalRules</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;ruleset input must be of type aiida.common.links.GraphTraversalRules</span><span class="se">\n</span><span class="s1">instead, it is: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">ruleset</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">rules_applied</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">links_forward</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">links_backward</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">ruleset</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="n">follow</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">default</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">rule</span><span class="o">.</span><span class="n">toggleable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;input rule </span><span class="si">{}</span><span class="s1"> is not toggleable for ruleset </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ruleset</span><span class="p">))</span>

            <span class="n">follow</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">follow</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the value of rule </span><span class="si">{}</span><span class="s1"> must be boolean, but it is: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">follow</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">follow</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span><span class="p">:</span>
                <span class="n">links_forward</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">link_type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rule</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span>
                <span class="n">links_backward</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">link_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InternalError</span><span class="p">(</span>
                    <span class="s1">&#39;unrecognized direction `</span><span class="si">{}</span><span class="s1">` for graph traversal rule&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">rules_applied</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">follow</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">error_message</span> <span class="o">=</span> <span class="s1">&#39;unrecognized keywords: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

    <span class="n">valid_output</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;rules_applied&#39;</span><span class="p">:</span> <span class="n">rules_applied</span><span class="p">,</span>
        <span class="s1">&#39;forward&#39;</span><span class="p">:</span> <span class="n">links_forward</span><span class="p">,</span>
        <span class="s1">&#39;backward&#39;</span><span class="p">:</span> <span class="n">links_backward</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">valid_output</span></div>


<div class="viewcode-block" id="traverse_graph"><a class="viewcode-back" href="../../../../apidoc/aiida.tools.graph.html#aiida.tools.graph.graph_traversers.traverse_graph">[docs]</a><span class="k">def</span> <span class="nf">traverse_graph</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">get_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">links_forward</span><span class="o">=</span><span class="p">(),</span> <span class="n">links_backward</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return the set of all nodes that can be connected</span>
<span class="sd">    to a list of initial nodes through any sequence of specified links.</span>
<span class="sd">    Optionally, it may also return the links that connect these nodes.</span>

<span class="sd">    :type starting_pks: list or tuple or set</span>
<span class="sd">    :param starting_pks: Contains the (valid) pks of the starting nodes.</span>

<span class="sd">    :type max_iterations: int or None</span>
<span class="sd">    :param max_iterations:</span>
<span class="sd">        The number of iterations to apply the set of rules (a value of &#39;None&#39; will</span>
<span class="sd">        iterate until no new nodes are added).</span>

<span class="sd">    :param bool get_links:</span>
<span class="sd">        Pass True to also return the links between all nodes (found + initial).</span>

<span class="sd">    :type links_forward: aiida.common.links.LinkType</span>
<span class="sd">    :param links_forward:</span>
<span class="sd">        List with all the links that should be traversed in the forward direction.</span>

<span class="sd">    :type links_backward: aiida.common.links.LinkType</span>
<span class="sd">    :param links_backward:</span>
<span class="sd">        List with all the links that should be traversed in the backward direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-locals,too-many-statements,too-many-branches</span>
    <span class="kn">from</span> <span class="nn">aiida</span> <span class="kn">import</span> <span class="n">orm</span>
    <span class="kn">from</span> <span class="nn">aiida.tools.graph.age_entities</span> <span class="kn">import</span> <span class="n">Basket</span>
    <span class="kn">from</span> <span class="nn">aiida.tools.graph.age_rules</span> <span class="kn">import</span> <span class="n">UpdateRule</span><span class="p">,</span> <span class="n">RuleSequence</span><span class="p">,</span> <span class="n">RuleSaveWalkers</span><span class="p">,</span> <span class="n">RuleSetWalkers</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">exceptions</span>

    <span class="k">if</span> <span class="n">max_iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="n">inf</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">max_iterations</span> <span class="ow">is</span> <span class="n">inf</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Max_iterations has to be an integer or infinity&#39;</span><span class="p">)</span>

    <span class="n">linktype_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">linktype</span> <span class="ow">in</span> <span class="n">links_forward</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linktype</span><span class="p">,</span> <span class="n">LinkType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;links_forward should contain links, but one of them is: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">linktype</span><span class="p">)))</span>
        <span class="n">linktype_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linktype</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">filters_forwards</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">linktype_list</span><span class="p">}}</span>

    <span class="n">linktype_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">linktype</span> <span class="ow">in</span> <span class="n">links_backward</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linktype</span><span class="p">,</span> <span class="n">LinkType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;links_backward should contain links, but one of them is: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">linktype</span><span class="p">)))</span>
        <span class="n">linktype_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linktype</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">filters_backwards</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">linktype_list</span><span class="p">}}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;starting_pks must be of type list, set or tuple</span><span class="se">\n</span><span class="s1">instead, it is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">)))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">starting_pks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">get_links</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(),</span> <span class="s1">&#39;links&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(),</span> <span class="s1">&#39;links&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">starting_pks</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;one of the starting_pks is not of type int:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">))</span>
    <span class="n">operational_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">starting_pks</span><span class="p">)</span>

    <span class="n">query_nodes</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">QueryBuilder</span><span class="p">()</span>
    <span class="n">query_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">operational_set</span><span class="p">}})</span>
    <span class="n">existing_pks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">query_nodes</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">missing_pks</span> <span class="o">=</span> <span class="n">operational_set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">existing_pks</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing_pks</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">NotExistent</span><span class="p">(</span>
            <span class="s1">&#39;The following pks are not in the database and must be pruned before this   call: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_pks</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">basket</span> <span class="o">=</span> <span class="n">Basket</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">operational_set</span><span class="p">)</span>

    <span class="c1"># When max_iterations is finite, the order of traversal may affect the result</span>
    <span class="c1"># (its not the same to first go backwards and then forwards than vice-versa)</span>
    <span class="c1"># In order to make it order-independent, the result of the first operation needs</span>
    <span class="c1"># to be stashed and the second operation must be performed only on the nodes</span>
    <span class="c1"># that were already in the set at the begining of the iteration: this way, both</span>
    <span class="c1"># rules are applied on the same set of nodes and the order doesn&#39;t matter.</span>
    <span class="c1"># The way to do this is saving and seting the walkers at the right moments only</span>
    <span class="c1"># when both forwards and backwards rules are present.</span>
    <span class="k">if</span> <span class="n">links_forward</span> <span class="ow">and</span> <span class="n">links_backward</span><span class="p">:</span>
        <span class="n">stash</span> <span class="o">=</span> <span class="n">basket</span><span class="o">.</span><span class="n">get_template</span><span class="p">()</span>
        <span class="n">rules</span> <span class="o">+=</span> <span class="p">[</span><span class="n">RuleSaveWalkers</span><span class="p">(</span><span class="n">stash</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">links_forward</span><span class="p">:</span>
        <span class="n">query_outgoing</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">query_outgoing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;sources&#39;</span><span class="p">)</span>
        <span class="n">query_outgoing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">edge_filters</span><span class="o">=</span><span class="n">filters_forwards</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;sources&#39;</span><span class="p">)</span>
        <span class="n">rule_outgoing</span> <span class="o">=</span> <span class="n">UpdateRule</span><span class="p">(</span><span class="n">query_outgoing</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">track_edges</span><span class="o">=</span><span class="n">get_links</span><span class="p">)</span>
        <span class="n">rules</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rule_outgoing</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">links_forward</span> <span class="ow">and</span> <span class="n">links_backward</span><span class="p">:</span>
        <span class="n">rules</span> <span class="o">+=</span> <span class="p">[</span><span class="n">RuleSetWalkers</span><span class="p">(</span><span class="n">stash</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">links_backward</span><span class="p">:</span>
        <span class="n">query_incoming</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">query_incoming</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;sources&#39;</span><span class="p">)</span>
        <span class="n">query_incoming</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orm</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="n">edge_filters</span><span class="o">=</span><span class="n">filters_backwards</span><span class="p">,</span> <span class="n">with_outgoing</span><span class="o">=</span><span class="s1">&#39;sources&#39;</span><span class="p">)</span>
        <span class="n">rule_incoming</span> <span class="o">=</span> <span class="n">UpdateRule</span><span class="p">(</span><span class="n">query_incoming</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">track_edges</span><span class="o">=</span><span class="n">get_links</span><span class="p">)</span>
        <span class="n">rules</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rule_incoming</span><span class="p">]</span>

    <span class="n">rulesequence</span> <span class="o">=</span> <span class="n">RuleSequence</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="n">max_iterations</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">rulesequence</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">basket</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keyset</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">get_links</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;nodes_nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keyset</span>

    <span class="k">return</span> <span class="n">output</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>