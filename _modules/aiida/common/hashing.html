

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.common.hashing &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/togglebutton.js"></script>
        <script src="../../../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.common.hashing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.common.hashing</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida-core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Common password and hash generation functions.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="k">try</span><span class="p">:</span>  <span class="c1"># Python &gt; 3.5</span>
    <span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># Python 3.5</span>
    <span class="kn">from</span> <span class="nn">pyblake2</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">abc</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">singledispatch</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">import</span> <span class="nn">pytz</span>

<span class="kn">from</span> <span class="nn">aiida.common.constants</span> <span class="kn">import</span> <span class="n">AIIDA_FLOAT_PRECISION</span>
<span class="kn">from</span> <span class="nn">.folders</span> <span class="kn">import</span> <span class="n">Folder</span>

<span class="c1"># The prefix of the hashed using pbkdf2_sha256 algorithm in Django</span>
<span class="n">HASHING_PREFIX_DJANGO</span> <span class="o">=</span> <span class="s1">&#39;pbkdf2_sha256&#39;</span>
<span class="c1"># The prefix of the hashed using pbkdf2_sha256 algorithm in Passlib</span>
<span class="n">HASHING_PREFIX_PBKDF2_SHA256</span> <span class="o">=</span> <span class="s1">&#39;$pbkdf2-sha256&#39;</span>

<span class="c1"># This will never be a valid encoded hash</span>
<span class="n">UNUSABLE_PASSWORD_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;!&#39;</span>  <span class="c1"># noqa</span>
<span class="c1"># Number of random chars to add after UNUSABLE_PASSWORD_PREFIX</span>
<span class="n">UNUSABLE_PASSWORD_SUFFIX_LENGTH</span> <span class="o">=</span> <span class="mi">40</span>

<span class="n">HASHING_KEY</span> <span class="o">=</span> <span class="s1">&#39;HashingKey&#39;</span>

<span class="c1"># The key that is used to store the hash in the node extras</span>
<span class="n">_HASH_EXTRA_KEY</span> <span class="o">=</span> <span class="s1">&#39;_aiida_hash&#39;</span>

<span class="c1">###################################################################</span>
<span class="c1"># THE FOLLOWING WAS TAKEN FROM DJANGO BUT IT CAN BE EASILY REPLACED</span>
<span class="c1">###################################################################</span>

<span class="c1"># Use the system PRNG if possible</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">random</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">SystemRandom</span><span class="p">()</span>
    <span class="n">using_sysrandom</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;A secure pseudo-random number generator is not available. Falling back to Mersenne Twister.&#39;</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>
    <span class="n">using_sysrandom</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># pylint: disable=invalid-name</span>


<div class="viewcode-block" id="get_random_string"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.hashing.get_random_string">[docs]</a><span class="k">def</span> <span class="nf">get_random_string</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">allowed_chars</span><span class="o">=</span><span class="s1">&#39;abcdefghijklmnopqrstuvwxyz&#39;</span> <span class="s1">&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a securely generated random string.</span>

<span class="sd">    The default length of 12 with the a-z, A-Z, 0-9 character set returns</span>
<span class="sd">    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">using_sysrandom</span><span class="p">:</span>
        <span class="c1"># This is ugly, and a hack, but it makes things better than</span>
        <span class="c1"># the alternative of predictability. This re-seeds the PRNG</span>
        <span class="c1"># using a value that is hard for an attacker to predict, every</span>
        <span class="c1"># time a random string is required. This may change the</span>
        <span class="c1"># properties of the chosen random sequence slightly, but this</span>
        <span class="c1"># is better than absolute predictability.</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">%s%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">getstate</span><span class="p">(),</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="n">HASHING_KEY</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">allowed_chars</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">))</span></div>


<span class="n">BLAKE2B_OPTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;fanout&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># unlimited fanout/depth mode</span>
    <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># has fixed depth of 2</span>
    <span class="s1">&#39;digest_size&#39;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span>  <span class="c1"># we do not need a cryptographically relevant digest</span>
    <span class="s1">&#39;inner_size&#39;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span>  <span class="c1"># ... but still use 64 as the inner size</span>
<span class="p">}</span>


<div class="viewcode-block" id="make_hash"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.hashing.make_hash">[docs]</a><span class="k">def</span> <span class="nf">make_hash</span><span class="p">(</span><span class="n">object_to_hash</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a hash from a dictionary, list, tuple or set to any level, that contains</span>
<span class="sd">    only other hashable or nonhashable types (including lists, tuples, sets, and</span>
<span class="sd">    dictionaries).</span>

<span class="sd">    :param object_to_hash: the object to hash</span>

<span class="sd">    :returns: a unique hash</span>

<span class="sd">    There are a lot of modules providing functionalities to create unique</span>
<span class="sd">    hashes for hashable values.</span>
<span class="sd">    However, getting hashes for nonhashable items like sets or dictionaries is</span>
<span class="sd">    not easily doable because order is not fixed.</span>
<span class="sd">    This leads to the peril of getting different hashes for the same</span>
<span class="sd">    dictionary.</span>

<span class="sd">    This function avoids this by recursing through nonhashable items and</span>
<span class="sd">    hashing iteratively. Uses python&#39;s sorted function to sort unsorted</span>
<span class="sd">    sets and dictionaries by sorting the hashed keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hashes</span> <span class="o">=</span> <span class="n">_make_hash</span><span class="p">(</span><span class="n">object_to_hash</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># pylint: disable=assignment-from-no-return</span>

    <span class="c1"># use the Unlimited fanout hashing protocol outlined in</span>
    <span class="c1">#   https://blake2.net/blake2_20130129.pdf</span>
    <span class="n">final_hash</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">node_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">BLAKE2B_OPTIONS</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">hashes</span><span class="p">:</span>
        <span class="n">final_hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>

    <span class="c1"># add an empty last leaf node</span>
    <span class="n">final_hash</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blake2b</span><span class="p">(</span><span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">BLAKE2B_OPTIONS</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">final_hash</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>


<div class="viewcode-block" id="_make_hash"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.hashing._make_hash">[docs]</a><span class="nd">@singledispatch</span>
<span class="k">def</span> <span class="nf">_make_hash</span><span class="p">(</span><span class="n">object_to_hash</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the ``make_hash`` function. The hash is created as a</span>
<span class="sd">    28 byte integer, and only later converted to a string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of type </span><span class="si">{}</span><span class="s1"> cannot be hashed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">object_to_hash</span><span class="p">)))</span></div>


<div class="viewcode-block" id="_single_digest"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.hashing._single_digest">[docs]</a><span class="k">def</span> <span class="nf">_single_digest</span><span class="p">(</span><span class="n">obj_type</span><span class="p">,</span> <span class="n">obj_bytes</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">obj_bytes</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">obj_type</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">BLAKE2B_OPTIONS</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span></div>


<span class="n">_END_DIGEST</span> <span class="o">=</span> <span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">bytes_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hash arbitrary byte strings.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">,</span> <span class="n">bytes_obj</span><span class="p">)]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert strings explicitly to bytes.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">sequence_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># unpack the list and use the elements</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;list(&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">_make_hash</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sequence_obj</span><span class="p">)</span>
                                           <span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">_END_DIGEST</span><span class="p">]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">set_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># turn the set objects into a list of hashes which are always sortable,</span>
    <span class="c1"># then return a flattened list of the hashes</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;set(&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_make_hash</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">set_obj</span><span class="p">))</span>
                                          <span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">_END_DIGEST</span><span class="p">]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hashing arbitrary mapping containers (dict, OrderedDict) by first sorting by hashed keys&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">hashed_key_mapping</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">_make_hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;dict(&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="p">(</span><span class="n">k_digest</span> <span class="o">+</span> <span class="n">_make_hash</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">k_digest</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hashed_key_mapping</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">_END_DIGEST</span><span class="p">]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hashing of OrderedDicts</span>

<span class="sd">    :param odict_as_unordered: hash OrderedDicts as normal dicts (mostly for testing)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;odict_as_unordered&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_make_hash</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">](</span><span class="n">mapping</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">([</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;odict(&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="n">_make_hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">_make_hash</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">_END_DIGEST</span><span class="p">])</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Before hashing a float, convert to a string (via rounding) and with a fixed number of digits after the comma.</span>
<span class="sd">    Note that the `_singe_digest` requires a bytes object so we need to encode the utf-8 string first</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">float_to_text</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="n">AIIDA_FLOAT_PRECISION</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Complex</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    In case of a complex number, use the same encoding of two floats and join them with a special symbol (a ! here).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">_single_digest</span><span class="p">(</span>
            <span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">!</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">float_to_text</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="n">AIIDA_FLOAT_PRECISION</span><span class="p">),</span> <span class="n">float_to_text</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="n">AIIDA_FLOAT_PRECISION</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;get the hash of the little-endian signed long long representation of the integer&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">val</span> <span class="k">else</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;hashes the little-endian rep of the float &lt;epoch-seconds&gt;.&lt;subseconds&gt;&quot;&quot;&quot;</span>
    <span class="c1"># see also https://stackoverflow.com/a/8778548 for an excellent elaboration</span>
    <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">val</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="n">float_to_text</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="n">AIIDA_FLOAT_PRECISION</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hashes the string representation in ISO format of the `datetime.date` object.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))]</span>


<span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;uuid&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">bytes</span><span class="p">)]</span>


<div class="viewcode-block" id="_"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.hashing._">[docs]</a><span class="nd">@_make_hash</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Folder</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hash the content of a Folder object. The name of the folder itself is actually ignored</span>
<span class="sd">    :param ignored_folder_content: list of filenames to be ignored for the hashing</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ignored_folder_content</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ignored_folder_content&#39;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">folder_digests</span><span class="p">(</span><span class="n">subfolder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;traverses the given folder and yields digests for the contained objects&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">isfile</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">subfolder</span><span class="o">.</span><span class="n">get_content_list</span><span class="p">(</span><span class="n">only_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ignored_folder_content</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">isfile</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
                <span class="k">with</span> <span class="n">subfolder</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;fcontent&#39;</span><span class="p">,</span> <span class="n">fhandle</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;dir(&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">digest</span> <span class="ow">in</span> <span class="n">folder_digests</span><span class="p">(</span><span class="n">subfolder</span><span class="o">.</span><span class="n">get_subfolder</span><span class="p">(</span><span class="n">name</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">digest</span>
                <span class="k">yield</span> <span class="n">_END_DIGEST</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">_single_digest</span><span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">folder_digests</span><span class="p">(</span><span class="n">folder</span><span class="p">))</span></div>


<div class="viewcode-block" id="float_to_text"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.hashing.float_to_text">[docs]</a><span class="k">def</span> <span class="nf">float_to_text</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert float to text string for computing hash.</span>
<span class="sd">    Preseve up to N significant number given by sig.</span>

<span class="sd">    :param value: the float value to convert</span>
<span class="sd">    :param sig: choose how many digits after the comma should be output</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;{{:.</span><span class="si">{}</span><span class="s1">g}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>