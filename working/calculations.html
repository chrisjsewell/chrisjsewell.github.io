

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Application &mdash; AiiDA 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/togglebutton.js"></script>
        <script src="../_static/contentui.js"></script>
        <script >var togglebuttonSelector = '.toggle';</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro/about.html">What is AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/installation.html">Advanced Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">How-To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../howto/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topics/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Plugins</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../plugins/placeholder.html">Placeholder</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../development/placeholder.html">Placeholder</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Application</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/working/calculations.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="application">
<span id="working-calculations"></span><h1>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h1>
<p>A calculation is a process (see the <a class="reference internal" href="../concepts/processes.html#concepts-processes"><span class="std std-ref">process section</span></a> for details) that <em>creates</em> new data.
Currently, there are two ways of implementing a calculation process:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#working-calcfunctions"><span class="std std-ref">calculation function</span></a></p></li>
<li><p><a class="reference internal" href="#working-calcjobs"><span class="std std-ref">calculation job</span></a></p></li>
</ul>
</div></blockquote>
<p>This section will provide detailed information and best practices on how to implement these two calculation types.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This chapter assumes that the basic concept and difference between calculation functions and calculation jobs is known and when one should use on or the other.
It is therefore crucial that, before you continue, you have read and understood the basic concept of <a class="reference internal" href="../concepts/calculations.html#concepts-calculations"><span class="std std-ref">calculation processes</span></a>.</p>
</div>
<div class="section" id="calculation-functions">
<span id="working-calcfunctions"></span><h2>Calculation functions<a class="headerlink" href="#calculation-functions" title="Permalink to this headline">¶</a></h2>
<p>The section on the <a class="reference internal" href="../concepts/calculations.html#concepts-calcfunctions"><span class="std std-ref">concept of calculation functions</span></a> already addressed their aim: automatic recording of their execution with their inputs and outputs in the provenance graph.
The <a class="reference internal" href="functions.html#working-process-functions"><span class="std std-ref">section on process functions</span></a> subsequently detailed the rules that apply when implementing them, all of which to calculation functions, which are a sub type, just like work functions.
However, there are some differences given that calculation functions are ‘calculation’-like processes and work function behave like ‘workflow’-like processes.
What this entails in terms of intended usage and limitations for calculation functions is the scope of this section.</p>
<div class="section" id="creating-data">
<h3>Creating data<a class="headerlink" href="#creating-data" title="Permalink to this headline">¶</a></h3>
<p>It has been said many times before: calculation functions, like all ‘calculation’-like processes, <cite>create</cite> data, but what does <cite>create</cite> mean exactly?
In this context, the term ‘create’ is not intended to refer to the simple creation of a new data node in the graph, in an interactive shell or a script for example.
But rather it indicates the creation of a new piece of data from some other data through a computation implemented by a process.
This is then exactly what the calculation function does.
It takes one or more data nodes as inputs and returns one or more data nodes as outputs, whose content is based on those inputs.
As explained in the <a class="reference internal" href="functions.html#working-process-functions"><span class="std std-ref">technical section</span></a>, outputs are created simply by returning the nodes from the function.
The engine will inspect the return value from the function and attach the output nodes to the calculation node that represents the calculation function.
To verify that the output nodes are in fact ‘created’, the engine will check that the nodes are not stored.
Therefore, it is very important that you <strong>do not store the nodes you create yourself</strong>, or the engine will raise an exception, as shown in the following example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">calcfunction</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">Int</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Because the returned node is already stored, the engine will raise the following exception:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ValueError: trying to <span class="k">return</span> an already stored Data node from a @calcfunction, however, @calcfunctions cannot <span class="k">return</span> data.
If you stored the node yourself, simply <span class="k">do</span> not call <span class="sb">`</span>store<span class="o">()</span><span class="sb">`</span> yourself.
If you want to <span class="k">return</span> an input node, use a @workfunction instead.
</pre></div>
</div>
<p>The reason for this strictness is that a node that was stored after being created in the function body, is indistinguishable from a node that was already stored and had simply been loaded in the function body and returned, e.g.:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">calcfunction</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">Int</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">load_node</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The loaded node would also have gotten a <cite>create</cite> link from the calculation function, even though it was not really created by it at all.
It is exactly to prevent this ambiguity that calculation functions require all returned output nodes to be <em>unstored</em>.</p>
<p>Note that work functions have exactly the opposite required and all the outputs that it returns <strong>have to be stored</strong>, because as a ‘workflow’-like process, it <em>cannot</em> create new data.
For more details refer to the <a class="reference internal" href="workflows.html#working-workfunctions"><span class="std std-ref">work function section</span></a>.</p>
</div>
</div>
<div class="section" id="calculation-jobs">
<span id="working-calcjobs"></span><h2>Calculation jobs<a class="headerlink" href="#calculation-jobs" title="Permalink to this headline">¶</a></h2>
<p>To explain how a calculation job can be implemented, we will continue with the example presented in the section on the <a class="reference internal" href="../concepts/calculations.html#concepts-calcjobs"><span class="std std-ref">concept of the calculation job</span></a>.
There we described a code that adds two integers, implemented as a simple bash script, and how the <a class="reference internal" href="../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.calcjob.CalcJob" title="aiida.engine.processes.calcjobs.calcjob.CalcJob"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcJob</span></code></a> class can be used to run this code through AiiDA.
Since it is a sub class of the <a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.process.Process" title="aiida.engine.processes.process.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> class, it shares all its properties.
It will be very valuable to have read the section on working with <a class="reference internal" href="processes.html#working-processes"><span class="std std-ref">generic processes</span></a> before continuing, because all the concepts explained there will apply also to calculation jobs.</p>
<div class="section" id="define">
<span id="working-calcjobs-define"></span><h3>Define<a class="headerlink" href="#define" title="Permalink to this headline">¶</a></h3>
<p>To implement a calculation job, one simply sub classes the <a class="reference internal" href="../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.calcjob.CalcJob" title="aiida.engine.processes.calcjobs.calcjob.CalcJob"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcJob</span></code></a> process class and implements the <a class="reference internal" href="../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.calcjob.CalcJob.define" title="aiida.engine.processes.calcjobs.calcjob.CalcJob.define"><code class="xref py py-meth docutils literal notranslate"><span class="pre">define()</span></code></a> method.
You can pick any name that is a valid python class name.
The most important method of the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> class, is the <code class="docutils literal notranslate"><span class="pre">define</span></code> class method.
Here you define, what inputs it takes and what outputs it will generate.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">CalcJob</span>

<span class="k">class</span> <span class="nc">ArithmeticAddCalculation</span><span class="p">(</span><span class="n">CalcJob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implementation of CalcJob to add two numbers for testing and demonstration purposes.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The left operand.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The right operand.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As the snippet above demonstrates, the class method takes two arguments:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cls</span></code> this is the reference of the class itself and is mandatory for any class method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spec</span></code> which is the ‘specification’</p></li>
</ul>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not forget to add the line <code class="docutils literal notranslate"><span class="pre">super().define(spec)</span></code> as the first line of the <code class="docutils literal notranslate"><span class="pre">define</span></code> method, where you replace the class name with the name of your calculation job.
This will call the <code class="docutils literal notranslate"><span class="pre">define</span></code> method of the parent class, which is necessary for the calculation job to work properly</p>
</div>
<p>As the name suggests, the <code class="docutils literal notranslate"><span class="pre">spec</span></code> can be used to specify the properties of the calculation job.
For example, it can be used to define inputs that the calculation job takes.
In our example, we need to be able to pass two integers as input, so we define those in the spec by calling <code class="docutils literal notranslate"><span class="pre">spec.input()</span></code>.
The first argument is the name of the input.
This name should be used later to specify the inputs when launching the calculation job and it will also be used as the label for link to connect the data node and the calculation node in the provenance graph.
Additionally, as we have done here, you can specify which types are valid for that particular input.
Since we expect integers, we specify that the valid type is the database storable <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.int.Int" title="aiida.orm.nodes.data.int.Int"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since we sub class from <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> and call its <code class="docutils literal notranslate"><span class="pre">define</span></code> method, it will inherit the ports that it declares as well.
If you look at the implementation, you will find that the base class <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> already defines an input <code class="docutils literal notranslate"><span class="pre">code</span></code> that takes a <code class="docutils literal notranslate"><span class="pre">Code</span></code> instance.
This will reference the code that the user wants to run when he launches the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code>.
For this reason, you <strong>do not</strong> again have to declare this input.</p>
</div>
<p>Next we should define what outputs we expect the calculation to produce:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">CalcJob</span>

<span class="k">class</span> <span class="nc">ArithmeticAddCalculation</span><span class="p">(</span><span class="n">CalcJob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implementation of CalcJob to add two numbers for testing and demonstration purposes.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The left operand.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The right operand.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The sum of the left and right operand.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Just as for the inputs, one can specify what node type each output should have.
By default a defined output will be ‘required’, which means that if the calculation job terminates and the output has not been attached, the process will be marked as failed.
To indicate that an output is optional, one can use <code class="docutils literal notranslate"><span class="pre">required=False</span></code> in the <code class="docutils literal notranslate"><span class="pre">spec.output</span></code> call.
Note that the process spec, and its <a class="reference external" href="https://plumpy.readthedocs.io/en/latest/apidoc/plumpy.html#plumpy.ProcessSpec.input" title="(in plumpy v0.14)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">input()</span></code></a> and <a class="reference external" href="https://plumpy.readthedocs.io/en/latest/apidoc/plumpy.html#plumpy.ProcessSpec.output" title="(in plumpy v0.14)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">output()</span></code></a> methods provide a lot more functionality.
Fore more details, please refer to the section on <a class="reference internal" href="processes.html#working-processes-spec"><span class="std std-ref">process specifications</span></a>.</p>
</div>
<div class="section" id="prepare">
<span id="working-calcjobs-prepare"></span><h3>Prepare<a class="headerlink" href="#prepare" title="Permalink to this headline">¶</a></h3>
<p>We have know defined through the process specification, what inputs the calculation job expects and what outputs it will create.
The final remaining task is to instruct the engine how the calculation job should actually be run.
To understand what the engine would have to do to accomplish this, let’s consider what one typically does when manually preparing to run a computing job through a scheduler:</p>
<blockquote>
<div><ul class="simple">
<li><p>Prepare a working directory in some scratch space on the machine where the job will run</p></li>
<li><p>Create the raw input files required by the executable</p></li>
<li><p>Create a launch script containing scheduler directives, loading of environment variables and finally calling the executable with certain command line parameters.</p></li>
</ul>
</div></blockquote>
<p>So all we need to do now is instruct the engine how to accomplish these things for a specific calculation job.
Since these instructions will be calculation dependent, we will implement this with the <a class="reference internal" href="../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission" title="aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prepare_for_submission()</span></code></a> method.
The implementation of the <code class="docutils literal notranslate"><span class="pre">ArithmeticAddCalculation</span></code> that we are considering in the example looks like the following:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.common.datastructures</span> <span class="kn">import</span> <span class="n">CalcInfo</span><span class="p">,</span> <span class="n">CodeInfo</span>
<span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">CalcJob</span>

<span class="k">class</span> <span class="nc">ArithmeticAddCalculation</span><span class="p">(</span><span class="n">CalcJob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implementation of CalcJob to add two numbers for testing and demonstration purposes.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The left operand.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The right operand.&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">valid_type</span><span class="o">=</span><span class="n">orm</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The sum of the left and right operand.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare_for_submission</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the input files that are required for the code to run.</span>

<span class="sd">        :param folder: an `~aiida.common.folders.Folder` to temporarily write files on disk</span>
<span class="sd">        :return: `~aiida.common.datastructures.CalcInfo` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">x</span>
        <span class="n">input_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># Write the input file based on the inputs that were passed</span>
        <span class="k">with</span> <span class="n">folder</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">input_filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">input_y</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

        <span class="n">codeinfo</span> <span class="o">=</span> <span class="n">CodeInfo</span><span class="p">()</span>
        <span class="n">codeinfo</span><span class="o">.</span><span class="n">code_uuid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">uuid</span>
        <span class="n">codeinfo</span><span class="o">.</span><span class="n">stdout_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">output_filename</span>
        <span class="n">codeinfo</span><span class="o">.</span><span class="n">cmdline_params</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;-in&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">input_filename</span><span class="p">]</span>

        <span class="n">calcinfo</span> <span class="o">=</span> <span class="n">CalcInfo</span><span class="p">()</span>
        <span class="n">calcinfo</span><span class="o">.</span><span class="n">codes_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">codeinfo</span><span class="p">]</span>
        <span class="n">calcinfo</span><span class="o">.</span><span class="n">local_copy_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">calcinfo</span><span class="o">.</span><span class="n">remote_copy_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">calcinfo</span><span class="o">.</span><span class="n">retrieve_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">calcinfo</span>
</pre></div>
</div>
<p>Before we go into the code line-by-line, let’s describe the big picture of what is happening here.
The goal of this method is to help the engine accomplish the three steps required for preparing the submission a calculation job, as described above.
The raw input files that are required can be written to a sandbox folder that is passed in as the <code class="docutils literal notranslate"><span class="pre">folder</span></code> argument.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">folder</span></code> argument points to a temporary sandbox folder on the local file system that can be used to write the input files to.
After the <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> method returns, the engine will take those contents and copy them to the working directory where the calculation will be run.
On top of that, these files will also be written to the file repository of the node that represents the calculation as an additional measure of provenance.
Even though the information written there should be a derivation of the contents of the nodes that were passed as input nodes, since it is a derived form we store this explicitly nonetheless.
Sometimes, this behavior is undesirable, for example for efficiency or data privacy reasons, so it can be controlled with various lists such as <a class="reference internal" href="#working-calcjobs-file-lists-local-copy"><span class="std std-ref">local_copy_list</span></a> and <a class="reference internal" href="#working-calcjobs-file-lists-provenance-exclude"><span class="std std-ref">provenance_exclude_list</span></a>.</p>
</div>
<p>All the other required information, such as the directives of which files to copy and what command line options to use are defined through the <a class="reference internal" href="../apidoc/aiida.common.html#aiida.common.datastructures.CalcInfo" title="aiida.common.datastructures.CalcInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcInfo</span></code></a> datastructure, which should be returned from the method as the only value.
In principle, this is what one <strong>should do</strong> in the <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> method:</p>
<blockquote>
<div><ul class="simple">
<li><p>Writing raw inputs files required for the calculation to run to the <code class="docutils literal notranslate"><span class="pre">folder</span></code> sandbox folder.</p></li>
<li><p>Use a <code class="docutils literal notranslate"><span class="pre">CalcInfo</span></code> to instruct the engine which files to copy to the working directory</p></li>
<li><p>Use a <code class="docutils literal notranslate"><span class="pre">CalcInfo</span></code> to tell which codes should run, using which command line parameters, such as standard input and output redirection.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> does not have to write the submission script itself.
The engine will know how to do this, because the codes that are to be used have been configured on a specific computer, which defines what scheduler is to be used.
This gives the engine all the necessary information on how to write the launch script such as what scheduler directives to write.</p>
</div>
<p>Now that we know what the <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> is expected to do, let’s see how the implementation of the <code class="docutils literal notranslate"><span class="pre">ArithmeticAddCalculation</span></code> accomplishes it line-by-line.
The input file required for this example calculation will consist of the two integers that are passed as inputs.
The <code class="docutils literal notranslate"><span class="pre">self.inputs</span></code> attribute returns an attribute dictionary with the parsed and validated inputs, according to the process specification defined in the <code class="docutils literal notranslate"><span class="pre">define</span></code> method.
This means that you do not have to validate the inputs yourself.
That is to say, if an input is marked as required and of a certain type, by the time we get to the <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> it is guaranteed that the dictionary returned by <code class="docutils literal notranslate"><span class="pre">self.inputs</span></code> will contain that input and of the correct type.</p>
<p>From the two inputs <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> that will have been passed when the calculation job was launched, we should now generate the input file, that is simply a text file with these two numbers on a single line, separated by a space.
We accomplish this by opening a filehandle to the input file in the sandbox folder and write the values of the two <code class="docutils literal notranslate"><span class="pre">Int</span></code> nodes to the file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The format of this input file just so happens to be the format that the <a class="reference internal" href="../concepts/calculations.html#concepts-calcjobs"><span class="std std-ref">bash script</span></a> expects that we are using in this example.
The exact number of input files and their content will of course depend on the code for which the calculation job is being written.</p>
</div>
<p>With the input file written, we now have to create an instance of <a class="reference internal" href="../apidoc/aiida.common.html#aiida.common.datastructures.CalcInfo" title="aiida.common.datastructures.CalcInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcInfo</span></code></a> that should be returned from the method.
This data structure will instruct the engine exactly what needs to be done to execute the code, such as what files should be copied to the remote computer where the code will be executed.
In this simple example, we define four simple attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">codes_info</span></code>: a list of <a class="reference internal" href="../apidoc/aiida.common.html#aiida.common.datastructures.CodeInfo" title="aiida.common.datastructures.CodeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodeInfo</span></code></a> datastructures, that tell which codes to run consecutively during the job</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_copy_list</span></code>: a list of tuples that instruct what files to copy to the working directory from the local machine</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">remote_copy_list</span></code>: a list of tuples that instruct what files to copy to the working directory from the machine on which the job will run</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">retrieve_list</span></code>: a list of tuples instructing which files should be retrieved from the working directory and stored in the local repository after the job has finished</p></li>
</ul>
</div></blockquote>
<p>In this example we only need to run a single code, so the <code class="docutils literal notranslate"><span class="pre">codes_info</span></code> list has a single <code class="docutils literal notranslate"><span class="pre">CodeInfo</span></code> datastructure.
This datastructure needs to define which code it needs to run, which is one of the inputs passed to the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code>, and does so by means of its UUID.
Through the <code class="docutils literal notranslate"><span class="pre">stdout_name</span></code> attribute, we tell the engine where the output of the executable should be redirected to.
In this example this is set to the value of the  <code class="docutils literal notranslate"><span class="pre">output_filename</span></code> option.
What options are available in calculation jobs, what they do and how they can be set will be explained in the <a class="reference internal" href="#working-calcjobs-options"><span class="std std-ref">section on options</span></a>.
Finally, the <code class="docutils literal notranslate"><span class="pre">cmdline_params</span></code> attribute takes a list with command line parameters that will be placed <em>after</em> the executable in the launch script.
Here we use it to explicitly instruct the executable to read its input from the filename stored in the option <code class="docutils literal notranslate"><span class="pre">input_filename</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since we instruct the executable should read the input from <code class="docutils literal notranslate"><span class="pre">self.options.input_filename</span></code>, this is also the filename we used when writing that very input file in the sandbox folder.</p>
</div>
<p>Finally, we have to define the various “file lists” that tell what files to copy from where to where and what files to retrieve.
Here we will briefly describe their intended goals.
The implementation details will be described in full in the <a class="reference internal" href="#working-calcjobs-file-lists"><span class="std std-ref">file lists section</span></a>.</p>
<p>The local copy list is useful to instruct the engine to copy over files that you might already have stored in your database, such as instances of <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.singlefile.SinglefileData" title="aiida.orm.nodes.data.singlefile.SinglefileData"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglefileData</span></code></a> nodes, that you can define and pass as inputs of the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code>.
You could have of course many copied their content to the <code class="docutils literal notranslate"><span class="pre">folder</span></code> sandbox folder, which will also have caused them to be written to the working directory.
The disadvantage of that method, however, is that all the contents written to the sandbox folder will also be stored in the repository of the <code class="docutils literal notranslate"><span class="pre">CalcJobNode</span></code> that will represent the execution of the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> in the provenance graph.
This will cause duplication of the data contained within these data nodes.
By not writing them explicitly to the sandbox folder, you avoid this duplication, without losing provenance, because the data node itself will of course be recorded in the provenance graph.</p>
<p>The remote copy list is useful to avoid unnecessary file transfers between the machine where the engine runs and where the calculation jobs are executed.
For example, imagine you have already completed a calculation job on a remote cluster and now want to launch a second one, that requires some of the output files of the first run as its inputs.
The remote copy list allows you to specify exactly what output files to copy to the remote working directory, without them having to be retrieved to the engine’s machine in between.</p>
<p>The retrieve list, finally, allows you to instruct the engine what files should be retrieved from the working directory after the job has terminated.
These files will be downloaded to the local machine, stored in a <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.folder.FolderData" title="aiida.orm.nodes.data.folder.FolderData"><code class="xref py py-class docutils literal notranslate"><span class="pre">FolderData</span></code></a> data node and attached as an output to the <code class="docutils literal notranslate"><span class="pre">CalcJobNode</span></code> with the link label <code class="docutils literal notranslate"><span class="pre">retrieved</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We didn’t explicitly define the <code class="docutils literal notranslate"><span class="pre">retrieved</span></code> folder data node as an output in the example <code class="docutils literal notranslate"><span class="pre">ArithmeticAddCalculation</span></code> implementation shown above.
This is because this is already defined by the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> base class.
Just as the <code class="docutils literal notranslate"><span class="pre">code</span></code> input, the <code class="docutils literal notranslate"><span class="pre">retrieved</span></code> output is common for all calculation job implementations.</p>
</div>
</div>
<div class="section" id="file-lists">
<span id="working-calcjobs-file-lists"></span><h3>File lists<a class="headerlink" href="#file-lists" title="Permalink to this headline">¶</a></h3>
<div class="section" id="local-copy-list">
<span id="working-calcjobs-file-lists-local-copy"></span><h4>Local copy list<a class="headerlink" href="#local-copy-list" title="Permalink to this headline">¶</a></h4>
<p>The local copy list takes tuples of length three, each of which represents a file to be copied, defined through the following items:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>node uuid</cite>: the node whose repository contains the file, typically a <code class="docutils literal notranslate"><span class="pre">SinglefileData</span></code> or <code class="docutils literal notranslate"><span class="pre">FolderData</span></code> node</p></li>
<li><p><cite>source relative path</cite>: the relative path of the file within the node repository</p></li>
<li><p><cite>target relative path</cite>: the relative path within the working directory to which to copy the file</p></li>
</ul>
</div></blockquote>
<p>As an example, consider a <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> implementation that receives a <code class="docutils literal notranslate"><span class="pre">SinglefileData</span></code> node as input with the name <code class="docutils literal notranslate"><span class="pre">pseudopotential</span></code>, to copy its contents one can specify:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">local_copy_list</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">pseudopotential</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">pseudopotential</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;pseudopotential.dat&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">SinglefileData</span></code> node only contains a single file by definition, the relative path of which is returned by the <code class="docutils literal notranslate"><span class="pre">filename</span></code> attribute.
If instead, you need to transfer a specific file from a <code class="docutils literal notranslate"><span class="pre">FolderData</span></code>, you can specify the explicit key of the file, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">local_copy_list</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">folder</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;internal/relative/path/file.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;relative/target/file.txt&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note that the filenames in the relative source and target path need not be the same.
This depends fully on how the files are stored in the node’s repository and what files need to be written to the working directory.</p>
<p>One might think what the purpose of the list is, when one could just as easily use normal the normal API to write the file to the <code class="docutils literal notranslate"><span class="pre">folder</span></code> sandbox folder.
It is true, that in this way the file will be copied to the working directory, however, then it will <em>also</em> be copied into the repository of the calculation node.
Since in this case it is merely a direct one-to-one copy of the file that is already part of one of the input nodes (in an unaltered form), this duplication is unnecessary and adds useless weight to the file repository.
Using the <code class="docutils literal notranslate"><span class="pre">local_copy_list</span></code> prevents this unnecessary duplication of file content.
It can also be used if the content of a particular input node is privacy sensitive and cannot be duplicated in the repository.</p>
</div>
<div class="section" id="provenance-exclude-list">
<span id="working-calcjobs-file-lists-provenance-exclude"></span><h4>Provenance exclude list<a class="headerlink" href="#provenance-exclude-list" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="#working-calcjobs-file-lists-local-copy"><span class="std std-ref">local_copy_list</span></a>  allows one to instruct the engine to write files from the input files to the working directory, without them <em>also</em> being copied to the file repository of the calculation node.
As discussed in the corresponding section, this is useful in order to avoid duplication or in case where the data of the nodes is proprietary or privacy sensitive and cannot be duplicated arbitrarily everywhere in the file repository.
However, the limitation of the <code class="docutils literal notranslate"><span class="pre">local_copy_list</span></code> is that the it can only target single files in its entirety and cannot be used for arbitrary files that are written to the <code class="docutils literal notranslate"><span class="pre">folder</span></code> sandbox folder.
To provide full control over what files from the <code class="docutils literal notranslate"><span class="pre">folder</span></code> are stored permanently in the calculation node file repository, the <code class="docutils literal notranslate"><span class="pre">provenance_exclude_list</span></code> is introduced.
This <a class="reference internal" href="../apidoc/aiida.common.html#aiida.common.datastructures.CalcInfo" title="aiida.common.datastructures.CalcInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcInfo</span></code></a> attribute is a list of filepaths, relative to the base path of the <code class="docutils literal notranslate"><span class="pre">folder</span></code> sandbox folder, which <em>are not stored</em> in the file repository.</p>
<p>Consider the following file structure as written by an implementation of <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> to the <code class="docutils literal notranslate"><span class="pre">folder</span></code> sandbox:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>├─ sub
│  ├─ file_b.txt
│  └─ personal.dat
├─ file_a.txt
└─ secret.key
</pre></div>
</div>
<p>Clearly, we do not want the <code class="docutils literal notranslate"><span class="pre">personal.dat</span></code> and <code class="docutils literal notranslate"><span class="pre">secret.key</span></code> files to end up permanently in the file repository.
This can be achieved by defining:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">provenance_exclude_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sub/personal.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;secret.key&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>With this specification, the final contents of the repository of the calculation node will contain:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>├─ sub
│  └─ file_b.txt
└─ file_a.txt
</pre></div>
</div>
</div>
<div class="section" id="remote-copy-list">
<span id="working-calcjobs-file-lists-remote-copy"></span><h4>Remote copy list<a class="headerlink" href="#remote-copy-list" title="Permalink to this headline">¶</a></h4>
<p>The remote copy list takes tuples of length three, each of which represents a file to be copied on the remote machine where the calculation will run, defined through the following items:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>computer uuid</cite>: this is the UUID of the <code class="docutils literal notranslate"><span class="pre">Computer</span></code> on which the source file resides. For now the remote copy list can only copy files on the same machine where the job will run.</p></li>
<li><p><cite>source absolute path</cite>: the absolute path of the source file on the remote machine</p></li>
<li><p><cite>target relative path</cite>: the relative path within the working directory to which to copy the file</p></li>
</ul>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">remote_copy_list</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">parent_folder</span><span class="o">.</span><span class="n">computer</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;output_folder&#39;</span><span class="p">,</span> <span class="s1">&#39;restart_folder&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note that the source path can point to a directory, in which case its contents will be recursively copied in its entirety.</p>
</div>
<div class="section" id="retrieve-list">
<span id="working-calcjobs-file-lists-retrieve"></span><h4>Retrieve list<a class="headerlink" href="#retrieve-list" title="Permalink to this headline">¶</a></h4>
<p>The retrieve list supports various formats to define what files should be retrieved.
The simplest is retrieving a single file, whose filename you know before hand and you simply want to copy with the same name in the retrieved folder.
Imagine you want to retrieve the files <code class="docutils literal notranslate"><span class="pre">output1.out</span></code> and <code class="docutils literal notranslate"><span class="pre">output_folder/output2.out</span></code> you would simply add them as strings to the retrieve list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">retrieve_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;output1.out&#39;</span><span class="p">,</span> <span class="s1">&#39;output_folder/output2.out&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The retrieved files will be copied over keeping the exact names and hierarchy.
If you require more control over the hierarchy and nesting, you can use tuples of length three instead, with the following items:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>source relative path</cite>: the relative path, with respect to the working directory on the remote, of the file or directory to retrieve</p></li>
<li><p><cite>target relative path</cite>: the relative path where to copy the files locally in the retrieved folder. The string <cite>‘.’</cite> indicates the top level in the retrieved folder.</p></li>
<li><p><cite>depth</cite>: the number of levels of nesting in the folder hierarchy to maintain when copying, starting from the deepest file</p></li>
</ul>
</div></blockquote>
<p>For example, imagine the calculation will have written a file in the remote working directory with the folder hierarchy <code class="docutils literal notranslate"><span class="pre">some/remote/path/files/output.dat</span></code>.
If you want to copy the file, with the final resulting path <code class="docutils literal notranslate"><span class="pre">path/files/output.dat</span></code>, you would specify:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">retrieve_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;some/remote/path/files/output.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
</pre></div>
</div>
<p>The depth of two, ensures that only two levels of nesting are copied.
If the output files have dynamic names that one cannot know beforehand, the <code class="docutils literal notranslate"><span class="pre">'*'</span></code> glob pattern can be used.
For example, if the code will generate a number of XML files in the folder <code class="docutils literal notranslate"><span class="pre">relative/path/output</span></code> with filenames that follow the pattern <code class="docutils literal notranslate"><span class="pre">file_*[0-9].xml</span></code>, you can instruct to retrieve all of them as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">calc_info</span><span class="o">.</span><span class="n">retrieve_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;relative/path/output/file_*[0-9].xml&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>The second item when using globbing <em>has</em> to be <code class="docutils literal notranslate"><span class="pre">'.'</span></code> and the depth works just as before.
In this example, all files matching the globbing pattern will be copied in the directory <code class="docutils literal notranslate"><span class="pre">output</span></code> in the retrieved folder data node.</p>
</div>
<div class="section" id="retrieve-temporary-list">
<h4>Retrieve temporary list<a class="headerlink" href="#retrieve-temporary-list" title="Permalink to this headline">¶</a></h4>
<p>Recall that, as explained in the <a class="reference internal" href="#working-calcjobs-prepare"><span class="std std-ref">‘prepare’ section</span></a>, all the files that are retrieved by the engine following the ‘retrieve list’, are stored in the <code class="docutils literal notranslate"><span class="pre">retrieved</span></code> folder data node.
This means that any file you retrieve for a completed calculation job will be stored in your repository.
If you are retrieving big files, this can cause your repository to grow significantly.
Often, however, you might only need a part of the information contained in these retrieved files.
To solve this common issue, there is the concept of the ‘retrieve temporary list’.
The specification of the retrieve temporary list is identical to that of the normal <a class="reference internal" href="#working-calcjobs-file-lists-retrieve"><span class="std std-ref">retrieve list</span></a>.
The only difference is that, unlike the files of the retrieve list which will be permanently stored in the retrieved <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.folder.FolderData" title="aiida.orm.nodes.data.folder.FolderData"><code class="xref py py-class docutils literal notranslate"><span class="pre">FolderData</span></code></a> node, the files of the retrieve temporary list will be stored in a temporary sandbox folder.
This folder is then passed to the <a class="reference internal" href="#working-calcjobs-parsers"><span class="std std-ref">parser</span></a>, if one was specified for the calculation job.
The parser implementation can then parse these files and store the relevant information as output nodes.
After the parser terminates, the engine will take care to automatically clean up the sandbox folder with the temporarily retrieved files.
The contract of the ‘retrieve temporary list’ is essentially that the files will be available during parsing and will be destroyed immediately afterwards.</p>
</div>
</div>
<div class="section" id="options">
<span id="working-calcjobs-options"></span><h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>In addition to the common metadata inputs, such as <code class="docutils literal notranslate"><span class="pre">label</span></code> and <code class="docutils literal notranslate"><span class="pre">description</span></code>, that all processes have, the <a class="reference internal" href="../apidoc/aiida.engine.processes.calcjobs.html#aiida.engine.processes.calcjobs.calcjob.CalcJob" title="aiida.engine.processes.calcjobs.calcjob.CalcJob"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalcJob</span></code></a> has an additonal input called <code class="docutils literal notranslate"><span class="pre">options</span></code>.
These options allow to subtly change the behavior of the calculation job, for example which parser should be used once it is finished and special scheduler directives.
The full list of available options are documented below as part of the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> interface:</p>
<dl class="class">
<dt>
<em class="property">calcjob</em><code class="sig-prename descclassname">aiida.engine.processes.calcjobs.</code><code class="sig-name descname">CalcJob</code></dt>
<dd><p>Implementation of the CalcJob process.</p>
<p><strong>Inputs:</strong><ul>
<li><strong>code</strong>, <em>Code</em>, required – The <cite>Code</cite> to use for this job.</li>
<li><strong>metadata</strong>, <em>Namespace</em><details open="open">
<summary>
Namespace Ports</summary><ul>
<li><strong>call_link_label</strong>, <em>str</em>, optional, <em>non_db</em> – The label to use for the <cite>CALL</cite> link if the process is called by another process.</li>
<li><strong>computer</strong>, <em>Computer</em>, optional, <em>non_db</em> – When using a “local” code, set the computer on which the calculation should be run.</li>
<li><strong>description</strong>, <em>str</em>, optional, <em>non_db</em> – Description to set on the process node.</li>
<li><strong>dry_run</strong>, <em>bool</em>, optional, <em>non_db</em> – When set to <cite>True</cite> will prepare the calculation job for submission but not actually launch it.</li>
<li><strong>label</strong>, <em>str</em>, optional, <em>non_db</em> – Label to set on the process node.</li>
<li><strong>options</strong>, <em>Namespace</em><details open="open">
<summary>
Namespace Ports</summary><ul>
<li><strong>account</strong>, <em>str</em>, optional, <em>non_db</em> – Set the account to use in for the queue on the remote computer</li>
<li><strong>append_text</strong>, <em>str</em>, optional, <em>non_db</em> – Set the calculation-specific append text, which is going to be appended in the scheduler-job script, just after the code execution</li>
<li><strong>custom_scheduler_commands</strong>, <em>str</em>, optional, <em>non_db</em> – Set a (possibly multiline) string with the commands that the user wants to manually set for the scheduler. The difference of this option with respect to the <cite>prepend_text</cite> is the position in the scheduler submission file where such text is inserted: with this option, the string is inserted before any non-scheduler command</li>
<li><strong>environment_variables</strong>, <em>dict</em>, optional, <em>non_db</em> – Set a dictionary of custom environment variables for this calculation</li>
<li><strong>import_sys_environment</strong>, <em>bool</em>, optional, <em>non_db</em> – If set to true, the submission script will load the system environment variables</li>
<li><strong>input_filename</strong>, <em>str</em>, optional, <em>non_db</em> – Filename to which the input for the code that is to be run is written.</li>
<li><strong>max_memory_kb</strong>, <em>int</em>, optional, <em>non_db</em> – Set the maximum memory (in KiloBytes) to be asked to the scheduler</li>
<li><strong>max_wallclock_seconds</strong>, <em>int</em>, optional, <em>non_db</em> – Set the wallclock in seconds asked to the scheduler</li>
<li><strong>mpirun_extra_params</strong>, <em>(list, tuple)</em>, optional, <em>non_db</em> – Set the extra params to pass to the mpirun (or equivalent) command after the one provided in computer.mpirun_command. Example: mpirun -np 8 extra_params[0] extra_params[1] … exec.x</li>
<li><strong>output_filename</strong>, <em>str</em>, optional, <em>non_db</em> – Filename to which the content of stdout of the code that is to be run is written.</li>
<li><strong>parser_name</strong>, <em>str</em>, optional, <em>non_db</em> – Set a string for the output parser. Can be None if no output plugin is available or needed</li>
<li><strong>prepend_text</strong>, <em>str</em>, optional, <em>non_db</em> – Set the calculation-specific prepend text, which is going to be prepended in the scheduler-job script, just before the code execution</li>
<li><strong>priority</strong>, <em>str</em>, optional, <em>non_db</em> – Set the priority of the job to be queued</li>
<li><strong>qos</strong>, <em>str</em>, optional, <em>non_db</em> – Set the quality of service to use in for the queue on the remote computer</li>
<li><strong>queue_name</strong>, <em>str</em>, optional, <em>non_db</em> – Set the name of the queue on the remote computer</li>
<li><strong>resources</strong>, <em>dict</em>, required, <em>non_db</em> – Set the dictionary of resources to be used by the scheduler plugin, like the number of nodes, cpus etc. This dictionary is scheduler-plugin dependent. Look at the documentation of the scheduler for more details.</li>
<li><strong>scheduler_stderr</strong>, <em>str</em>, optional, <em>non_db</em> – Filename to which the content of stderr of the scheduler is written.</li>
<li><strong>scheduler_stdout</strong>, <em>str</em>, optional, <em>non_db</em> – Filename to which the content of stdout of the scheduler is written.</li>
<li><strong>submit_script_filename</strong>, <em>str</em>, optional, <em>non_db</em> – Filename to which the job submission script is written.</li>
<li><strong>withmpi</strong>, <em>bool</em>, optional, <em>non_db</em> – Set the calculation to use mpi</li>
</ul>
</details></li>
<li><strong>store_provenance</strong>, <em>bool</em>, optional, <em>non_db</em> – If set to <cite>False</cite> provenance will not be stored in the database.</li>
</ul>
</details></li>
</ul>
</p>
<p><strong>Outputs:</strong><ul>
<li><strong>remote_folder</strong>, <em>RemoteData</em>, required – Input files necessary to run the process will be stored in this folder node.</li>
<li><strong>retrieved</strong>, <em>FolderData</em>, required – Files that are retrieved by the daemon will be stored in this node. By default the stdout and stderr of the scheduler will be added, but one can add more by specifying them in <cite>CalcInfo.retrieve_list</cite>.</li>
</ul>
</p>
</dd></dl>

</div>
<div class="section" id="launch">
<span id="working-calcjobs-launch"></span><h3>Launch<a class="headerlink" href="#launch" title="Permalink to this headline">¶</a></h3>
<p>Launching a calculation job is no different from launching any other process class, so please refer to the section on <a class="reference internal" href="processes.html#working-processes-launch"><span class="std std-ref">launching processes</span></a>.
The only caveat that we should place is that calculation jobs typically tend to take quite a bit of time.
The trivial example we used above of course will run very fast, but a typical calculation job that will be submitted to a scheduler will most likely take longer than just a few seconds.
For that reason it is highly advisable to <strong>submit</strong> calculation jobs instead of running them.
By submitting them to the daemon, you free up your interpreter straight away and the process will be checkpointed between the various <a class="reference internal" href="../concepts/calculations.html#concepts-calcjobs-transport-tasks"><span class="std std-ref">transport tasks</span></a> that will have to be performed.
The exception is of course when you want to run a calculation job locally for testing or demonstration purposes.</p>
</div>
<div class="section" id="dry-run">
<span id="working-calcjobs-dry-run"></span><h3>Dry run<a class="headerlink" href="#dry-run" title="Permalink to this headline">¶</a></h3>
<p>The calculation job has one additional feature over all other processes when it comes to launching them.
Since an incorrectly configured calculation job can potentially waste computational resources, one might want to inspect the input files that will be written by the plugin, before actually submitting the job.
A so-called dry-run is possible by simply specifying it in the metadata of the inputs.
If you are using the process builder, it is as simple as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dry_run</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>When you now launch the process builder, the engine will perform the entire process of a normal calculation job run, except that it will not actually upload and submit the job to the remote computer.
However, the <code class="docutils literal notranslate"><span class="pre">prepare_for_submission</span></code> method will be called.
The inputs that it writes to the input folder will be stored in temporary folder called <code class="docutils literal notranslate"><span class="pre">submit_test</span></code> that will be created in the current working directory.
Each time you perform a dry-run, a new sub folder will be created in the <code class="docutils literal notranslate"><span class="pre">submit_test</span></code> folder, which you allows you to perform multiple dry-runs without overwriting the previous results.</p>
<p>Moreover, the following applies:</p>
<ul class="simple">
<li><p>when calling <a class="reference internal" href="../apidoc/aiida.engine.html#aiida.engine.launch.run" title="aiida.engine.launch.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> for a calculation with the
<code class="docutils literal notranslate"><span class="pre">dry_run</span></code> flag set, you will get back its results, being always an empty dictionary <code class="docutils literal notranslate"><span class="pre">{}</span></code>;</p></li>
<li><p>if you call <a class="reference internal" href="../apidoc/aiida.engine.html#aiida.engine.launch.run_get_node" title="aiida.engine.launch.run_get_node"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_get_node()</span></code></a>, you will get back as a node
an unstored <code class="docutils literal notranslate"><span class="pre">CalcJobNode</span></code>. In this case, the unstored <code class="docutils literal notranslate"><span class="pre">CalcJobNode</span></code> (let’s call it
<code class="docutils literal notranslate"><span class="pre">node</span></code>) will have an additional property <code class="docutils literal notranslate"><span class="pre">node.dry_run_info</span></code>. This is a dictionary
that contains additional information on the dry-run output. In particular, it will have
the following keys:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">folder</span></code>: the absolute path to the folder within the <code class="docutils literal notranslate"><span class="pre">submit_test</span></code> folder
where the files have been created, e.g.: <code class="docutils literal notranslate"><span class="pre">/home/user/submit_test/20190726-00019</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">script_filename</span></code>: the filename of the submission script that AiiDA generated
in the folder, e.g.: <code class="docutils literal notranslate"><span class="pre">_aiidasubmit.sh</span></code></p></li>
</ul>
</li>
<li><p>if you send a dry-run to the <a class="reference internal" href="../apidoc/aiida.engine.html#aiida.engine.launch.submit" title="aiida.engine.launch.submit"><code class="xref py py-func docutils literal notranslate"><span class="pre">submit()</span></code></a> function,
this will be just forwarded to run and you will get back the unstored node
(with the same properties as above).</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>By default the storing of provenance is enabled and this goes also for a dry run.
If you do not want any nodes to be created during a dry run, simply set the metadata input <code class="docutils literal notranslate"><span class="pre">store_provenance</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</div>
</div>
<div class="section" id="parsing">
<span id="working-calcjobs-parsers"></span><h3>Parsing<a class="headerlink" href="#parsing" title="Permalink to this headline">¶</a></h3>
<p>The previous sections explained in detail how the execution of an external executable is wrapped by the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> class to make it runnable by AiiDA’s engine.
From the first steps of preparing the input files on the remote machine, to retrieving the relevant files and storing them in a <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.folder.FolderData" title="aiida.orm.nodes.data.folder.FolderData"><code class="xref py py-class docutils literal notranslate"><span class="pre">FolderData</span></code></a> node, that is attached as the <code class="docutils literal notranslate"><span class="pre">retrieved</span></code> output.
This is the last <em>required</em> step for a <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> to terminate, but often we would <em>like</em> to parse the raw output and attach them as queryable output nodes to the calculation job node.
To automatically trigger the parsing of a calculation job after its output has been retrieved, is to specify the <a class="reference internal" href="#working-calcjobs-options"><span class="std std-ref">parser name option</span></a>.
If the engine find this option specified, it will load the corresponding parser class, which should be a sub class of <a class="reference internal" href="../apidoc/aiida.parsers.html#aiida.parsers.parser.Parser" title="aiida.parsers.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> and calls its <a class="reference internal" href="../apidoc/aiida.parsers.html#aiida.parsers.parser.Parser.parse" title="aiida.parsers.parser.Parser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a> method.</p>
<p>To explain the interface of the <code class="docutils literal notranslate"><span class="pre">Parser</span></code> class and the <code class="docutils literal notranslate"><span class="pre">parse</span></code> method, let’s take the <a class="reference internal" href="../apidoc/aiida.parsers.plugins.arithmetic.html#aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser" title="aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArithmeticAddParser</span></code></a> as an example.
This parser is designed to parse the output produced by the simple bash script that is wrapped by the <code class="docutils literal notranslate"><span class="pre">ArithmeticAddCalculation</span></code> discussed in the previous sections.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.common</span> <span class="kn">import</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">Int</span>
<span class="kn">from</span> <span class="nn">aiida.parsers.parser</span> <span class="kn">import</span> <span class="n">Parser</span>


<span class="k">class</span> <span class="nc">ArithmeticAddParser</span><span class="p">(</span><span class="n">Parser</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the contents of the output files retrieved in the `FolderData`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">output_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieved</span>
        <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">NotExistent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_codes</span><span class="o">.</span><span class="n">ERROR_NO_RETRIEVED_FOLDER</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">output_folder</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;output_filename&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_stdout</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_codes</span><span class="o">.</span><span class="n">ERROR_READING_OUTPUT_FILE</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_codes</span><span class="o">.</span><span class="n">ERROR_INVALID_OUTPUT</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">Int</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse_stdout</span><span class="p">(</span><span class="n">filelike</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the sum from the output of the ArithmeticAddcalculation written to standard out</span>

<span class="sd">        :param filelike: filelike object containing the output</span>
<span class="sd">        :returns: the sum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">filelike</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</td></tr></table></div>
<p>To create a new parser implementation, simply create a new class that sub classes the <a class="reference internal" href="../apidoc/aiida.parsers.html#aiida.parsers.parser.Parser" title="aiida.parsers.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> class.
As usual, any valid python class name will work, but the convention is to always use the <code class="docutils literal notranslate"><span class="pre">Parser</span></code> suffix and to use the same name as the calculation job for which the parser is designed.
For example, here we are implementing a parser for the <code class="docutils literal notranslate"><span class="pre">ArithmeticAddCalculation</span></code>, so therefore we name it <code class="docutils literal notranslate"><span class="pre">ArithmeticAddParser</span></code>, just replacing the <code class="docutils literal notranslate"><span class="pre">Calculation</span></code> suffix for <code class="docutils literal notranslate"><span class="pre">Parser</span></code>.
The only method that needs to be implemented is the <a class="reference internal" href="../apidoc/aiida.parsers.html#aiida.parsers.parser.Parser.parse" title="aiida.parsers.parser.Parser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a> method.
Its signature should include <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>, the reason for which will become clear later.
The goal of the <code class="docutils literal notranslate"><span class="pre">parse</span></code> method is very simple:</p>
<blockquote>
<div><ul class="simple">
<li><p>Open and load the content of the output files generated by the calculation job and have been retrieved by the engine</p></li>
<li><p>Create data nodes out of this raw data that are attached as output nodes</p></li>
<li><p>Log human-readable warning messages in the case of worrying output</p></li>
<li><p>Optionally return an <a class="reference internal" href="../concepts/processes.html#concepts-process-exit-codes"><span class="std std-ref">exit code</span></a> to indicate that the results of the calculation was not successful</p></li>
</ul>
</div></blockquote>
<p>The advantage of adding the raw output data in different form as output nodes, is that in that form the content becomes queryable.
This allows one to query for calculations that produced specific outputs with a certain value, which becomes a very powerful approach for post-processing and analyses of big databases.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">retrieved</span></code> attribute of the parser will return the <code class="docutils literal notranslate"><span class="pre">FolderData</span></code> node that should have been attached by the engine containing all the retrieved files, as specified using the <a class="reference internal" href="#working-calcjobs-file-lists-retrieve"><span class="std std-ref">retrieve list</span></a> in the <a class="reference internal" href="#working-calcjobs-prepare"><span class="std std-ref">preparation step of the calculation job</span></a>.
If this node has not been attached for whatever reason, this call will throw an <a class="reference internal" href="../apidoc/aiida.common.html#aiida.common.exceptions.NotExistent" title="aiida.common.exceptions.NotExistent"><code class="xref py py-class docutils literal notranslate"><span class="pre">NotExistent</span></code></a> exception.
This is why we wrap the <code class="docutils literal notranslate"><span class="pre">self.retrieved</span></code> call in a try-catch block:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">output_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieved</span>
        <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">NotExistent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_codes</span><span class="o">.</span><span class="n">ERROR_NO_RETRIEVED_FOLDER</span>
</pre></div>
</td></tr></table></div>
<p>If the exception is thrown, it means the retrieved files are not available and something must have has gone terribly awry with the calculation.
In this case, there is nothing to do for the parser and so we return an exit code.
Specific exit codes can be referenced by their label, such as <code class="docutils literal notranslate"><span class="pre">ERROR_NO_RETRIEVED_FOLDER</span></code> in this example, through the <code class="docutils literal notranslate"><span class="pre">self.exit_codes</span></code> property.
This call will retrieve the corresponding exit code defined on the <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> that we are currently parsing.
Returning this exit code from the parser will stop the parsing immediately and will instruct the engine to set its exit status and exit message on the node of this calculation job.
This should scenario should however never occur, but it is just here as a safety.
If the exception would not be caught, the engine will catch the exception instead and set the process state of the corresponding calculation to <code class="docutils literal notranslate"><span class="pre">Excepted</span></code>.
Note that this will happen for any exception that occurs during parsing.</p>
<p>Assuming that everything went according to plan during the retrieval, we now have access to those retrieved files and can start to parse them.
In this example, there should be a single output file that was written by redirecting the standard output of the bash script that added the two integers.
The parser opens this file, reads its content and tries to parse the sum from it:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">output_folder</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;output_filename&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_stdout</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_codes</span><span class="o">.</span><span class="n">ERROR_READING_OUTPUT_FILE</span>
</pre></div>
</td></tr></table></div>
<p>Note that again we wrap this parsing action in a try-except block.
If the file cannot be found or cannot be read, we return the appropriate exit code.
The <code class="docutils literal notranslate"><span class="pre">parse_stdout</span></code> method is just a small utility function to separate the actual parsing of the data from the main parser code.
In this case, the parsing is so simple that we might have as well kept it in the main method, but this is just to illustrate that you are completely free to organize the code within the <code class="docutils literal notranslate"><span class="pre">parse</span></code> method for clarity.
If we manage to parse the sum, produced by the calculation, we wrap it in the appropriate <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.int.Int" title="aiida.orm.nodes.data.int.Int"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int</span></code></a> data node class, and register it as an output through the <code class="docutils literal notranslate"><span class="pre">out</span></code> method:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>24</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">Int</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>Note that if we encountered no problems, we do not have to return anything.
The engine will interpret this as the calculation having finished successfully.
You might now pose the question: “what part of the raw data should I parse and in what types of data nodes should I store it?”.
This not an easy question to answer in the general, because it will heavily depend on the type of raw output that is produced by the calculation and what parts you would like to be queryable.
However, we can give you some guidelines:</p>
<blockquote>
<div><ul class="simple">
<li><p>Store data that you might want to query for, in the lightweight data nodes, such as <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.dict.Dict" title="aiida.orm.nodes.data.dict.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a>, <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.list.List" title="aiida.orm.nodes.data.list.List"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></a> and <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.html#aiida.orm.nodes.data.structure.StructureData" title="aiida.orm.nodes.data.structure.StructureData"><code class="xref py py-class docutils literal notranslate"><span class="pre">StructureData</span></code></a>.
The contents of these nodes are stored as attributes in the database, which makes sure that they can be queried for.</p></li>
<li><p>Bigger data sets, such as large (multi-dimnensional) arrays, are better stored in an <a class="reference internal" href="../apidoc/aiida.orm.nodes.data.array.html#aiida.orm.nodes.data.array.array.ArrayData" title="aiida.orm.nodes.data.array.array.ArrayData"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrayData</span></code></a> or one of its sub classes.
If you were to store all this data in the database, it would become unnecessarily bloated, because the chances you would have to query for this data are unlikely.
Instead these array type data nodes store the bulk of their content in the repository.
This way you still keep the data and therewith the provenance of your calculations, while keeping your database lean and fast!</p></li>
</ul>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>